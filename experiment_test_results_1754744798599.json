{
  "timestamp": "2025-08-09T12:55:02.195Z",
  "testCases": [
    {
      "name": "简单物理模拟",
      "prompt": "创建一个简单的重力球下落模拟",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T12:55:02.199Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T12:56:26.260Z",
          "response": {
            "status": 200,
            "statusText": "OK",
            "headers": {
              "access-control-allow-origin": "*",
              "connection": "keep-alive",
              "content-length": "42987",
              "content-type": "application/json; charset=utf-8",
              "date": "Sat, 09 Aug 2025 12:56:26 GMT",
              "etag": "W/\"a7eb-WfmfbMLMDQuI7qjCLCf4b/ktWYg\"",
              "keep-alive": "timeout=5",
              "x-powered-by": "Express"
            },
            "data": {
              "success": true,
              "data": {
                "experiment_id": "234561a8-cc44-47b7-8ae9-1446ab40a762",
                "title": "重力球下落模拟",
                "description": "摘要（来自 Perplexity 的信息汇总）：\n- 重力下落可以用经典力学描述：在忽略空气阻力时，位移满足 y(t) = y0 + v0*t + 0.5*g*t^2，速度 v(t) = v0 + g*t（方向约定向下为正或负要一致）。若考虑阻力，可用数值积分（例如欧拉或更好的积分法）来近似解决。本文演示同时提供无阻力的解析解和含线性阻力的数值解，方便对比与教学。信息来源：Perplexity（Perplexity AI 研究）。\n\n下面给出一个完整可运行的 HTML 文件：它包含可调的初始高度、初速度、重力加速度、阻力系数（线性阻力可选）、播放/暂停/重置、实时数值显示、动画视图和位置-时间图。代码无外部依赖，可直接保存为 .html 后在浏览器打开运行。",
                "html_content": "<div class=\"container\">\n    <!-- 控件面板 -->\n    <div class=\"panel controls\" aria-label=\"模拟控制\">\n      <h2>重力球下落 模拟 控制面板</h2>\n      <div class=\"small\">单位：m（米），s（秒），m/s（速度）</div>\n\n      <label for=\"height\">初始高度 h0（米）: <span id=\"h0-val\">10</span></label>\n      <div class=\"row\">\n        <input id=\"height\" type=\"range\" min=\"0\" max=\"100\" step=\"0.5\" value=\"10\" aria-labelledby=\"height\">\n        <input id=\"height-num\" type=\"number\" min=\"0\" max=\"100\" step=\"0.1\" value=\"10\">\n      </div>\n\n      <label for=\"v0\">初速度 v0（m/s，向下为正）: <span id=\"v0-val\">0</span></label>\n      <div class=\"row\">\n        <input id=\"v0\" type=\"range\" min=\"-50\" max=\"50\" step=\"0.5\" value=\"0\">\n        <input id=\"v0-num\" type=\"number\" min=\"-50\" max=\"50\" step=\"0.1\" value=\"0\">\n      </div>\n\n      <label for=\"g\">重力加速度 g（m/s²）: <span id=\"g-val\">9.81</span></label>\n      <div class=\"row\">\n        <input id=\"g\" type=\"range\" min=\"0.1\" max=\"20\" step=\"0.01\" value=\"9.81\">\n        <input id=\"g-num\" type=\"number\" min=\"0.1\" max=\"20\" step=\"0.01\" value=\"9.81\">\n      </div>\n\n      <label for=\"drag\">线性阻力系数 b（kg/s，0 为无阻力）: <span id=\"b-val\">0</span></label>\n      <div class=\"row\">\n        <input id=\"drag\" type=\"range\" min=\"0\" max=\"5\" step=\"0.01\" value=\"0\">\n        <input id=\"drag-num\" type=\"number\" min=\"0\" max=\"5\" step=\"0.01\" value=\"0\">\n      </div>\n\n      <div class=\"toggle\" role=\"group\" aria-label=\"模拟选项\">\n        <input id=\"show-analytic\" type=\"checkbox\" checked>\n        <label for=\"show-analytic\" class=\"small\">显示无阻力解析解曲线（仅在 b=0 时严格对应）</label>\n      </div>\n\n      <div class=\"buttons\" role=\"group\" aria-label=\"播放按钮\">\n        <button id=\"play\">播放</button>\n        <button id=\"pause\" class=\"secondary\">暂停</button>\n        <button id=\"reset\" class=\"secondary\">重置</button>\n        <button id=\"step\" class=\"secondary\">单步（0.02s）</button>\n      </div>\n\n      <div class=\"footer-note\">\n        提示：修改参数后可以按“重置”或“播放”来观察新参数下的行为。解析解仅在无阻力时（b=0）可得精确结果；当启用阻力，使用数值积分近似。\n      </div>\n    </div>\n\n    <!-- 模拟显示面板 -->\n    <div class=\"panel sim-area\" aria-label=\"模拟显示\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n        <h3 style=\"margin:0\">模拟视图</h3>\n        <div class=\"legend small\" aria-hidden=\"true\">\n          <div style=\"display:flex;align-items:center\"><span class=\"dot\" style=\"background:#2b85ff\"></span> 球体</div>\n          <div style=\"display:flex;align-items:center\"><span class=\"dot\" style=\"background:#ff7a7a\"></span> 解析位置</div>\n          <div style=\"display:flex;align-items:center\"><span class=\"dot\" style=\"background:#3ad27a\"></span> 数值位置（带阻力）</div>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <canvas id=\"viewCanvas\" width=\"800\" height=\"420\" aria-label=\"可视化画布\"></canvas>\n        <canvas id=\"plotCanvas\" width=\"800\" height=\"160\" style=\"position:absolute;left:0;right:0;bottom:0;height:160px\"></canvas>\n      </div>\n\n      <div class=\"readouts\" aria-live=\"polite\">\n        <div class=\"readout\"><div class=\"small\">时间 t (s)</div><div id=\"time\" class=\"v\">0.00</div></div>\n        <div class=\"readout\"><div class=\"small\">高度 y (m)</div><div id=\"pos\" class=\"v\">10.00</div></div>\n        <div class=\"readout\"><div class=\"small\">速度 v (m/s)</div><div id=\"vel\" class=\"v\">0.00</div></div>\n        <div class=\"readout\"><div class=\"small\">加速度 a (m/s²)</div><div id=\"acc\" class=\"v\">-9.81</div></div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // 简要说明：\n    // - 我们把画布的顶部视为 y = maxHeight（地面为 y = 0）。为直观，将高度转换为像素（pixelsPerMeter）。\n    // - 无阻力解析解： y(t)=y0 + v0*t + 0.5*g*t^2 （若向下为正，这里我们用向上为正的常见约定，在显示时做适配）\n    // - 数值积分（带线性阻力 b）：使用改进欧拉/显式欧拉做简单近似： dv/dt = g - (b/m)*v 。此演示将质量 m 设为 1 kg（相对无损失，b 为每秒的阻力常数）。\n    // - UI 控件会同步滑条与数字框，支持播放/暂停/重置/单步。\n\n    // 获取 DOM\n    const heightSlider = document.getElementById('height');\n    const heightNum = document.getElementById('height-num');\n    const h0ValSpan = document.getElementById('h0-val');\n\n    const v0Slider = document.getElementById('v0');\n    const v0Num = document.getElementById('v0-num');\n    const v0ValSpan = document.getElementById('v0-val');\n\n    const gSlider = document.getElementById('g');\n    const gNum = document.getElementById('g-num');\n    const gValSpan = document.getElementById('g-val');\n\n    const dragSlider = document.getElementById('drag');\n    const dragNum = document.getElementById('drag-num');\n    const bValSpan = document.getElementById('b-val');\n\n    const showAnalytic = document.getElementById('show-analytic');\n\n    const playBtn = document.getElementById('play');\n    const pauseBtn = document.getElementById('pause');\n    const resetBtn = document.getElementById('reset');\n    const stepBtn = document.getElementById('step');\n\n    const timeRead = document.getElementById('time');\n    const posRead = document.getElementById('pos');\n    const velRead = document.getElementById('vel');\n    const accRead = document.getElementById('acc');\n\n    const canvas = document.getElementById('viewCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n\n    const plot = document.getElementById('plotCanvas');\n    const pctx = plot.getContext('2d', { alpha: true });\n\n    // 状态与参数\n    let params = {\n      h0: parseFloat(heightSlider.value), // 初始高度（m）\n      v0: parseFloat(v0Slider.value),     // 初速度（m/s，向下为正）\n      g: parseFloat(gSlider.value),       // 重力（m/s^2，向下为正）\n      b: parseFloat(dragSlider.value),    // 线性阻力系数（kg/s）\n      m: 1.0                              // 质量（kg），用于数值积分（设为1 kg）\n    };\n\n    // 仿真状态（数值解）\n    let state = {\n      t: 0,\n      y: params.h0, // 高度（m），以地面为 y=0，初始在 h0\n      v: params.v0, // 速度（m/s），向下为正\n      running: false\n    };\n\n    // 绘图尺度与尺寸\n    function getCanvasSize() {\n      // 获取实际绘制像素大小\n      const rect = canvas.getBoundingClientRect();\n      const scale = window.devicePixelRatio || 1;\n      canvas.width = Math.round(rect.width * scale);\n      canvas.height = Math.round(rect.height * scale);\n      // plot canvas positioned at bottom overlay — resize similarly\n      const prect = plot.getBoundingClientRect();\n      plot.width = Math.round(prect.width * scale);\n      plot.height = Math.round(prect.height * scale);\n      // returns pixel per meter for converting height to canvas y\n      // 留出顶部空间 20px 与底部 plot 高度\n      const topPadding = 16 * scale;\n      const bottomPlotHeight = plot.height;\n      const usablePx = canvas.height - bottomPlotHeight - topPadding - 20 * scale;\n      // 让最大高度（例如 1.2*h0 或至少 10m）可视化\n      const maxVisibleMeters = Math.max(params.h0 * 1.2, 10);\n      const pixelsPerMeter = usablePx / maxVisibleMeters;\n      return {scale, topPadding, bottomPlotHeight, pixelsPerMeter};\n    }\n\n    // 更新参数与同步 UI\n    function syncFromUI() {\n      params.h0 = parseFloat(heightNum.value) || 0;\n      heightSlider.value = params.h0;\n      h0ValSpan.textContent = params.h0;\n\n      params.v0 = parseFloat(v0Num.value) || 0;\n      v0Slider.value = params.v0;\n      v0ValSpan.textContent = params.v0;\n\n      params.g = parseFloat(gNum.value) || 9.81;\n      gSlider.value = params.g;\n      gValSpan.textContent = params.g;\n\n      params.b = parseFloat(dragNum.value) || 0;\n      dragSlider.value = params.b;\n      bValSpan.textContent = params.b;\n    }\n\n    // 事件绑定（同步滑块与数字框）\n    function bindRangeAndNumber(rangeEl, numEl, valSpan){\n      rangeEl.addEventListener('input', ()=> {\n        numEl.value = rangeEl.value;\n        syncFromUI();\n      });\n      numEl.addEventListener('change', ()=>{\n        // clamp within range\n        const min = parseFloat(rangeEl.min);\n        const max = parseFloat(rangeEl.max);\n        let v = parseFloat(numEl.value);\n        if (isNaN(v)) v = parseFloat(rangeEl.value);\n        v = Math.max(min, Math.min(max, v));\n        numEl.value = v;\n        rangeEl.value = v;\n        syncFromUI();\n      });\n    }\n    bindRangeAndNumber(heightSlider, heightNum, h0ValSpan);\n    bindRangeAndNumber(v0Slider, v0Num, v0ValSpan);\n    bindRangeAndNumber(gSlider, gNum, gValSpan);\n    bindRangeAndNumber(dragSlider, dragNum, bValSpan);\n\n    // 播放控制\n    playBtn.addEventListener('click', ()=>{\n      if (!state.running) {\n        state.running = true;\n        lastFrameTime = null;\n        requestAnimationFrame(mainLoop);\n      }\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.running = false;\n    });\n    resetBtn.addEventListener('click', ()=>{\n      // 重置初始状态（不改变参数）\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    });\n    stepBtn.addEventListener('click', ()=>{\n      // 单步 0.02 s\n      singleStep(0.02);\n      drawAll();\n    });\n\n    // 重置到默认并初始化绘图\n    function initialize() {\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    }\n\n    // 数值积分：显式欧拉（小步长）用于 dv/dt = g - (b/m)*v 和 dy/dt = v\n    function integrate(dt) {\n      // acceleration (向下为正)\n      const a = params.g - (params.b / params.m) * state.v;\n      // 更新\n      state.v += a * dt;\n      state.y -= state.v * dt; // 注意：我们用 y 为高度（地面为0），v 为向下为正 => y 减小\n      state.t += dt;\n      return a;\n    }\n\n    // 单步封装：检查是否触地（y<=0）\n    function singleStep(dt) {\n      if (state.y <= 0) return; // 已触地\n      // 如果没有阻力且启用解析显示，解析和数值应一致 — 但我们仍使用数值解用于动画（便于比较）\n      const a = integrate(dt);\n      if (state.y <= 0) {\n        state.y = 0;\n        state.v = 0;\n        state.running = false;\n      }\n      // 更新读数与记录绘图点\n      updateReadouts(a);\n      appendPlotPoint();\n    }\n\n    // 画布绘图函数\n    function clearPlot() {\n      const s = getCanvasSize();\n      // 绘制背景的 view canvas\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n      // 绘制 lower plot background\n      pctx.clearRect(0,0,plot.width,plot.height);\n      pctx.fillStyle = 'rgba(255,255,255,0.6)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n      // 初始化 plot data arrays\n      plotData = [];\n      analyticData = [];\n    }\n\n    // 存储绘图数据点\n    let plotData = []; // 数值：{t,y}\n    let analyticData = []; // 解析（b=0）：{t,y}\n\n    function appendPlotPoint() {\n      plotData.push({t: state.t, y: state.y});\n      // analytic data point up to current t if b==0 or we still draw analytic optionally\n      if (showAnalytic.checked) {\n        // compute analytic y (y0 - (v0*t + 0.5*g*t^2)) since y is height decreasing\n        const t = state.t;\n        const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n        analyticData.push({t: t, y: Math.max(0, yAnal)});\n      }\n    }\n\n    function drawAll() {\n      // Setup sizes\n      const s = getCanvasSize();\n      // clear background\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n\n      // Draw ground line\n      const groundYpx = canvas.height - s.bottomPlotHeight - 6 * s.scale;\n      ctx.fillStyle = '#c4d8ff';\n      ctx.fillRect(0, groundYpx, canvas.width, 6 * s.scale);\n\n      // Convert current height (m) to pixel Y\n      const toPixelY = (yMeters) => {\n        // highest visible meters we mapped earlier:\n        const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n        const usablePx = canvas.height - s.bottomPlotHeight - s.topPadding - 20 * s.scale;\n        const ppm = usablePx / maxVisMeters;\n        // top zero at s.topPadding\n        const ypx = s.topPadding + (maxVisMeters - yMeters) * ppm;\n        return ypx;\n      };\n\n      // Draw grid/scale ticks every 1m\n      const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n      const stepMeters = chooseStep(maxVisMeters);\n      ctx.strokeStyle = 'rgba(30,40,60,0.05)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.font = `${12 * s.scale}px system-ui`;\n      ctx.fillStyle = '#234';\n\n      for (let m = 0; m <= Math.ceil(maxVisMeters / stepMeters) * stepMeters; m += stepMeters) {\n        const yPx = toPixelY(m);\n        ctx.beginPath();\n        ctx.moveTo(0, yPx);\n        ctx.lineTo(canvas.width, yPx);\n        ctx.stroke();\n        // label on left\n        ctx.fillText(`${m.toFixed(0)} m`, 6 * s.scale, yPx - 4 * s.scale);\n      }\n\n      // Draw analytic curve (if requested)\n      if (showAnalytic.checked) {\n        // compute series of points for analytic curve until hits ground or up to certain time\n        const color = '#ff7a7a';\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        const steps = 200;\n        let started = false;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n          if (yAnal <= 0) {\n            // reached ground, draw endpoint and break\n            const x = (t / maxT) * canvas.width;\n            const y = toPixelY(0);\n            if (!started) ctx.moveTo(x, y);\n            else ctx.lineTo(x, y);\n            break;\n          }\n          const x = (t / maxT) * canvas.width;\n          const y = toPixelY(yAnal);\n          if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw numerical solution path (stored in plotData)\n      if (plotData.length > 1) {\n        ctx.strokeStyle = '#3ad27a';\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = (p.t / maxT) * canvas.width;\n          const y = toPixelY(p.y);\n          if (i === 0) ctx.moveTo(x,y);\n          else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw the ball at current numeric state\n      const ballX = canvas.width * 0.15;\n      const ballYpx = toPixelY(state.y);\n      const ballRadius = 14 * s.scale;\n      // shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\n      ctx.ellipse(ballX + 6 * s.scale, groundYpx - 6 * s.scale, 28 * s.scale, 6 * s.scale, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball\n      ctx.beginPath();\n      const grd = ctx.createLinearGradient(ballX - ballRadius, ballYpx - ballRadius, ballX + ballRadius, ballYpx + ballRadius);\n      grd.addColorStop(0, '#2b85ff');\n      grd.addColorStop(1, '#1d4db3');\n      ctx.fillStyle = grd;\n      ctx.arc(ballX, ballYpx, ballRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball outline\n      ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.stroke();\n\n      // Draw small text: current numeric and analytic positions on right\n      ctx.fillStyle = '#123';\n      ctx.font = `${14 * s.scale}px system-ui`;\n      ctx.fillText(`数值 y = ${state.y.toFixed(3)} m`, canvas.width * 0.55, s.topPadding + 20 * s.scale);\n      const vSign = state.v;\n      ctx.fillText(`v = ${vSign.toFixed(3)} m/s`, canvas.width * 0.55, s.topPadding + 44 * s.scale);\n      // draw ground label\n      ctx.fillText('地面', 8 * s.scale, groundYpx + 18 * s.scale);\n      // draw axis for time along bottom (just a reference)\n      drawBottomPlot();\n    }\n\n    // 选择合理的刻度步长（米）\n    function chooseStep(maxMeters) {\n      if (maxMeters <= 10) return 1;\n      if (maxMeters <= 30) return 2;\n      if (maxMeters <= 60) return 5;\n      return 10;\n    }\n\n    // 绘制底部趋势图（位置随时间）\n    function drawBottomPlot() {\n      const s = getCanvasSize();\n      // clear plot overlay\n      pctx.clearRect(0,0,plot.width,plot.height);\n      // background\n      pctx.fillStyle = 'rgba(255,255,255,0.82)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n\n      // draw axes\n      pctx.strokeStyle = 'rgba(30,40,60,0.12)';\n      pctx.lineWidth = 1 * s.scale;\n      pctx.beginPath();\n      pctx.moveTo(40 * s.scale, 10 * s.scale);\n      pctx.lineTo(40 * s.scale, plot.height - 24 * s.scale);\n      pctx.lineTo(plot.width - 10 * s.scale, plot.height - 24 * s.scale);\n      pctx.stroke();\n\n      // determine time window\n      const maxT = Math.max(2, state.t + 1.5);\n      // draw numeric data (green)\n      if (plotData.length > 0) {\n        pctx.strokeStyle = '#3ad27a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = 40 * s.scale + (p.t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - p.y) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y);\n          else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // analytic (red)\n      if (showAnalytic.checked) {\n        pctx.strokeStyle = '#ff7a7a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        const steps = 150;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = Math.max(0, params.h0 - (params.v0 * t + 0.5 * params.g * t * t));\n          const x = 40 * s.scale + (t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - yAnal) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y); else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // axis labels\n      pctx.fillStyle = '#234';\n      pctx.font = `${11 * s.scale}px system-ui`;\n      pctx.fillText('t (s)', plot.width - 50 * s.scale, plot.height - 8 * s.scale);\n      pctx.fillText('下降量 (m)', 6 * s.scale, 14 * s.scale);\n    }\n\n    // 更新数值读出\n    function updateReadouts(acc){\n      timeRead.textContent = state.t.toFixed(2);\n      posRead.textContent = state.y.toFixed(3);\n      velRead.textContent = state.v.toFixed(3);\n      // 加速度显示为向下为正，因此显示为 +g... 但为更直观，显示为负值（向下加速使高度负二阶）\n      // 这里我们显示加速度的代数值（向下为正）\n      const a = acc === undefined ? (params.g - params.b / params.m * state.v) : acc;\n      accRead.textContent = a.toFixed(3);\n    }\n\n    // 主循环（使用 requestAnimationFrame，按真实时间步进）\n    let lastFrameTime = null;\n    function mainLoop(timestamp) {\n      if (!state.running) return;\n      if (!lastFrameTime) lastFrameTime = timestamp;\n      const dtSec = Math.min(0.05, (timestamp - lastFrameTime) / 1000); // 限制最大步长\n      lastFrameTime = timestamp;\n\n      // 做若干小步以提高数值稳定性（分割，避免过大 dt）\n      const subSteps = Math.max(1, Math.ceil(dtSec / 0.01));\n      let acc = 0;\n      for (let i = 0; i < subSteps; i++) {\n        acc = integrate(dtSec / subSteps);\n        appendPlotPoint();\n        if (state.y <= 0) {\n          state.y = 0;\n          state.v = 0;\n          state.running = false;\n          break;\n        }\n      }\n      updateReadouts(acc);\n      drawAll();\n\n      if (state.running) requestAnimationFrame(mainLoop);\n    }\n\n    // 初始化并监听窗口尺寸变化\n    window.addEventListener('resize', ()=> {\n      drawAll();\n    });\n\n    // 初始化\n    initialize();\n\n    // 键盘快捷键（空格播放/暂停，r 重置）\n    window.addEventListener('keydown', (e)=>{\n      if (e.code === 'Space') {\n        e.preventDefault();\n        if (state.running) pauseBtn.click(); else playBtn.click();\n      } else if (e.key === 'r' || e.key === 'R') {\n        resetBtn.click();\n      }\n    });\n\n    // 初次绘制\n    drawAll();\n  </script>",
                "css_content": ":root{\n      --bg:#f6f8fa;\n      --card:#ffffff;\n      --accent:#2b85ff;\n      --muted:#666;\n      --danger:#e64b4b;\n    }\n    body{\n      margin:0;\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background:linear-gradient(180deg,#eef4ff 0%,var(--bg) 60%);\n      color:#222;\n      display:flex;\n      min-height:100vh;\n      align-items:flex-start;\n      justify-content:center;\n      padding:24px;\n      box-sizing:border-box;\n    }\n    .container{\n      width:100%;\n      max-width:1100px;\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:20px;\n      align-items:start;\n    }\n    .panel{\n      background:var(--card);\n      border-radius:10px;\n      box-shadow:0 6px 18px rgba(30,40,60,0.08);\n      padding:16px;\n    }\n    .controls h2{\n      margin:0 0 8px 0;\n      font-size:18px;\n    }\n    label{\n      display:block;\n      margin:10px 0 6px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .row{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    input[type=\"range\"]{\n      width:100%;\n    }\n    input[type=\"number\"]{\n      width:100px;\n      padding:6px 8px;\n      border-radius:6px;\n      border:1px solid #d6dbe6;\n    }\n    .small{\n      font-size:12px;\n      color:var(--muted);\n    }\n    .buttons{\n      display:flex;\n      gap:8px;\n      margin-top:12px;\n    }\n    button{\n      background:var(--accent);\n      color:white;\n      border:none;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow:0 6px 14px rgba(43,133,255,0.18);\n    }\n    button.secondary{\n      background:#f3f6fb;\n      color:#214;\n      box-shadow:none;\n      font-weight:600;\n    }\n    button.danger{\n      background:var(--danger);\n      box-shadow:none;\n    }\n    .sim-area{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .canvas-wrap{\n      background: linear-gradient(180deg,#e9f0ff 0%, #ffffff 60%);\n      border:1px solid rgba(30,40,60,0.06);\n      height:420px;\n      border-radius:10px;\n      position:relative;\n      overflow:hidden;\n    }\n    canvas{\n      width:100%;\n      height:100%;\n      display:block;\n    }\n    .readouts{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n    .readout{\n      background:#fff;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid #eef3fb;\n      min-width:120px;\n      text-align:center;\n    }\n    .readout .v{\n      font-size:18px;\n      font-weight:700;\n    }\n    .footer-note{\n      font-size:12px;\n      color:var(--muted);\n      margin-top:8px;\n    }\n    .toggle{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      margin-top:6px;\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n      margin-top:6px;\n    }\n    .legend .dot{\n      width:12px;height:12px;border-radius:50%;\n      display:inline-block;\n      margin-right:6px;\n    }\n    @media (max-width:900px){\n      .container{grid-template-columns:1fr; padding:0 8px;}\n    }",
                "js_content": "// 简要说明：\n    // - 我们把画布的顶部视为 y = maxHeight（地面为 y = 0）。为直观，将高度转换为像素（pixelsPerMeter）。\n    // - 无阻力解析解： y(t)=y0 + v0*t + 0.5*g*t^2 （若向下为正，这里我们用向上为正的常见约定，在显示时做适配）\n    // - 数值积分（带线性阻力 b）：使用改进欧拉/显式欧拉做简单近似： dv/dt = g - (b/m)*v 。此演示将质量 m 设为 1 kg（相对无损失，b 为每秒的阻力常数）。\n    // - UI 控件会同步滑条与数字框，支持播放/暂停/重置/单步。\n\n    // 获取 DOM\n    const heightSlider = document.getElementById('height');\n    const heightNum = document.getElementById('height-num');\n    const h0ValSpan = document.getElementById('h0-val');\n\n    const v0Slider = document.getElementById('v0');\n    const v0Num = document.getElementById('v0-num');\n    const v0ValSpan = document.getElementById('v0-val');\n\n    const gSlider = document.getElementById('g');\n    const gNum = document.getElementById('g-num');\n    const gValSpan = document.getElementById('g-val');\n\n    const dragSlider = document.getElementById('drag');\n    const dragNum = document.getElementById('drag-num');\n    const bValSpan = document.getElementById('b-val');\n\n    const showAnalytic = document.getElementById('show-analytic');\n\n    const playBtn = document.getElementById('play');\n    const pauseBtn = document.getElementById('pause');\n    const resetBtn = document.getElementById('reset');\n    const stepBtn = document.getElementById('step');\n\n    const timeRead = document.getElementById('time');\n    const posRead = document.getElementById('pos');\n    const velRead = document.getElementById('vel');\n    const accRead = document.getElementById('acc');\n\n    const canvas = document.getElementById('viewCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n\n    const plot = document.getElementById('plotCanvas');\n    const pctx = plot.getContext('2d', { alpha: true });\n\n    // 状态与参数\n    let params = {\n      h0: parseFloat(heightSlider.value), // 初始高度（m）\n      v0: parseFloat(v0Slider.value),     // 初速度（m/s，向下为正）\n      g: parseFloat(gSlider.value),       // 重力（m/s^2，向下为正）\n      b: parseFloat(dragSlider.value),    // 线性阻力系数（kg/s）\n      m: 1.0                              // 质量（kg），用于数值积分（设为1 kg）\n    };\n\n    // 仿真状态（数值解）\n    let state = {\n      t: 0,\n      y: params.h0, // 高度（m），以地面为 y=0，初始在 h0\n      v: params.v0, // 速度（m/s），向下为正\n      running: false\n    };\n\n    // 绘图尺度与尺寸\n    function getCanvasSize() {\n      // 获取实际绘制像素大小\n      const rect = canvas.getBoundingClientRect();\n      const scale = window.devicePixelRatio || 1;\n      canvas.width = Math.round(rect.width * scale);\n      canvas.height = Math.round(rect.height * scale);\n      // plot canvas positioned at bottom overlay — resize similarly\n      const prect = plot.getBoundingClientRect();\n      plot.width = Math.round(prect.width * scale);\n      plot.height = Math.round(prect.height * scale);\n      // returns pixel per meter for converting height to canvas y\n      // 留出顶部空间 20px 与底部 plot 高度\n      const topPadding = 16 * scale;\n      const bottomPlotHeight = plot.height;\n      const usablePx = canvas.height - bottomPlotHeight - topPadding - 20 * scale;\n      // 让最大高度（例如 1.2*h0 或至少 10m）可视化\n      const maxVisibleMeters = Math.max(params.h0 * 1.2, 10);\n      const pixelsPerMeter = usablePx / maxVisibleMeters;\n      return {scale, topPadding, bottomPlotHeight, pixelsPerMeter};\n    }\n\n    // 更新参数与同步 UI\n    function syncFromUI() {\n      params.h0 = parseFloat(heightNum.value) || 0;\n      heightSlider.value = params.h0;\n      h0ValSpan.textContent = params.h0;\n\n      params.v0 = parseFloat(v0Num.value) || 0;\n      v0Slider.value = params.v0;\n      v0ValSpan.textContent = params.v0;\n\n      params.g = parseFloat(gNum.value) || 9.81;\n      gSlider.value = params.g;\n      gValSpan.textContent = params.g;\n\n      params.b = parseFloat(dragNum.value) || 0;\n      dragSlider.value = params.b;\n      bValSpan.textContent = params.b;\n    }\n\n    // 事件绑定（同步滑块与数字框）\n    function bindRangeAndNumber(rangeEl, numEl, valSpan){\n      rangeEl.addEventListener('input', ()=> {\n        numEl.value = rangeEl.value;\n        syncFromUI();\n      });\n      numEl.addEventListener('change', ()=>{\n        // clamp within range\n        const min = parseFloat(rangeEl.min);\n        const max = parseFloat(rangeEl.max);\n        let v = parseFloat(numEl.value);\n        if (isNaN(v)) v = parseFloat(rangeEl.value);\n        v = Math.max(min, Math.min(max, v));\n        numEl.value = v;\n        rangeEl.value = v;\n        syncFromUI();\n      });\n    }\n    bindRangeAndNumber(heightSlider, heightNum, h0ValSpan);\n    bindRangeAndNumber(v0Slider, v0Num, v0ValSpan);\n    bindRangeAndNumber(gSlider, gNum, gValSpan);\n    bindRangeAndNumber(dragSlider, dragNum, bValSpan);\n\n    // 播放控制\n    playBtn.addEventListener('click', ()=>{\n      if (!state.running) {\n        state.running = true;\n        lastFrameTime = null;\n        requestAnimationFrame(mainLoop);\n      }\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.running = false;\n    });\n    resetBtn.addEventListener('click', ()=>{\n      // 重置初始状态（不改变参数）\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    });\n    stepBtn.addEventListener('click', ()=>{\n      // 单步 0.02 s\n      singleStep(0.02);\n      drawAll();\n    });\n\n    // 重置到默认并初始化绘图\n    function initialize() {\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    }\n\n    // 数值积分：显式欧拉（小步长）用于 dv/dt = g - (b/m)*v 和 dy/dt = v\n    function integrate(dt) {\n      // acceleration (向下为正)\n      const a = params.g - (params.b / params.m) * state.v;\n      // 更新\n      state.v += a * dt;\n      state.y -= state.v * dt; // 注意：我们用 y 为高度（地面为0），v 为向下为正 => y 减小\n      state.t += dt;\n      return a;\n    }\n\n    // 单步封装：检查是否触地（y<=0）\n    function singleStep(dt) {\n      if (state.y <= 0) return; // 已触地\n      // 如果没有阻力且启用解析显示，解析和数值应一致 — 但我们仍使用数值解用于动画（便于比较）\n      const a = integrate(dt);\n      if (state.y <= 0) {\n        state.y = 0;\n        state.v = 0;\n        state.running = false;\n      }\n      // 更新读数与记录绘图点\n      updateReadouts(a);\n      appendPlotPoint();\n    }\n\n    // 画布绘图函数\n    function clearPlot() {\n      const s = getCanvasSize();\n      // 绘制背景的 view canvas\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n      // 绘制 lower plot background\n      pctx.clearRect(0,0,plot.width,plot.height);\n      pctx.fillStyle = 'rgba(255,255,255,0.6)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n      // 初始化 plot data arrays\n      plotData = [];\n      analyticData = [];\n    }\n\n    // 存储绘图数据点\n    let plotData = []; // 数值：{t,y}\n    let analyticData = []; // 解析（b=0）：{t,y}\n\n    function appendPlotPoint() {\n      plotData.push({t: state.t, y: state.y});\n      // analytic data point up to current t if b==0 or we still draw analytic optionally\n      if (showAnalytic.checked) {\n        // compute analytic y (y0 - (v0*t + 0.5*g*t^2)) since y is height decreasing\n        const t = state.t;\n        const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n        analyticData.push({t: t, y: Math.max(0, yAnal)});\n      }\n    }\n\n    function drawAll() {\n      // Setup sizes\n      const s = getCanvasSize();\n      // clear background\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n\n      // Draw ground line\n      const groundYpx = canvas.height - s.bottomPlotHeight - 6 * s.scale;\n      ctx.fillStyle = '#c4d8ff';\n      ctx.fillRect(0, groundYpx, canvas.width, 6 * s.scale);\n\n      // Convert current height (m) to pixel Y\n      const toPixelY = (yMeters) => {\n        // highest visible meters we mapped earlier:\n        const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n        const usablePx = canvas.height - s.bottomPlotHeight - s.topPadding - 20 * s.scale;\n        const ppm = usablePx / maxVisMeters;\n        // top zero at s.topPadding\n        const ypx = s.topPadding + (maxVisMeters - yMeters) * ppm;\n        return ypx;\n      };\n\n      // Draw grid/scale ticks every 1m\n      const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n      const stepMeters = chooseStep(maxVisMeters);\n      ctx.strokeStyle = 'rgba(30,40,60,0.05)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.font = `${12 * s.scale}px system-ui`;\n      ctx.fillStyle = '#234';\n\n      for (let m = 0; m <= Math.ceil(maxVisMeters / stepMeters) * stepMeters; m += stepMeters) {\n        const yPx = toPixelY(m);\n        ctx.beginPath();\n        ctx.moveTo(0, yPx);\n        ctx.lineTo(canvas.width, yPx);\n        ctx.stroke();\n        // label on left\n        ctx.fillText(`${m.toFixed(0)} m`, 6 * s.scale, yPx - 4 * s.scale);\n      }\n\n      // Draw analytic curve (if requested)\n      if (showAnalytic.checked) {\n        // compute series of points for analytic curve until hits ground or up to certain time\n        const color = '#ff7a7a';\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        const steps = 200;\n        let started = false;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n          if (yAnal <= 0) {\n            // reached ground, draw endpoint and break\n            const x = (t / maxT) * canvas.width;\n            const y = toPixelY(0);\n            if (!started) ctx.moveTo(x, y);\n            else ctx.lineTo(x, y);\n            break;\n          }\n          const x = (t / maxT) * canvas.width;\n          const y = toPixelY(yAnal);\n          if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw numerical solution path (stored in plotData)\n      if (plotData.length > 1) {\n        ctx.strokeStyle = '#3ad27a';\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = (p.t / maxT) * canvas.width;\n          const y = toPixelY(p.y);\n          if (i === 0) ctx.moveTo(x,y);\n          else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw the ball at current numeric state\n      const ballX = canvas.width * 0.15;\n      const ballYpx = toPixelY(state.y);\n      const ballRadius = 14 * s.scale;\n      // shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\n      ctx.ellipse(ballX + 6 * s.scale, groundYpx - 6 * s.scale, 28 * s.scale, 6 * s.scale, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball\n      ctx.beginPath();\n      const grd = ctx.createLinearGradient(ballX - ballRadius, ballYpx - ballRadius, ballX + ballRadius, ballYpx + ballRadius);\n      grd.addColorStop(0, '#2b85ff');\n      grd.addColorStop(1, '#1d4db3');\n      ctx.fillStyle = grd;\n      ctx.arc(ballX, ballYpx, ballRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball outline\n      ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.stroke();\n\n      // Draw small text: current numeric and analytic positions on right\n      ctx.fillStyle = '#123';\n      ctx.font = `${14 * s.scale}px system-ui`;\n      ctx.fillText(`数值 y = ${state.y.toFixed(3)} m`, canvas.width * 0.55, s.topPadding + 20 * s.scale);\n      const vSign = state.v;\n      ctx.fillText(`v = ${vSign.toFixed(3)} m/s`, canvas.width * 0.55, s.topPadding + 44 * s.scale);\n      // draw ground label\n      ctx.fillText('地面', 8 * s.scale, groundYpx + 18 * s.scale);\n      // draw axis for time along bottom (just a reference)\n      drawBottomPlot();\n    }\n\n    // 选择合理的刻度步长（米）\n    function chooseStep(maxMeters) {\n      if (maxMeters <= 10) return 1;\n      if (maxMeters <= 30) return 2;\n      if (maxMeters <= 60) return 5;\n      return 10;\n    }\n\n    // 绘制底部趋势图（位置随时间）\n    function drawBottomPlot() {\n      const s = getCanvasSize();\n      // clear plot overlay\n      pctx.clearRect(0,0,plot.width,plot.height);\n      // background\n      pctx.fillStyle = 'rgba(255,255,255,0.82)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n\n      // draw axes\n      pctx.strokeStyle = 'rgba(30,40,60,0.12)';\n      pctx.lineWidth = 1 * s.scale;\n      pctx.beginPath();\n      pctx.moveTo(40 * s.scale, 10 * s.scale);\n      pctx.lineTo(40 * s.scale, plot.height - 24 * s.scale);\n      pctx.lineTo(plot.width - 10 * s.scale, plot.height - 24 * s.scale);\n      pctx.stroke();\n\n      // determine time window\n      const maxT = Math.max(2, state.t + 1.5);\n      // draw numeric data (green)\n      if (plotData.length > 0) {\n        pctx.strokeStyle = '#3ad27a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = 40 * s.scale + (p.t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - p.y) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y);\n          else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // analytic (red)\n      if (showAnalytic.checked) {\n        pctx.strokeStyle = '#ff7a7a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        const steps = 150;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = Math.max(0, params.h0 - (params.v0 * t + 0.5 * params.g * t * t));\n          const x = 40 * s.scale + (t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - yAnal) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y); else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // axis labels\n      pctx.fillStyle = '#234';\n      pctx.font = `${11 * s.scale}px system-ui`;\n      pctx.fillText('t (s)', plot.width - 50 * s.scale, plot.height - 8 * s.scale);\n      pctx.fillText('下降量 (m)', 6 * s.scale, 14 * s.scale);\n    }\n\n    // 更新数值读出\n    function updateReadouts(acc){\n      timeRead.textContent = state.t.toFixed(2);\n      posRead.textContent = state.y.toFixed(3);\n      velRead.textContent = state.v.toFixed(3);\n      // 加速度显示为向下为正，因此显示为 +g... 但为更直观，显示为负值（向下加速使高度负二阶）\n      // 这里我们显示加速度的代数值（向下为正）\n      const a = acc === undefined ? (params.g - params.b / params.m * state.v) : acc;\n      accRead.textContent = a.toFixed(3);\n    }\n\n    // 主循环（使用 requestAnimationFrame，按真实时间步进）\n    let lastFrameTime = null;\n    function mainLoop(timestamp) {\n      if (!state.running) return;\n      if (!lastFrameTime) lastFrameTime = timestamp;\n      const dtSec = Math.min(0.05, (timestamp - lastFrameTime) / 1000); // 限制最大步长\n      lastFrameTime = timestamp;\n\n      // 做若干小步以提高数值稳定性（分割，避免过大 dt）\n      const subSteps = Math.max(1, Math.ceil(dtSec / 0.01));\n      let acc = 0;\n      for (let i = 0; i < subSteps; i++) {\n        acc = integrate(dtSec / subSteps);\n        appendPlotPoint();\n        if (state.y <= 0) {\n          state.y = 0;\n          state.v = 0;\n          state.running = false;\n          break;\n        }\n      }\n      updateReadouts(acc);\n      drawAll();\n\n      if (state.running) requestAnimationFrame(mainLoop);\n    }\n\n    // 初始化并监听窗口尺寸变化\n    window.addEventListener('resize', ()=> {\n      drawAll();\n    });\n\n    // 初始化\n    initialize();\n\n    // 键盘快捷键（空格播放/暂停，r 重置）\n    window.addEventListener('keydown', (e)=>{\n      if (e.code === 'Space') {\n        e.preventDefault();\n        if (state.running) pauseBtn.click(); else playBtn.click();\n      } else if (e.key === 'r' || e.key === 'R') {\n        resetBtn.click();\n      }\n    });\n\n    // 初次绘制\n    drawAll();",
                "parameters": [],
                "status": "success"
              },
              "attempts": 1
            },
            "rawData": "{\"success\":true,\"data\":{\"experiment_id\":\"234561a8-cc44-47b7-8ae9-1446ab40a762\",\"title\":\"重力球下落模拟\",\"description\":\"摘要（来自 Perplexity 的信息汇总）：\\n- 重力下落可以用经典力学描述：在忽略空气阻力时，位移满足 y(t) = y0 + v0*t + 0.5*g*t^2，速度 v(t) = v0 + g*t（方向约定向下为正或负要一致）。若考虑阻力，可用数值积分（例如欧拉或更好的积分法）来近似解决。本文演示同时提供无阻力的解析解和含线性阻力的数值解，方便对比与教学。信息来源：Perplexity（Perplexity AI 研究）。\\n\\n下面给出一个完整可运行的 HTML 文件：它包含可调的初始高度、初速度、重力加速度、阻力系数（线性阻力可选）、播放/暂停/重置、实时数值显示、动画视图和位置-时间图。代码无外部依赖，可直接保存为 .html 后在浏览器打开运行。\",\"html_content\":\"<div class=\\\"container\\\">\\n    <!-- 控件面板 -->\\n    <div class=\\\"panel controls\\\" aria-label=\\\"模拟控制\\\">\\n      <h2>重力球下落 模拟 控制面板</h2>\\n      <div class=\\\"small\\\">单位：m（米），s（秒），m/s（速度）</div>\\n\\n      <label for=\\\"height\\\">初始高度 h0（米）: <span id=\\\"h0-val\\\">10</span></label>\\n      <div class=\\\"row\\\">\\n        <input id=\\\"height\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"100\\\" step=\\\"0.5\\\" value=\\\"10\\\" aria-labelledby=\\\"height\\\">\\n        <input id=\\\"height-num\\\" type=\\\"number\\\" min=\\\"0\\\" max=\\\"100\\\" step=\\\"0.1\\\" value=\\\"10\\\">\\n      </div>\\n\\n      <label for=\\\"v0\\\">初速度 v0（m/s，向下为正）: <span id=\\\"v0-val\\\">0</span></label>\\n      <div class=\\\"row\\\">\\n        <input id=\\\"v0\\\" type=\\\"range\\\" min=\\\"-50\\\" max=\\\"50\\\" step=\\\"0.5\\\" value=\\\"0\\\">\\n        <input id=\\\"v0-num\\\" type=\\\"number\\\" min=\\\"-50\\\" max=\\\"50\\\" step=\\\"0.1\\\" value=\\\"0\\\">\\n      </div>\\n\\n      <label for=\\\"g\\\">重力加速度 g（m/s²）: <span id=\\\"g-val\\\">9.81</span></label>\\n      <div class=\\\"row\\\">\\n        <input id=\\\"g\\\" type=\\\"range\\\" min=\\\"0.1\\\" max=\\\"20\\\" step=\\\"0.01\\\" value=\\\"9.81\\\">\\n        <input id=\\\"g-num\\\" type=\\\"number\\\" min=\\\"0.1\\\" max=\\\"20\\\" step=\\\"0.01\\\" value=\\\"9.81\\\">\\n      </div>\\n\\n      <label for=\\\"drag\\\">线性阻力系数 b（kg/s，0 为无阻力）: <span id=\\\"b-val\\\">0</span></label>\\n      <div class=\\\"row\\\">\\n        <input id=\\\"drag\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"5\\\" step=\\\"0.01\\\" value=\\\"0\\\">\\n        <input id=\\\"drag-num\\\" type=\\\"number\\\" min=\\\"0\\\" max=\\\"5\\\" step=\\\"0.01\\\" value=\\\"0\\\">\\n      </div>\\n\\n      <div class=\\\"toggle\\\" role=\\\"group\\\" aria-label=\\\"模拟选项\\\">\\n        <input id=\\\"show-analytic\\\" type=\\\"checkbox\\\" checked>\\n        <label for=\\\"show-analytic\\\" class=\\\"small\\\">显示无阻力解析解曲线（仅在 b=0 时严格对应）</label>\\n      </div>\\n\\n      <div class=\\\"buttons\\\" role=\\\"group\\\" aria-label=\\\"播放按钮\\\">\\n        <button id=\\\"play\\\">播放</button>\\n        <button id=\\\"pause\\\" class=\\\"secondary\\\">暂停</button>\\n        <button id=\\\"reset\\\" class=\\\"secondary\\\">重置</button>\\n        <button id=\\\"step\\\" class=\\\"secondary\\\">单步（0.02s）</button>\\n      </div>\\n\\n      <div class=\\\"footer-note\\\">\\n        提示：修改参数后可以按“重置”或“播放”来观察新参数下的行为。解析解仅在无阻力时（b=0）可得精确结果；当启用阻力，使用数值积分近似。\\n      </div>\\n    </div>\\n\\n    <!-- 模拟显示面板 -->\\n    <div class=\\\"panel sim-area\\\" aria-label=\\\"模拟显示\\\">\\n      <div style=\\\"display:flex;align-items:center;justify-content:space-between;\\\">\\n        <h3 style=\\\"margin:0\\\">模拟视图</h3>\\n        <div class=\\\"legend small\\\" aria-hidden=\\\"true\\\">\\n          <div style=\\\"display:flex;align-items:center\\\"><span class=\\\"dot\\\" style=\\\"background:#2b85ff\\\"></span> 球体</div>\\n          <div style=\\\"display:flex;align-items:center\\\"><span class=\\\"dot\\\" style=\\\"background:#ff7a7a\\\"></span> 解析位置</div>\\n          <div style=\\\"display:flex;align-items:center\\\"><span class=\\\"dot\\\" style=\\\"background:#3ad27a\\\"></span> 数值位置（带阻力）</div>\\n        </div>\\n      </div>\\n\\n      <div class=\\\"canvas-wrap\\\" id=\\\"canvasWrap\\\">\\n        <canvas id=\\\"viewCanvas\\\" width=\\\"800\\\" height=\\\"420\\\" aria-label=\\\"可视化画布\\\"></canvas>\\n        <canvas id=\\\"plotCanvas\\\" width=\\\"800\\\" height=\\\"160\\\" style=\\\"position:absolute;left:0;right:0;bottom:0;height:160px\\\"></canvas>\\n      </div>\\n\\n      <div class=\\\"readouts\\\" aria-live=\\\"polite\\\">\\n        <div class=\\\"readout\\\"><div class=\\\"small\\\">时间 t (s)</div><div id=\\\"time\\\" class=\\\"v\\\">0.00</div></div>\\n        <div class=\\\"readout\\\"><div class=\\\"small\\\">高度 y (m)</div><div id=\\\"pos\\\" class=\\\"v\\\">10.00</div></div>\\n        <div class=\\\"readout\\\"><div class=\\\"small\\\">速度 v (m/s)</div><div id=\\\"vel\\\" class=\\\"v\\\">0.00</div></div>\\n        <div class=\\\"readout\\\"><div class=\\\"small\\\">加速度 a (m/s²)</div><div id=\\\"acc\\\" class=\\\"v\\\">-9.81</div></div>\\n      </div>\\n    </div>\\n  </div>\\n\\n  <script>\\n    // 简要说明：\\n    // - 我们把画布的顶部视为 y = maxHeight（地面为 y = 0）。为直观，将高度转换为像素（pixelsPerMeter）。\\n    // - 无阻力解析解： y(t)=y0 + v0*t + 0.5*g*t^2 （若向下为正，这里我们用向上为正的常见约定，在显示时做适配）\\n    // - 数值积分（带线性阻力 b）：使用改进欧拉/显式欧拉做简单近似： dv/dt = g - (b/m)*v 。此演示将质量 m 设为 1 kg（相对无损失，b 为每秒的阻力常数）。\\n    // - UI 控件会同步滑条与数字框，支持播放/暂停/重置/单步。\\n\\n    // 获取 DOM\\n    const heightSlider = document.getElementById('height');\\n    const heightNum = document.getElementById('height-num');\\n    const h0ValSpan = document.getElementById('h0-val');\\n\\n    const v0Slider = document.getElementById('v0');\\n    const v0Num = document.getElementById('v0-num');\\n    const v0ValSpan = document.getElementById('v0-val');\\n\\n    const gSlider = document.getElementById('g');\\n    const gNum = document.getElementById('g-num');\\n    const gValSpan = document.getElementById('g-val');\\n\\n    const dragSlider = document.getElementById('drag');\\n    const dragNum = document.getElementById('drag-num');\\n    const bValSpan = document.getElementById('b-val');\\n\\n    const showAnalytic = document.getElementById('show-analytic');\\n\\n    const playBtn = document.getElementById('play');\\n    const pauseBtn = document.getElementById('pause');\\n    const resetBtn = document.getElementById('reset');\\n    const stepBtn = document.getElementById('step');\\n\\n    const timeRead = document.getElementById('time');\\n    const posRead = document.getElementById('pos');\\n    const velRead = document.getElementById('vel');\\n    const accRead = document.getElementById('acc');\\n\\n    const canvas = document.getElementById('viewCanvas');\\n    const ctx = canvas.getContext('2d', { alpha: false });\\n\\n    const plot = document.getElementById('plotCanvas');\\n    const pctx = plot.getContext('2d', { alpha: true });\\n\\n    // 状态与参数\\n    let params = {\\n      h0: parseFloat(heightSlider.value), // 初始高度（m）\\n      v0: parseFloat(v0Slider.value),     // 初速度（m/s，向下为正）\\n      g: parseFloat(gSlider.value),       // 重力（m/s^2，向下为正）\\n      b: parseFloat(dragSlider.value),    // 线性阻力系数（kg/s）\\n      m: 1.0                              // 质量（kg），用于数值积分（设为1 kg）\\n    };\\n\\n    // 仿真状态（数值解）\\n    let state = {\\n      t: 0,\\n      y: params.h0, // 高度（m），以地面为 y=0，初始在 h0\\n      v: params.v0, // 速度（m/s），向下为正\\n      running: false\\n    };\\n\\n    // 绘图尺度与尺寸\\n    function getCanvasSize() {\\n      // 获取实际绘制像素大小\\n      const rect = canvas.getBoundingClientRect();\\n      const scale = window.devicePixelRatio || 1;\\n      canvas.width = Math.round(rect.width * scale);\\n      canvas.height = Math.round(rect.height * scale);\\n      // plot canvas positioned at bottom overlay — resize similarly\\n      const prect = plot.getBoundingClientRect();\\n      plot.width = Math.round(prect.width * scale);\\n      plot.height = Math.round(prect.height * scale);\\n      // returns pixel per meter for converting height to canvas y\\n      // 留出顶部空间 20px 与底部 plot 高度\\n      const topPadding = 16 * scale;\\n      const bottomPlotHeight = plot.height;\\n      const usablePx = canvas.height - bottomPlotHeight - topPadding - 20 * scale;\\n      // 让最大高度（例如 1.2*h0 或至少 10m）可视化\\n      const maxVisibleMeters = Math.max(params.h0 * 1.2, 10);\\n      const pixelsPerMeter = usablePx / maxVisibleMeters;\\n      return {scale, topPadding, bottomPlotHeight, pixelsPerMeter};\\n    }\\n\\n    // 更新参数与同步 UI\\n    function syncFromUI() {\\n      params.h0 = parseFloat(heightNum.value) || 0;\\n      heightSlider.value = params.h0;\\n      h0ValSpan.textContent = params.h0;\\n\\n      params.v0 = parseFloat(v0Num.value) || 0;\\n      v0Slider.value = params.v0;\\n      v0ValSpan.textContent = params.v0;\\n\\n      params.g = parseFloat(gNum.value) || 9.81;\\n      gSlider.value = params.g;\\n      gValSpan.textContent = params.g;\\n\\n      params.b = parseFloat(dragNum.value) || 0;\\n      dragSlider.value = params.b;\\n      bValSpan.textContent = params.b;\\n    }\\n\\n    // 事件绑定（同步滑块与数字框）\\n    function bindRangeAndNumber(rangeEl, numEl, valSpan){\\n      rangeEl.addEventListener('input', ()=> {\\n        numEl.value = rangeEl.value;\\n        syncFromUI();\\n      });\\n      numEl.addEventListener('change', ()=>{\\n        // clamp within range\\n        const min = parseFloat(rangeEl.min);\\n        const max = parseFloat(rangeEl.max);\\n        let v = parseFloat(numEl.value);\\n        if (isNaN(v)) v = parseFloat(rangeEl.value);\\n        v = Math.max(min, Math.min(max, v));\\n        numEl.value = v;\\n        rangeEl.value = v;\\n        syncFromUI();\\n      });\\n    }\\n    bindRangeAndNumber(heightSlider, heightNum, h0ValSpan);\\n    bindRangeAndNumber(v0Slider, v0Num, v0ValSpan);\\n    bindRangeAndNumber(gSlider, gNum, gValSpan);\\n    bindRangeAndNumber(dragSlider, dragNum, bValSpan);\\n\\n    // 播放控制\\n    playBtn.addEventListener('click', ()=>{\\n      if (!state.running) {\\n        state.running = true;\\n        lastFrameTime = null;\\n        requestAnimationFrame(mainLoop);\\n      }\\n    });\\n    pauseBtn.addEventListener('click', ()=>{\\n      state.running = false;\\n    });\\n    resetBtn.addEventListener('click', ()=>{\\n      // 重置初始状态（不改变参数）\\n      syncFromUI();\\n      state.t = 0;\\n      state.y = params.h0;\\n      state.v = params.v0;\\n      clearPlot();\\n      drawAll();\\n    });\\n    stepBtn.addEventListener('click', ()=>{\\n      // 单步 0.02 s\\n      singleStep(0.02);\\n      drawAll();\\n    });\\n\\n    // 重置到默认并初始化绘图\\n    function initialize() {\\n      syncFromUI();\\n      state.t = 0;\\n      state.y = params.h0;\\n      state.v = params.v0;\\n      clearPlot();\\n      drawAll();\\n    }\\n\\n    // 数值积分：显式欧拉（小步长）用于 dv/dt = g - (b/m)*v 和 dy/dt = v\\n    function integrate(dt) {\\n      // acceleration (向下为正)\\n      const a = params.g - (params.b / params.m) * state.v;\\n      // 更新\\n      state.v += a * dt;\\n      state.y -= state.v * dt; // 注意：我们用 y 为高度（地面为0），v 为向下为正 => y 减小\\n      state.t += dt;\\n      return a;\\n    }\\n\\n    // 单步封装：检查是否触地（y<=0）\\n    function singleStep(dt) {\\n      if (state.y <= 0) return; // 已触地\\n      // 如果没有阻力且启用解析显示，解析和数值应一致 — 但我们仍使用数值解用于动画（便于比较）\\n      const a = integrate(dt);\\n      if (state.y <= 0) {\\n        state.y = 0;\\n        state.v = 0;\\n        state.running = false;\\n      }\\n      // 更新读数与记录绘图点\\n      updateReadouts(a);\\n      appendPlotPoint();\\n    }\\n\\n    // 画布绘图函数\\n    function clearPlot() {\\n      const s = getCanvasSize();\\n      // 绘制背景的 view canvas\\n      ctx.fillStyle = '#eaf2ff';\\n      ctx.fillRect(0,0,canvas.width,canvas.height);\\n      // 绘制 lower plot background\\n      pctx.clearRect(0,0,plot.width,plot.height);\\n      pctx.fillStyle = 'rgba(255,255,255,0.6)';\\n      pctx.fillRect(0,0,plot.width,plot.height);\\n      // 初始化 plot data arrays\\n      plotData = [];\\n      analyticData = [];\\n    }\\n\\n    // 存储绘图数据点\\n    let plotData = []; // 数值：{t,y}\\n    let analyticData = []; // 解析（b=0）：{t,y}\\n\\n    function appendPlotPoint() {\\n      plotData.push({t: state.t, y: state.y});\\n      // analytic data point up to current t if b==0 or we still draw analytic optionally\\n      if (showAnalytic.checked) {\\n        // compute analytic y (y0 - (v0*t + 0.5*g*t^2)) since y is height decreasing\\n        const t = state.t;\\n        const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\\n        analyticData.push({t: t, y: Math.max(0, yAnal)});\\n      }\\n    }\\n\\n    function drawAll() {\\n      // Setup sizes\\n      const s = getCanvasSize();\\n      // clear background\\n      ctx.fillStyle = '#eaf2ff';\\n      ctx.fillRect(0,0,canvas.width,canvas.height);\\n\\n      // Draw ground line\\n      const groundYpx = canvas.height - s.bottomPlotHeight - 6 * s.scale;\\n      ctx.fillStyle = '#c4d8ff';\\n      ctx.fillRect(0, groundYpx, canvas.width, 6 * s.scale);\\n\\n      // Convert current height (m) to pixel Y\\n      const toPixelY = (yMeters) => {\\n        // highest visible meters we mapped earlier:\\n        const maxVisMeters = Math.max(params.h0 * 1.2, 10);\\n        const usablePx = canvas.height - s.bottomPlotHeight - s.topPadding - 20 * s.scale;\\n        const ppm = usablePx / maxVisMeters;\\n        // top zero at s.topPadding\\n        const ypx = s.topPadding + (maxVisMeters - yMeters) * ppm;\\n        return ypx;\\n      };\\n\\n      // Draw grid/scale ticks every 1m\\n      const maxVisMeters = Math.max(params.h0 * 1.2, 10);\\n      const stepMeters = chooseStep(maxVisMeters);\\n      ctx.strokeStyle = 'rgba(30,40,60,0.05)';\\n      ctx.lineWidth = 1 * s.scale;\\n      ctx.font = `${12 * s.scale}px system-ui`;\\n      ctx.fillStyle = '#234';\\n\\n      for (let m = 0; m <= Math.ceil(maxVisMeters / stepMeters) * stepMeters; m += stepMeters) {\\n        const yPx = toPixelY(m);\\n        ctx.beginPath();\\n        ctx.moveTo(0, yPx);\\n        ctx.lineTo(canvas.width, yPx);\\n        ctx.stroke();\\n        // label on left\\n        ctx.fillText(`${m.toFixed(0)} m`, 6 * s.scale, yPx - 4 * s.scale);\\n      }\\n\\n      // Draw analytic curve (if requested)\\n      if (showAnalytic.checked) {\\n        // compute series of points for analytic curve until hits ground or up to certain time\\n        const color = '#ff7a7a';\\n        ctx.strokeStyle = color;\\n        ctx.lineWidth = 2 * s.scale;\\n        ctx.beginPath();\\n        const maxT = Math.max(2, state.t + 1.5);\\n        const steps = 200;\\n        let started = false;\\n        for (let i = 0; i <= steps; i++) {\\n          const t = (i / steps) * maxT;\\n          const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\\n          if (yAnal <= 0) {\\n            // reached ground, draw endpoint and break\\n            const x = (t / maxT) * canvas.width;\\n            const y = toPixelY(0);\\n            if (!started) ctx.moveTo(x, y);\\n            else ctx.lineTo(x, y);\\n            break;\\n          }\\n          const x = (t / maxT) * canvas.width;\\n          const y = toPixelY(yAnal);\\n          if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);\\n        }\\n        ctx.stroke();\\n      }\\n\\n      // Draw numerical solution path (stored in plotData)\\n      if (plotData.length > 1) {\\n        ctx.strokeStyle = '#3ad27a';\\n        ctx.lineWidth = 2 * s.scale;\\n        ctx.beginPath();\\n        const maxT = Math.max(2, state.t + 1.5);\\n        for (let i = 0; i < plotData.length; i++) {\\n          const p = plotData[i];\\n          const x = (p.t / maxT) * canvas.width;\\n          const y = toPixelY(p.y);\\n          if (i === 0) ctx.moveTo(x,y);\\n          else ctx.lineTo(x,y);\\n        }\\n        ctx.stroke();\\n      }\\n\\n      // Draw the ball at current numeric state\\n      const ballX = canvas.width * 0.15;\\n      const ballYpx = toPixelY(state.y);\\n      const ballRadius = 14 * s.scale;\\n      // shadow\\n      ctx.beginPath();\\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\\n      ctx.ellipse(ballX + 6 * s.scale, groundYpx - 6 * s.scale, 28 * s.scale, 6 * s.scale, 0, 0, Math.PI * 2);\\n      ctx.fill();\\n\\n      // ball\\n      ctx.beginPath();\\n      const grd = ctx.createLinearGradient(ballX - ballRadius, ballYpx - ballRadius, ballX + ballRadius, ballYpx + ballRadius);\\n      grd.addColorStop(0, '#2b85ff');\\n      grd.addColorStop(1, '#1d4db3');\\n      ctx.fillStyle = grd;\\n      ctx.arc(ballX, ballYpx, ballRadius, 0, Math.PI * 2);\\n      ctx.fill();\\n\\n      // ball outline\\n      ctx.strokeStyle = 'rgba(0,0,0,0.12)';\\n      ctx.lineWidth = 1 * s.scale;\\n      ctx.stroke();\\n\\n      // Draw small text: current numeric and analytic positions on right\\n      ctx.fillStyle = '#123';\\n      ctx.font = `${14 * s.scale}px system-ui`;\\n      ctx.fillText(`数值 y = ${state.y.toFixed(3)} m`, canvas.width * 0.55, s.topPadding + 20 * s.scale);\\n      const vSign = state.v;\\n      ctx.fillText(`v = ${vSign.toFixed(3)} m/s`, canvas.width * 0.55, s.topPadding + 44 * s.scale);\\n      // draw ground label\\n      ctx.fillText('地面', 8 * s.scale, groundYpx + 18 * s.scale);\\n      // draw axis for time along bottom (just a reference)\\n      drawBottomPlot();\\n    }\\n\\n    // 选择合理的刻度步长（米）\\n    function chooseStep(maxMeters) {\\n      if (maxMeters <= 10) return 1;\\n      if (maxMeters <= 30) return 2;\\n      if (maxMeters <= 60) return 5;\\n      return 10;\\n    }\\n\\n    // 绘制底部趋势图（位置随时间）\\n    function drawBottomPlot() {\\n      const s = getCanvasSize();\\n      // clear plot overlay\\n      pctx.clearRect(0,0,plot.width,plot.height);\\n      // background\\n      pctx.fillStyle = 'rgba(255,255,255,0.82)';\\n      pctx.fillRect(0,0,plot.width,plot.height);\\n\\n      // draw axes\\n      pctx.strokeStyle = 'rgba(30,40,60,0.12)';\\n      pctx.lineWidth = 1 * s.scale;\\n      pctx.beginPath();\\n      pctx.moveTo(40 * s.scale, 10 * s.scale);\\n      pctx.lineTo(40 * s.scale, plot.height - 24 * s.scale);\\n      pctx.lineTo(plot.width - 10 * s.scale, plot.height - 24 * s.scale);\\n      pctx.stroke();\\n\\n      // determine time window\\n      const maxT = Math.max(2, state.t + 1.5);\\n      // draw numeric data (green)\\n      if (plotData.length > 0) {\\n        pctx.strokeStyle = '#3ad27a';\\n        pctx.lineWidth = 2 * s.scale;\\n        pctx.beginPath();\\n        for (let i = 0; i < plotData.length; i++) {\\n          const p = plotData[i];\\n          const x = 40 * s.scale + (p.t / maxT) * (plot.width - 60 * s.scale);\\n          const y = 10 * s.scale + ((params.h0 - p.y) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\\n          if (i === 0) pctx.moveTo(x,y);\\n          else pctx.lineTo(x,y);\\n        }\\n        pctx.stroke();\\n      }\\n\\n      // analytic (red)\\n      if (showAnalytic.checked) {\\n        pctx.strokeStyle = '#ff7a7a';\\n        pctx.lineWidth = 2 * s.scale;\\n        pctx.beginPath();\\n        const steps = 150;\\n        for (let i = 0; i <= steps; i++) {\\n          const t = (i / steps) * maxT;\\n          const yAnal = Math.max(0, params.h0 - (params.v0 * t + 0.5 * params.g * t * t));\\n          const x = 40 * s.scale + (t / maxT) * (plot.width - 60 * s.scale);\\n          const y = 10 * s.scale + ((params.h0 - yAnal) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\\n          if (i === 0) pctx.moveTo(x,y); else pctx.lineTo(x,y);\\n        }\\n        pctx.stroke();\\n      }\\n\\n      // axis labels\\n      pctx.fillStyle = '#234';\\n      pctx.font = `${11 * s.scale}px system-ui`;\\n      pctx.fillText('t (s)', plot.width - 50 * s.scale, plot.height - 8 * s.scale);\\n      pctx.fillText('下降量 (m)', 6 * s.scale, 14 * s.scale);\\n    }\\n\\n    // 更新数值读出\\n    function updateReadouts(acc){\\n      timeRead.textContent = state.t.toFixed(2);\\n      posRead.textContent = state.y.toFixed(3);\\n      velRead.textContent = state.v.toFixed(3);\\n      // 加速度显示为向下为正，因此显示为 +g... 但为更直观，显示为负值（向下加速使高度负二阶）\\n      // 这里我们显示加速度的代数值（向下为正）\\n      const a = acc === undefined ? (params.g - params.b / params.m * state.v) : acc;\\n      accRead.textContent = a.toFixed(3);\\n    }\\n\\n    // 主循环（使用 requestAnimationFrame，按真实时间步进）\\n    let lastFrameTime = null;\\n    function mainLoop(timestamp) {\\n      if (!state.running) return;\\n      if (!lastFrameTime) lastFrameTime = timestamp;\\n      const dtSec = Math.min(0.05, (timestamp - lastFrameTime) / 1000); // 限制最大步长\\n      lastFrameTime = timestamp;\\n\\n      // 做若干小步以提高数值稳定性（分割，避免过大 dt）\\n      const subSteps = Math.max(1, Math.ceil(dtSec / 0.01));\\n      let acc = 0;\\n      for (let i = 0; i < subSteps; i++) {\\n        acc = integrate(dtSec / subSteps);\\n        appendPlotPoint();\\n        if (state.y <= 0) {\\n          state.y = 0;\\n          state.v = 0;\\n          state.running = false;\\n          break;\\n        }\\n      }\\n      updateReadouts(acc);\\n      drawAll();\\n\\n      if (state.running) requestAnimationFrame(mainLoop);\\n    }\\n\\n    // 初始化并监听窗口尺寸变化\\n    window.addEventListener('resize', ()=> {\\n      drawAll();\\n    });\\n\\n    // 初始化\\n    initialize();\\n\\n    // 键盘快捷键（空格播放/暂停，r 重置）\\n    window.addEventListener('keydown', (e)=>{\\n      if (e.code === 'Space') {\\n        e.preventDefault();\\n        if (state.running) pauseBtn.click(); else playBtn.click();\\n      } else if (e.key === 'r' || e.key === 'R') {\\n        resetBtn.click();\\n      }\\n    });\\n\\n    // 初次绘制\\n    drawAll();\\n  </script>\",\"css_content\":\":root{\\n      --bg:#f6f8fa;\\n      --card:#ffffff;\\n      --accent:#2b85ff;\\n      --muted:#666;\\n      --danger:#e64b4b;\\n    }\\n    body{\\n      margin:0;\\n      font-family: system-ui, -apple-system, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial;\\n      background:linear-gradient(180deg,#eef4ff 0%,var(--bg) 60%);\\n      color:#222;\\n      display:flex;\\n      min-height:100vh;\\n      align-items:flex-start;\\n      justify-content:center;\\n      padding:24px;\\n      box-sizing:border-box;\\n    }\\n    .container{\\n      width:100%;\\n      max-width:1100px;\\n      display:grid;\\n      grid-template-columns: 360px 1fr;\\n      gap:20px;\\n      align-items:start;\\n    }\\n    .panel{\\n      background:var(--card);\\n      border-radius:10px;\\n      box-shadow:0 6px 18px rgba(30,40,60,0.08);\\n      padding:16px;\\n    }\\n    .controls h2{\\n      margin:0 0 8px 0;\\n      font-size:18px;\\n    }\\n    label{\\n      display:block;\\n      margin:10px 0 6px;\\n      font-size:13px;\\n      color:var(--muted);\\n    }\\n    .row{\\n      display:flex;\\n      gap:8px;\\n      align-items:center;\\n    }\\n    input[type=\\\"range\\\"]{\\n      width:100%;\\n    }\\n    input[type=\\\"number\\\"]{\\n      width:100px;\\n      padding:6px 8px;\\n      border-radius:6px;\\n      border:1px solid #d6dbe6;\\n    }\\n    .small{\\n      font-size:12px;\\n      color:var(--muted);\\n    }\\n    .buttons{\\n      display:flex;\\n      gap:8px;\\n      margin-top:12px;\\n    }\\n    button{\\n      background:var(--accent);\\n      color:white;\\n      border:none;\\n      padding:8px 12px;\\n      border-radius:8px;\\n      cursor:pointer;\\n      font-weight:600;\\n      box-shadow:0 6px 14px rgba(43,133,255,0.18);\\n    }\\n    button.secondary{\\n      background:#f3f6fb;\\n      color:#214;\\n      box-shadow:none;\\n      font-weight:600;\\n    }\\n    button.danger{\\n      background:var(--danger);\\n      box-shadow:none;\\n    }\\n    .sim-area{\\n      display:flex;\\n      flex-direction:column;\\n      gap:12px;\\n    }\\n    .canvas-wrap{\\n      background: linear-gradient(180deg,#e9f0ff 0%, #ffffff 60%);\\n      border:1px solid rgba(30,40,60,0.06);\\n      height:420px;\\n      border-radius:10px;\\n      position:relative;\\n      overflow:hidden;\\n    }\\n    canvas{\\n      width:100%;\\n      height:100%;\\n      display:block;\\n    }\\n    .readouts{\\n      display:flex;\\n      gap:12px;\\n      flex-wrap:wrap;\\n    }\\n    .readout{\\n      background:#fff;\\n      padding:8px 10px;\\n      border-radius:8px;\\n      border:1px solid #eef3fb;\\n      min-width:120px;\\n      text-align:center;\\n    }\\n    .readout .v{\\n      font-size:18px;\\n      font-weight:700;\\n    }\\n    .footer-note{\\n      font-size:12px;\\n      color:var(--muted);\\n      margin-top:8px;\\n    }\\n    .toggle{\\n      display:flex;\\n      gap:8px;\\n      align-items:center;\\n      margin-top:6px;\\n    }\\n    .legend{\\n      display:flex;\\n      gap:12px;\\n      align-items:center;\\n      flex-wrap:wrap;\\n      margin-top:6px;\\n    }\\n    .legend .dot{\\n      width:12px;height:12px;border-radius:50%;\\n      display:inline-block;\\n      margin-right:6px;\\n    }\\n    @media (max-width:900px){\\n      .container{grid-template-columns:1fr; padding:0 8px;}\\n    }\",\"js_content\":\"// 简要说明：\\n    // - 我们把画布的顶部视为 y = maxHeight（地面为 y = 0）。为直观，将高度转换为像素（pixelsPerMeter）。\\n    // - 无阻力解析解： y(t)=y0 + v0*t + 0.5*g*t^2 （若向下为正，这里我们用向上为正的常见约定，在显示时做适配）\\n    // - 数值积分（带线性阻力 b）：使用改进欧拉/显式欧拉做简单近似： dv/dt = g - (b/m)*v 。此演示将质量 m 设为 1 kg（相对无损失，b 为每秒的阻力常数）。\\n    // - UI 控件会同步滑条与数字框，支持播放/暂停/重置/单步。\\n\\n    // 获取 DOM\\n    const heightSlider = document.getElementById('height');\\n    const heightNum = document.getElementById('height-num');\\n    const h0ValSpan = document.getElementById('h0-val');\\n\\n    const v0Slider = document.getElementById('v0');\\n    const v0Num = document.getElementById('v0-num');\\n    const v0ValSpan = document.getElementById('v0-val');\\n\\n    const gSlider = document.getElementById('g');\\n    const gNum = document.getElementById('g-num');\\n    const gValSpan = document.getElementById('g-val');\\n\\n    const dragSlider = document.getElementById('drag');\\n    const dragNum = document.getElementById('drag-num');\\n    const bValSpan = document.getElementById('b-val');\\n\\n    const showAnalytic = document.getElementById('show-analytic');\\n\\n    const playBtn = document.getElementById('play');\\n    const pauseBtn = document.getElementById('pause');\\n    const resetBtn = document.getElementById('reset');\\n    const stepBtn = document.getElementById('step');\\n\\n    const timeRead = document.getElementById('time');\\n    const posRead = document.getElementById('pos');\\n    const velRead = document.getElementById('vel');\\n    const accRead = document.getElementById('acc');\\n\\n    const canvas = document.getElementById('viewCanvas');\\n    const ctx = canvas.getContext('2d', { alpha: false });\\n\\n    const plot = document.getElementById('plotCanvas');\\n    const pctx = plot.getContext('2d', { alpha: true });\\n\\n    // 状态与参数\\n    let params = {\\n      h0: parseFloat(heightSlider.value), // 初始高度（m）\\n      v0: parseFloat(v0Slider.value),     // 初速度（m/s，向下为正）\\n      g: parseFloat(gSlider.value),       // 重力（m/s^2，向下为正）\\n      b: parseFloat(dragSlider.value),    // 线性阻力系数（kg/s）\\n      m: 1.0                              // 质量（kg），用于数值积分（设为1 kg）\\n    };\\n\\n    // 仿真状态（数值解）\\n    let state = {\\n      t: 0,\\n      y: params.h0, // 高度（m），以地面为 y=0，初始在 h0\\n      v: params.v0, // 速度（m/s），向下为正\\n      running: false\\n    };\\n\\n    // 绘图尺度与尺寸\\n    function getCanvasSize() {\\n      // 获取实际绘制像素大小\\n      const rect = canvas.getBoundingClientRect();\\n      const scale = window.devicePixelRatio || 1;\\n      canvas.width = Math.round(rect.width * scale);\\n      canvas.height = Math.round(rect.height * scale);\\n      // plot canvas positioned at bottom overlay — resize similarly\\n      const prect = plot.getBoundingClientRect();\\n      plot.width = Math.round(prect.width * scale);\\n      plot.height = Math.round(prect.height * scale);\\n      // returns pixel per meter for converting height to canvas y\\n      // 留出顶部空间 20px 与底部 plot 高度\\n      const topPadding = 16 * scale;\\n      const bottomPlotHeight = plot.height;\\n      const usablePx = canvas.height - bottomPlotHeight - topPadding - 20 * scale;\\n      // 让最大高度（例如 1.2*h0 或至少 10m）可视化\\n      const maxVisibleMeters = Math.max(params.h0 * 1.2, 10);\\n      const pixelsPerMeter = usablePx / maxVisibleMeters;\\n      return {scale, topPadding, bottomPlotHeight, pixelsPerMeter};\\n    }\\n\\n    // 更新参数与同步 UI\\n    function syncFromUI() {\\n      params.h0 = parseFloat(heightNum.value) || 0;\\n      heightSlider.value = params.h0;\\n      h0ValSpan.textContent = params.h0;\\n\\n      params.v0 = parseFloat(v0Num.value) || 0;\\n      v0Slider.value = params.v0;\\n      v0ValSpan.textContent = params.v0;\\n\\n      params.g = parseFloat(gNum.value) || 9.81;\\n      gSlider.value = params.g;\\n      gValSpan.textContent = params.g;\\n\\n      params.b = parseFloat(dragNum.value) || 0;\\n      dragSlider.value = params.b;\\n      bValSpan.textContent = params.b;\\n    }\\n\\n    // 事件绑定（同步滑块与数字框）\\n    function bindRangeAndNumber(rangeEl, numEl, valSpan){\\n      rangeEl.addEventListener('input', ()=> {\\n        numEl.value = rangeEl.value;\\n        syncFromUI();\\n      });\\n      numEl.addEventListener('change', ()=>{\\n        // clamp within range\\n        const min = parseFloat(rangeEl.min);\\n        const max = parseFloat(rangeEl.max);\\n        let v = parseFloat(numEl.value);\\n        if (isNaN(v)) v = parseFloat(rangeEl.value);\\n        v = Math.max(min, Math.min(max, v));\\n        numEl.value = v;\\n        rangeEl.value = v;\\n        syncFromUI();\\n      });\\n    }\\n    bindRangeAndNumber(heightSlider, heightNum, h0ValSpan);\\n    bindRangeAndNumber(v0Slider, v0Num, v0ValSpan);\\n    bindRangeAndNumber(gSlider, gNum, gValSpan);\\n    bindRangeAndNumber(dragSlider, dragNum, bValSpan);\\n\\n    // 播放控制\\n    playBtn.addEventListener('click', ()=>{\\n      if (!state.running) {\\n        state.running = true;\\n        lastFrameTime = null;\\n        requestAnimationFrame(mainLoop);\\n      }\\n    });\\n    pauseBtn.addEventListener('click', ()=>{\\n      state.running = false;\\n    });\\n    resetBtn.addEventListener('click', ()=>{\\n      // 重置初始状态（不改变参数）\\n      syncFromUI();\\n      state.t = 0;\\n      state.y = params.h0;\\n      state.v = params.v0;\\n      clearPlot();\\n      drawAll();\\n    });\\n    stepBtn.addEventListener('click', ()=>{\\n      // 单步 0.02 s\\n      singleStep(0.02);\\n      drawAll();\\n    });\\n\\n    // 重置到默认并初始化绘图\\n    function initialize() {\\n      syncFromUI();\\n      state.t = 0;\\n      state.y = params.h0;\\n      state.v = params.v0;\\n      clearPlot();\\n      drawAll();\\n    }\\n\\n    // 数值积分：显式欧拉（小步长）用于 dv/dt = g - (b/m)*v 和 dy/dt = v\\n    function integrate(dt) {\\n      // acceleration (向下为正)\\n      const a = params.g - (params.b / params.m) * state.v;\\n      // 更新\\n      state.v += a * dt;\\n      state.y -= state.v * dt; // 注意：我们用 y 为高度（地面为0），v 为向下为正 => y 减小\\n      state.t += dt;\\n      return a;\\n    }\\n\\n    // 单步封装：检查是否触地（y<=0）\\n    function singleStep(dt) {\\n      if (state.y <= 0) return; // 已触地\\n      // 如果没有阻力且启用解析显示，解析和数值应一致 — 但我们仍使用数值解用于动画（便于比较）\\n      const a = integrate(dt);\\n      if (state.y <= 0) {\\n        state.y = 0;\\n        state.v = 0;\\n        state.running = false;\\n      }\\n      // 更新读数与记录绘图点\\n      updateReadouts(a);\\n      appendPlotPoint();\\n    }\\n\\n    // 画布绘图函数\\n    function clearPlot() {\\n      const s = getCanvasSize();\\n      // 绘制背景的 view canvas\\n      ctx.fillStyle = '#eaf2ff';\\n      ctx.fillRect(0,0,canvas.width,canvas.height);\\n      // 绘制 lower plot background\\n      pctx.clearRect(0,0,plot.width,plot.height);\\n      pctx.fillStyle = 'rgba(255,255,255,0.6)';\\n      pctx.fillRect(0,0,plot.width,plot.height);\\n      // 初始化 plot data arrays\\n      plotData = [];\\n      analyticData = [];\\n    }\\n\\n    // 存储绘图数据点\\n    let plotData = []; // 数值：{t,y}\\n    let analyticData = []; // 解析（b=0）：{t,y}\\n\\n    function appendPlotPoint() {\\n      plotData.push({t: state.t, y: state.y});\\n      // analytic data point up to current t if b==0 or we still draw analytic optionally\\n      if (showAnalytic.checked) {\\n        // compute analytic y (y0 - (v0*t + 0.5*g*t^2)) since y is height decreasing\\n        const t = state.t;\\n        const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\\n        analyticData.push({t: t, y: Math.max(0, yAnal)});\\n      }\\n    }\\n\\n    function drawAll() {\\n      // Setup sizes\\n      const s = getCanvasSize();\\n      // clear background\\n      ctx.fillStyle = '#eaf2ff';\\n      ctx.fillRect(0,0,canvas.width,canvas.height);\\n\\n      // Draw ground line\\n      const groundYpx = canvas.height - s.bottomPlotHeight - 6 * s.scale;\\n      ctx.fillStyle = '#c4d8ff';\\n      ctx.fillRect(0, groundYpx, canvas.width, 6 * s.scale);\\n\\n      // Convert current height (m) to pixel Y\\n      const toPixelY = (yMeters) => {\\n        // highest visible meters we mapped earlier:\\n        const maxVisMeters = Math.max(params.h0 * 1.2, 10);\\n        const usablePx = canvas.height - s.bottomPlotHeight - s.topPadding - 20 * s.scale;\\n        const ppm = usablePx / maxVisMeters;\\n        // top zero at s.topPadding\\n        const ypx = s.topPadding + (maxVisMeters - yMeters) * ppm;\\n        return ypx;\\n      };\\n\\n      // Draw grid/scale ticks every 1m\\n      const maxVisMeters = Math.max(params.h0 * 1.2, 10);\\n      const stepMeters = chooseStep(maxVisMeters);\\n      ctx.strokeStyle = 'rgba(30,40,60,0.05)';\\n      ctx.lineWidth = 1 * s.scale;\\n      ctx.font = `${12 * s.scale}px system-ui`;\\n      ctx.fillStyle = '#234';\\n\\n      for (let m = 0; m <= Math.ceil(maxVisMeters / stepMeters) * stepMeters; m += stepMeters) {\\n        const yPx = toPixelY(m);\\n        ctx.beginPath();\\n        ctx.moveTo(0, yPx);\\n        ctx.lineTo(canvas.width, yPx);\\n        ctx.stroke();\\n        // label on left\\n        ctx.fillText(`${m.toFixed(0)} m`, 6 * s.scale, yPx - 4 * s.scale);\\n      }\\n\\n      // Draw analytic curve (if requested)\\n      if (showAnalytic.checked) {\\n        // compute series of points for analytic curve until hits ground or up to certain time\\n        const color = '#ff7a7a';\\n        ctx.strokeStyle = color;\\n        ctx.lineWidth = 2 * s.scale;\\n        ctx.beginPath();\\n        const maxT = Math.max(2, state.t + 1.5);\\n        const steps = 200;\\n        let started = false;\\n        for (let i = 0; i <= steps; i++) {\\n          const t = (i / steps) * maxT;\\n          const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\\n          if (yAnal <= 0) {\\n            // reached ground, draw endpoint and break\\n            const x = (t / maxT) * canvas.width;\\n            const y = toPixelY(0);\\n            if (!started) ctx.moveTo(x, y);\\n            else ctx.lineTo(x, y);\\n            break;\\n          }\\n          const x = (t / maxT) * canvas.width;\\n          const y = toPixelY(yAnal);\\n          if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);\\n        }\\n        ctx.stroke();\\n      }\\n\\n      // Draw numerical solution path (stored in plotData)\\n      if (plotData.length > 1) {\\n        ctx.strokeStyle = '#3ad27a';\\n        ctx.lineWidth = 2 * s.scale;\\n        ctx.beginPath();\\n        const maxT = Math.max(2, state.t + 1.5);\\n        for (let i = 0; i < plotData.length; i++) {\\n          const p = plotData[i];\\n          const x = (p.t / maxT) * canvas.width;\\n          const y = toPixelY(p.y);\\n          if (i === 0) ctx.moveTo(x,y);\\n          else ctx.lineTo(x,y);\\n        }\\n        ctx.stroke();\\n      }\\n\\n      // Draw the ball at current numeric state\\n      const ballX = canvas.width * 0.15;\\n      const ballYpx = toPixelY(state.y);\\n      const ballRadius = 14 * s.scale;\\n      // shadow\\n      ctx.beginPath();\\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\\n      ctx.ellipse(ballX + 6 * s.scale, groundYpx - 6 * s.scale, 28 * s.scale, 6 * s.scale, 0, 0, Math.PI * 2);\\n      ctx.fill();\\n\\n      // ball\\n      ctx.beginPath();\\n      const grd = ctx.createLinearGradient(ballX - ballRadius, ballYpx - ballRadius, ballX + ballRadius, ballYpx + ballRadius);\\n      grd.addColorStop(0, '#2b85ff');\\n      grd.addColorStop(1, '#1d4db3');\\n      ctx.fillStyle = grd;\\n      ctx.arc(ballX, ballYpx, ballRadius, 0, Math.PI * 2);\\n      ctx.fill();\\n\\n      // ball outline\\n      ctx.strokeStyle = 'rgba(0,0,0,0.12)';\\n      ctx.lineWidth = 1 * s.scale;\\n      ctx.stroke();\\n\\n      // Draw small text: current numeric and analytic positions on right\\n      ctx.fillStyle = '#123';\\n      ctx.font = `${14 * s.scale}px system-ui`;\\n      ctx.fillText(`数值 y = ${state.y.toFixed(3)} m`, canvas.width * 0.55, s.topPadding + 20 * s.scale);\\n      const vSign = state.v;\\n      ctx.fillText(`v = ${vSign.toFixed(3)} m/s`, canvas.width * 0.55, s.topPadding + 44 * s.scale);\\n      // draw ground label\\n      ctx.fillText('地面', 8 * s.scale, groundYpx + 18 * s.scale);\\n      // draw axis for time along bottom (just a reference)\\n      drawBottomPlot();\\n    }\\n\\n    // 选择合理的刻度步长（米）\\n    function chooseStep(maxMeters) {\\n      if (maxMeters <= 10) return 1;\\n      if (maxMeters <= 30) return 2;\\n      if (maxMeters <= 60) return 5;\\n      return 10;\\n    }\\n\\n    // 绘制底部趋势图（位置随时间）\\n    function drawBottomPlot() {\\n      const s = getCanvasSize();\\n      // clear plot overlay\\n      pctx.clearRect(0,0,plot.width,plot.height);\\n      // background\\n      pctx.fillStyle = 'rgba(255,255,255,0.82)';\\n      pctx.fillRect(0,0,plot.width,plot.height);\\n\\n      // draw axes\\n      pctx.strokeStyle = 'rgba(30,40,60,0.12)';\\n      pctx.lineWidth = 1 * s.scale;\\n      pctx.beginPath();\\n      pctx.moveTo(40 * s.scale, 10 * s.scale);\\n      pctx.lineTo(40 * s.scale, plot.height - 24 * s.scale);\\n      pctx.lineTo(plot.width - 10 * s.scale, plot.height - 24 * s.scale);\\n      pctx.stroke();\\n\\n      // determine time window\\n      const maxT = Math.max(2, state.t + 1.5);\\n      // draw numeric data (green)\\n      if (plotData.length > 0) {\\n        pctx.strokeStyle = '#3ad27a';\\n        pctx.lineWidth = 2 * s.scale;\\n        pctx.beginPath();\\n        for (let i = 0; i < plotData.length; i++) {\\n          const p = plotData[i];\\n          const x = 40 * s.scale + (p.t / maxT) * (plot.width - 60 * s.scale);\\n          const y = 10 * s.scale + ((params.h0 - p.y) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\\n          if (i === 0) pctx.moveTo(x,y);\\n          else pctx.lineTo(x,y);\\n        }\\n        pctx.stroke();\\n      }\\n\\n      // analytic (red)\\n      if (showAnalytic.checked) {\\n        pctx.strokeStyle = '#ff7a7a';\\n        pctx.lineWidth = 2 * s.scale;\\n        pctx.beginPath();\\n        const steps = 150;\\n        for (let i = 0; i <= steps; i++) {\\n          const t = (i / steps) * maxT;\\n          const yAnal = Math.max(0, params.h0 - (params.v0 * t + 0.5 * params.g * t * t));\\n          const x = 40 * s.scale + (t / maxT) * (plot.width - 60 * s.scale);\\n          const y = 10 * s.scale + ((params.h0 - yAnal) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\\n          if (i === 0) pctx.moveTo(x,y); else pctx.lineTo(x,y);\\n        }\\n        pctx.stroke();\\n      }\\n\\n      // axis labels\\n      pctx.fillStyle = '#234';\\n      pctx.font = `${11 * s.scale}px system-ui`;\\n      pctx.fillText('t (s)', plot.width - 50 * s.scale, plot.height - 8 * s.scale);\\n      pctx.fillText('下降量 (m)', 6 * s.scale, 14 * s.scale);\\n    }\\n\\n    // 更新数值读出\\n    function updateReadouts(acc){\\n      timeRead.textContent = state.t.toFixed(2);\\n      posRead.textContent = state.y.toFixed(3);\\n      velRead.textContent = state.v.toFixed(3);\\n      // 加速度显示为向下为正，因此显示为 +g... 但为更直观，显示为负值（向下加速使高度负二阶）\\n      // 这里我们显示加速度的代数值（向下为正）\\n      const a = acc === undefined ? (params.g - params.b / params.m * state.v) : acc;\\n      accRead.textContent = a.toFixed(3);\\n    }\\n\\n    // 主循环（使用 requestAnimationFrame，按真实时间步进）\\n    let lastFrameTime = null;\\n    function mainLoop(timestamp) {\\n      if (!state.running) return;\\n      if (!lastFrameTime) lastFrameTime = timestamp;\\n      const dtSec = Math.min(0.05, (timestamp - lastFrameTime) / 1000); // 限制最大步长\\n      lastFrameTime = timestamp;\\n\\n      // 做若干小步以提高数值稳定性（分割，避免过大 dt）\\n      const subSteps = Math.max(1, Math.ceil(dtSec / 0.01));\\n      let acc = 0;\\n      for (let i = 0; i < subSteps; i++) {\\n        acc = integrate(dtSec / subSteps);\\n        appendPlotPoint();\\n        if (state.y <= 0) {\\n          state.y = 0;\\n          state.v = 0;\\n          state.running = false;\\n          break;\\n        }\\n      }\\n      updateReadouts(acc);\\n      drawAll();\\n\\n      if (state.running) requestAnimationFrame(mainLoop);\\n    }\\n\\n    // 初始化并监听窗口尺寸变化\\n    window.addEventListener('resize', ()=> {\\n      drawAll();\\n    });\\n\\n    // 初始化\\n    initialize();\\n\\n    // 键盘快捷键（空格播放/暂停，r 重置）\\n    window.addEventListener('keydown', (e)=>{\\n      if (e.code === 'Space') {\\n        e.preventDefault();\\n        if (state.running) pauseBtn.click(); else playBtn.click();\\n      } else if (e.key === 'r' || e.key === 'R') {\\n        resetBtn.click();\\n      }\\n    });\\n\\n    // 初次绘制\\n    drawAll();\",\"parameters\":[],\"status\":\"success\"},\"attempts\":1}"
          }
        },
        {
          "stage": "data_analysis",
          "timestamp": "2025-08-09T12:56:26.260Z",
          "dataType": "object",
          "keys": [
            "success",
            "data",
            "attempts"
          ],
          "data": {
            "success": true,
            "data": {
              "experiment_id": "234561a8-cc44-47b7-8ae9-1446ab40a762",
              "title": "重力球下落模拟",
              "description": "摘要（来自 Perplexity 的信息汇总）：\n- 重力下落可以用经典力学描述：在忽略空气阻力时，位移满足 y(t) = y0 + v0*t + 0.5*g*t^2，速度 v(t) = v0 + g*t（方向约定向下为正或负要一致）。若考虑阻力，可用数值积分（例如欧拉或更好的积分法）来近似解决。本文演示同时提供无阻力的解析解和含线性阻力的数值解，方便对比与教学。信息来源：Perplexity（Perplexity AI 研究）。\n\n下面给出一个完整可运行的 HTML 文件：它包含可调的初始高度、初速度、重力加速度、阻力系数（线性阻力可选）、播放/暂停/重置、实时数值显示、动画视图和位置-时间图。代码无外部依赖，可直接保存为 .html 后在浏览器打开运行。",
              "html_content": "<div class=\"container\">\n    <!-- 控件面板 -->\n    <div class=\"panel controls\" aria-label=\"模拟控制\">\n      <h2>重力球下落 模拟 控制面板</h2>\n      <div class=\"small\">单位：m（米），s（秒），m/s（速度）</div>\n\n      <label for=\"height\">初始高度 h0（米）: <span id=\"h0-val\">10</span></label>\n      <div class=\"row\">\n        <input id=\"height\" type=\"range\" min=\"0\" max=\"100\" step=\"0.5\" value=\"10\" aria-labelledby=\"height\">\n        <input id=\"height-num\" type=\"number\" min=\"0\" max=\"100\" step=\"0.1\" value=\"10\">\n      </div>\n\n      <label for=\"v0\">初速度 v0（m/s，向下为正）: <span id=\"v0-val\">0</span></label>\n      <div class=\"row\">\n        <input id=\"v0\" type=\"range\" min=\"-50\" max=\"50\" step=\"0.5\" value=\"0\">\n        <input id=\"v0-num\" type=\"number\" min=\"-50\" max=\"50\" step=\"0.1\" value=\"0\">\n      </div>\n\n      <label for=\"g\">重力加速度 g（m/s²）: <span id=\"g-val\">9.81</span></label>\n      <div class=\"row\">\n        <input id=\"g\" type=\"range\" min=\"0.1\" max=\"20\" step=\"0.01\" value=\"9.81\">\n        <input id=\"g-num\" type=\"number\" min=\"0.1\" max=\"20\" step=\"0.01\" value=\"9.81\">\n      </div>\n\n      <label for=\"drag\">线性阻力系数 b（kg/s，0 为无阻力）: <span id=\"b-val\">0</span></label>\n      <div class=\"row\">\n        <input id=\"drag\" type=\"range\" min=\"0\" max=\"5\" step=\"0.01\" value=\"0\">\n        <input id=\"drag-num\" type=\"number\" min=\"0\" max=\"5\" step=\"0.01\" value=\"0\">\n      </div>\n\n      <div class=\"toggle\" role=\"group\" aria-label=\"模拟选项\">\n        <input id=\"show-analytic\" type=\"checkbox\" checked>\n        <label for=\"show-analytic\" class=\"small\">显示无阻力解析解曲线（仅在 b=0 时严格对应）</label>\n      </div>\n\n      <div class=\"buttons\" role=\"group\" aria-label=\"播放按钮\">\n        <button id=\"play\">播放</button>\n        <button id=\"pause\" class=\"secondary\">暂停</button>\n        <button id=\"reset\" class=\"secondary\">重置</button>\n        <button id=\"step\" class=\"secondary\">单步（0.02s）</button>\n      </div>\n\n      <div class=\"footer-note\">\n        提示：修改参数后可以按“重置”或“播放”来观察新参数下的行为。解析解仅在无阻力时（b=0）可得精确结果；当启用阻力，使用数值积分近似。\n      </div>\n    </div>\n\n    <!-- 模拟显示面板 -->\n    <div class=\"panel sim-area\" aria-label=\"模拟显示\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n        <h3 style=\"margin:0\">模拟视图</h3>\n        <div class=\"legend small\" aria-hidden=\"true\">\n          <div style=\"display:flex;align-items:center\"><span class=\"dot\" style=\"background:#2b85ff\"></span> 球体</div>\n          <div style=\"display:flex;align-items:center\"><span class=\"dot\" style=\"background:#ff7a7a\"></span> 解析位置</div>\n          <div style=\"display:flex;align-items:center\"><span class=\"dot\" style=\"background:#3ad27a\"></span> 数值位置（带阻力）</div>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <canvas id=\"viewCanvas\" width=\"800\" height=\"420\" aria-label=\"可视化画布\"></canvas>\n        <canvas id=\"plotCanvas\" width=\"800\" height=\"160\" style=\"position:absolute;left:0;right:0;bottom:0;height:160px\"></canvas>\n      </div>\n\n      <div class=\"readouts\" aria-live=\"polite\">\n        <div class=\"readout\"><div class=\"small\">时间 t (s)</div><div id=\"time\" class=\"v\">0.00</div></div>\n        <div class=\"readout\"><div class=\"small\">高度 y (m)</div><div id=\"pos\" class=\"v\">10.00</div></div>\n        <div class=\"readout\"><div class=\"small\">速度 v (m/s)</div><div id=\"vel\" class=\"v\">0.00</div></div>\n        <div class=\"readout\"><div class=\"small\">加速度 a (m/s²)</div><div id=\"acc\" class=\"v\">-9.81</div></div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // 简要说明：\n    // - 我们把画布的顶部视为 y = maxHeight（地面为 y = 0）。为直观，将高度转换为像素（pixelsPerMeter）。\n    // - 无阻力解析解： y(t)=y0 + v0*t + 0.5*g*t^2 （若向下为正，这里我们用向上为正的常见约定，在显示时做适配）\n    // - 数值积分（带线性阻力 b）：使用改进欧拉/显式欧拉做简单近似： dv/dt = g - (b/m)*v 。此演示将质量 m 设为 1 kg（相对无损失，b 为每秒的阻力常数）。\n    // - UI 控件会同步滑条与数字框，支持播放/暂停/重置/单步。\n\n    // 获取 DOM\n    const heightSlider = document.getElementById('height');\n    const heightNum = document.getElementById('height-num');\n    const h0ValSpan = document.getElementById('h0-val');\n\n    const v0Slider = document.getElementById('v0');\n    const v0Num = document.getElementById('v0-num');\n    const v0ValSpan = document.getElementById('v0-val');\n\n    const gSlider = document.getElementById('g');\n    const gNum = document.getElementById('g-num');\n    const gValSpan = document.getElementById('g-val');\n\n    const dragSlider = document.getElementById('drag');\n    const dragNum = document.getElementById('drag-num');\n    const bValSpan = document.getElementById('b-val');\n\n    const showAnalytic = document.getElementById('show-analytic');\n\n    const playBtn = document.getElementById('play');\n    const pauseBtn = document.getElementById('pause');\n    const resetBtn = document.getElementById('reset');\n    const stepBtn = document.getElementById('step');\n\n    const timeRead = document.getElementById('time');\n    const posRead = document.getElementById('pos');\n    const velRead = document.getElementById('vel');\n    const accRead = document.getElementById('acc');\n\n    const canvas = document.getElementById('viewCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n\n    const plot = document.getElementById('plotCanvas');\n    const pctx = plot.getContext('2d', { alpha: true });\n\n    // 状态与参数\n    let params = {\n      h0: parseFloat(heightSlider.value), // 初始高度（m）\n      v0: parseFloat(v0Slider.value),     // 初速度（m/s，向下为正）\n      g: parseFloat(gSlider.value),       // 重力（m/s^2，向下为正）\n      b: parseFloat(dragSlider.value),    // 线性阻力系数（kg/s）\n      m: 1.0                              // 质量（kg），用于数值积分（设为1 kg）\n    };\n\n    // 仿真状态（数值解）\n    let state = {\n      t: 0,\n      y: params.h0, // 高度（m），以地面为 y=0，初始在 h0\n      v: params.v0, // 速度（m/s），向下为正\n      running: false\n    };\n\n    // 绘图尺度与尺寸\n    function getCanvasSize() {\n      // 获取实际绘制像素大小\n      const rect = canvas.getBoundingClientRect();\n      const scale = window.devicePixelRatio || 1;\n      canvas.width = Math.round(rect.width * scale);\n      canvas.height = Math.round(rect.height * scale);\n      // plot canvas positioned at bottom overlay — resize similarly\n      const prect = plot.getBoundingClientRect();\n      plot.width = Math.round(prect.width * scale);\n      plot.height = Math.round(prect.height * scale);\n      // returns pixel per meter for converting height to canvas y\n      // 留出顶部空间 20px 与底部 plot 高度\n      const topPadding = 16 * scale;\n      const bottomPlotHeight = plot.height;\n      const usablePx = canvas.height - bottomPlotHeight - topPadding - 20 * scale;\n      // 让最大高度（例如 1.2*h0 或至少 10m）可视化\n      const maxVisibleMeters = Math.max(params.h0 * 1.2, 10);\n      const pixelsPerMeter = usablePx / maxVisibleMeters;\n      return {scale, topPadding, bottomPlotHeight, pixelsPerMeter};\n    }\n\n    // 更新参数与同步 UI\n    function syncFromUI() {\n      params.h0 = parseFloat(heightNum.value) || 0;\n      heightSlider.value = params.h0;\n      h0ValSpan.textContent = params.h0;\n\n      params.v0 = parseFloat(v0Num.value) || 0;\n      v0Slider.value = params.v0;\n      v0ValSpan.textContent = params.v0;\n\n      params.g = parseFloat(gNum.value) || 9.81;\n      gSlider.value = params.g;\n      gValSpan.textContent = params.g;\n\n      params.b = parseFloat(dragNum.value) || 0;\n      dragSlider.value = params.b;\n      bValSpan.textContent = params.b;\n    }\n\n    // 事件绑定（同步滑块与数字框）\n    function bindRangeAndNumber(rangeEl, numEl, valSpan){\n      rangeEl.addEventListener('input', ()=> {\n        numEl.value = rangeEl.value;\n        syncFromUI();\n      });\n      numEl.addEventListener('change', ()=>{\n        // clamp within range\n        const min = parseFloat(rangeEl.min);\n        const max = parseFloat(rangeEl.max);\n        let v = parseFloat(numEl.value);\n        if (isNaN(v)) v = parseFloat(rangeEl.value);\n        v = Math.max(min, Math.min(max, v));\n        numEl.value = v;\n        rangeEl.value = v;\n        syncFromUI();\n      });\n    }\n    bindRangeAndNumber(heightSlider, heightNum, h0ValSpan);\n    bindRangeAndNumber(v0Slider, v0Num, v0ValSpan);\n    bindRangeAndNumber(gSlider, gNum, gValSpan);\n    bindRangeAndNumber(dragSlider, dragNum, bValSpan);\n\n    // 播放控制\n    playBtn.addEventListener('click', ()=>{\n      if (!state.running) {\n        state.running = true;\n        lastFrameTime = null;\n        requestAnimationFrame(mainLoop);\n      }\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.running = false;\n    });\n    resetBtn.addEventListener('click', ()=>{\n      // 重置初始状态（不改变参数）\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    });\n    stepBtn.addEventListener('click', ()=>{\n      // 单步 0.02 s\n      singleStep(0.02);\n      drawAll();\n    });\n\n    // 重置到默认并初始化绘图\n    function initialize() {\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    }\n\n    // 数值积分：显式欧拉（小步长）用于 dv/dt = g - (b/m)*v 和 dy/dt = v\n    function integrate(dt) {\n      // acceleration (向下为正)\n      const a = params.g - (params.b / params.m) * state.v;\n      // 更新\n      state.v += a * dt;\n      state.y -= state.v * dt; // 注意：我们用 y 为高度（地面为0），v 为向下为正 => y 减小\n      state.t += dt;\n      return a;\n    }\n\n    // 单步封装：检查是否触地（y<=0）\n    function singleStep(dt) {\n      if (state.y <= 0) return; // 已触地\n      // 如果没有阻力且启用解析显示，解析和数值应一致 — 但我们仍使用数值解用于动画（便于比较）\n      const a = integrate(dt);\n      if (state.y <= 0) {\n        state.y = 0;\n        state.v = 0;\n        state.running = false;\n      }\n      // 更新读数与记录绘图点\n      updateReadouts(a);\n      appendPlotPoint();\n    }\n\n    // 画布绘图函数\n    function clearPlot() {\n      const s = getCanvasSize();\n      // 绘制背景的 view canvas\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n      // 绘制 lower plot background\n      pctx.clearRect(0,0,plot.width,plot.height);\n      pctx.fillStyle = 'rgba(255,255,255,0.6)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n      // 初始化 plot data arrays\n      plotData = [];\n      analyticData = [];\n    }\n\n    // 存储绘图数据点\n    let plotData = []; // 数值：{t,y}\n    let analyticData = []; // 解析（b=0）：{t,y}\n\n    function appendPlotPoint() {\n      plotData.push({t: state.t, y: state.y});\n      // analytic data point up to current t if b==0 or we still draw analytic optionally\n      if (showAnalytic.checked) {\n        // compute analytic y (y0 - (v0*t + 0.5*g*t^2)) since y is height decreasing\n        const t = state.t;\n        const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n        analyticData.push({t: t, y: Math.max(0, yAnal)});\n      }\n    }\n\n    function drawAll() {\n      // Setup sizes\n      const s = getCanvasSize();\n      // clear background\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n\n      // Draw ground line\n      const groundYpx = canvas.height - s.bottomPlotHeight - 6 * s.scale;\n      ctx.fillStyle = '#c4d8ff';\n      ctx.fillRect(0, groundYpx, canvas.width, 6 * s.scale);\n\n      // Convert current height (m) to pixel Y\n      const toPixelY = (yMeters) => {\n        // highest visible meters we mapped earlier:\n        const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n        const usablePx = canvas.height - s.bottomPlotHeight - s.topPadding - 20 * s.scale;\n        const ppm = usablePx / maxVisMeters;\n        // top zero at s.topPadding\n        const ypx = s.topPadding + (maxVisMeters - yMeters) * ppm;\n        return ypx;\n      };\n\n      // Draw grid/scale ticks every 1m\n      const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n      const stepMeters = chooseStep(maxVisMeters);\n      ctx.strokeStyle = 'rgba(30,40,60,0.05)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.font = `${12 * s.scale}px system-ui`;\n      ctx.fillStyle = '#234';\n\n      for (let m = 0; m <= Math.ceil(maxVisMeters / stepMeters) * stepMeters; m += stepMeters) {\n        const yPx = toPixelY(m);\n        ctx.beginPath();\n        ctx.moveTo(0, yPx);\n        ctx.lineTo(canvas.width, yPx);\n        ctx.stroke();\n        // label on left\n        ctx.fillText(`${m.toFixed(0)} m`, 6 * s.scale, yPx - 4 * s.scale);\n      }\n\n      // Draw analytic curve (if requested)\n      if (showAnalytic.checked) {\n        // compute series of points for analytic curve until hits ground or up to certain time\n        const color = '#ff7a7a';\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        const steps = 200;\n        let started = false;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n          if (yAnal <= 0) {\n            // reached ground, draw endpoint and break\n            const x = (t / maxT) * canvas.width;\n            const y = toPixelY(0);\n            if (!started) ctx.moveTo(x, y);\n            else ctx.lineTo(x, y);\n            break;\n          }\n          const x = (t / maxT) * canvas.width;\n          const y = toPixelY(yAnal);\n          if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw numerical solution path (stored in plotData)\n      if (plotData.length > 1) {\n        ctx.strokeStyle = '#3ad27a';\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = (p.t / maxT) * canvas.width;\n          const y = toPixelY(p.y);\n          if (i === 0) ctx.moveTo(x,y);\n          else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw the ball at current numeric state\n      const ballX = canvas.width * 0.15;\n      const ballYpx = toPixelY(state.y);\n      const ballRadius = 14 * s.scale;\n      // shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\n      ctx.ellipse(ballX + 6 * s.scale, groundYpx - 6 * s.scale, 28 * s.scale, 6 * s.scale, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball\n      ctx.beginPath();\n      const grd = ctx.createLinearGradient(ballX - ballRadius, ballYpx - ballRadius, ballX + ballRadius, ballYpx + ballRadius);\n      grd.addColorStop(0, '#2b85ff');\n      grd.addColorStop(1, '#1d4db3');\n      ctx.fillStyle = grd;\n      ctx.arc(ballX, ballYpx, ballRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball outline\n      ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.stroke();\n\n      // Draw small text: current numeric and analytic positions on right\n      ctx.fillStyle = '#123';\n      ctx.font = `${14 * s.scale}px system-ui`;\n      ctx.fillText(`数值 y = ${state.y.toFixed(3)} m`, canvas.width * 0.55, s.topPadding + 20 * s.scale);\n      const vSign = state.v;\n      ctx.fillText(`v = ${vSign.toFixed(3)} m/s`, canvas.width * 0.55, s.topPadding + 44 * s.scale);\n      // draw ground label\n      ctx.fillText('地面', 8 * s.scale, groundYpx + 18 * s.scale);\n      // draw axis for time along bottom (just a reference)\n      drawBottomPlot();\n    }\n\n    // 选择合理的刻度步长（米）\n    function chooseStep(maxMeters) {\n      if (maxMeters <= 10) return 1;\n      if (maxMeters <= 30) return 2;\n      if (maxMeters <= 60) return 5;\n      return 10;\n    }\n\n    // 绘制底部趋势图（位置随时间）\n    function drawBottomPlot() {\n      const s = getCanvasSize();\n      // clear plot overlay\n      pctx.clearRect(0,0,plot.width,plot.height);\n      // background\n      pctx.fillStyle = 'rgba(255,255,255,0.82)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n\n      // draw axes\n      pctx.strokeStyle = 'rgba(30,40,60,0.12)';\n      pctx.lineWidth = 1 * s.scale;\n      pctx.beginPath();\n      pctx.moveTo(40 * s.scale, 10 * s.scale);\n      pctx.lineTo(40 * s.scale, plot.height - 24 * s.scale);\n      pctx.lineTo(plot.width - 10 * s.scale, plot.height - 24 * s.scale);\n      pctx.stroke();\n\n      // determine time window\n      const maxT = Math.max(2, state.t + 1.5);\n      // draw numeric data (green)\n      if (plotData.length > 0) {\n        pctx.strokeStyle = '#3ad27a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = 40 * s.scale + (p.t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - p.y) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y);\n          else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // analytic (red)\n      if (showAnalytic.checked) {\n        pctx.strokeStyle = '#ff7a7a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        const steps = 150;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = Math.max(0, params.h0 - (params.v0 * t + 0.5 * params.g * t * t));\n          const x = 40 * s.scale + (t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - yAnal) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y); else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // axis labels\n      pctx.fillStyle = '#234';\n      pctx.font = `${11 * s.scale}px system-ui`;\n      pctx.fillText('t (s)', plot.width - 50 * s.scale, plot.height - 8 * s.scale);\n      pctx.fillText('下降量 (m)', 6 * s.scale, 14 * s.scale);\n    }\n\n    // 更新数值读出\n    function updateReadouts(acc){\n      timeRead.textContent = state.t.toFixed(2);\n      posRead.textContent = state.y.toFixed(3);\n      velRead.textContent = state.v.toFixed(3);\n      // 加速度显示为向下为正，因此显示为 +g... 但为更直观，显示为负值（向下加速使高度负二阶）\n      // 这里我们显示加速度的代数值（向下为正）\n      const a = acc === undefined ? (params.g - params.b / params.m * state.v) : acc;\n      accRead.textContent = a.toFixed(3);\n    }\n\n    // 主循环（使用 requestAnimationFrame，按真实时间步进）\n    let lastFrameTime = null;\n    function mainLoop(timestamp) {\n      if (!state.running) return;\n      if (!lastFrameTime) lastFrameTime = timestamp;\n      const dtSec = Math.min(0.05, (timestamp - lastFrameTime) / 1000); // 限制最大步长\n      lastFrameTime = timestamp;\n\n      // 做若干小步以提高数值稳定性（分割，避免过大 dt）\n      const subSteps = Math.max(1, Math.ceil(dtSec / 0.01));\n      let acc = 0;\n      for (let i = 0; i < subSteps; i++) {\n        acc = integrate(dtSec / subSteps);\n        appendPlotPoint();\n        if (state.y <= 0) {\n          state.y = 0;\n          state.v = 0;\n          state.running = false;\n          break;\n        }\n      }\n      updateReadouts(acc);\n      drawAll();\n\n      if (state.running) requestAnimationFrame(mainLoop);\n    }\n\n    // 初始化并监听窗口尺寸变化\n    window.addEventListener('resize', ()=> {\n      drawAll();\n    });\n\n    // 初始化\n    initialize();\n\n    // 键盘快捷键（空格播放/暂停，r 重置）\n    window.addEventListener('keydown', (e)=>{\n      if (e.code === 'Space') {\n        e.preventDefault();\n        if (state.running) pauseBtn.click(); else playBtn.click();\n      } else if (e.key === 'r' || e.key === 'R') {\n        resetBtn.click();\n      }\n    });\n\n    // 初次绘制\n    drawAll();\n  </script>",
              "css_content": ":root{\n      --bg:#f6f8fa;\n      --card:#ffffff;\n      --accent:#2b85ff;\n      --muted:#666;\n      --danger:#e64b4b;\n    }\n    body{\n      margin:0;\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background:linear-gradient(180deg,#eef4ff 0%,var(--bg) 60%);\n      color:#222;\n      display:flex;\n      min-height:100vh;\n      align-items:flex-start;\n      justify-content:center;\n      padding:24px;\n      box-sizing:border-box;\n    }\n    .container{\n      width:100%;\n      max-width:1100px;\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:20px;\n      align-items:start;\n    }\n    .panel{\n      background:var(--card);\n      border-radius:10px;\n      box-shadow:0 6px 18px rgba(30,40,60,0.08);\n      padding:16px;\n    }\n    .controls h2{\n      margin:0 0 8px 0;\n      font-size:18px;\n    }\n    label{\n      display:block;\n      margin:10px 0 6px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .row{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    input[type=\"range\"]{\n      width:100%;\n    }\n    input[type=\"number\"]{\n      width:100px;\n      padding:6px 8px;\n      border-radius:6px;\n      border:1px solid #d6dbe6;\n    }\n    .small{\n      font-size:12px;\n      color:var(--muted);\n    }\n    .buttons{\n      display:flex;\n      gap:8px;\n      margin-top:12px;\n    }\n    button{\n      background:var(--accent);\n      color:white;\n      border:none;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow:0 6px 14px rgba(43,133,255,0.18);\n    }\n    button.secondary{\n      background:#f3f6fb;\n      color:#214;\n      box-shadow:none;\n      font-weight:600;\n    }\n    button.danger{\n      background:var(--danger);\n      box-shadow:none;\n    }\n    .sim-area{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .canvas-wrap{\n      background: linear-gradient(180deg,#e9f0ff 0%, #ffffff 60%);\n      border:1px solid rgba(30,40,60,0.06);\n      height:420px;\n      border-radius:10px;\n      position:relative;\n      overflow:hidden;\n    }\n    canvas{\n      width:100%;\n      height:100%;\n      display:block;\n    }\n    .readouts{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n    .readout{\n      background:#fff;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid #eef3fb;\n      min-width:120px;\n      text-align:center;\n    }\n    .readout .v{\n      font-size:18px;\n      font-weight:700;\n    }\n    .footer-note{\n      font-size:12px;\n      color:var(--muted);\n      margin-top:8px;\n    }\n    .toggle{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      margin-top:6px;\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n      margin-top:6px;\n    }\n    .legend .dot{\n      width:12px;height:12px;border-radius:50%;\n      display:inline-block;\n      margin-right:6px;\n    }\n    @media (max-width:900px){\n      .container{grid-template-columns:1fr; padding:0 8px;}\n    }",
              "js_content": "// 简要说明：\n    // - 我们把画布的顶部视为 y = maxHeight（地面为 y = 0）。为直观，将高度转换为像素（pixelsPerMeter）。\n    // - 无阻力解析解： y(t)=y0 + v0*t + 0.5*g*t^2 （若向下为正，这里我们用向上为正的常见约定，在显示时做适配）\n    // - 数值积分（带线性阻力 b）：使用改进欧拉/显式欧拉做简单近似： dv/dt = g - (b/m)*v 。此演示将质量 m 设为 1 kg（相对无损失，b 为每秒的阻力常数）。\n    // - UI 控件会同步滑条与数字框，支持播放/暂停/重置/单步。\n\n    // 获取 DOM\n    const heightSlider = document.getElementById('height');\n    const heightNum = document.getElementById('height-num');\n    const h0ValSpan = document.getElementById('h0-val');\n\n    const v0Slider = document.getElementById('v0');\n    const v0Num = document.getElementById('v0-num');\n    const v0ValSpan = document.getElementById('v0-val');\n\n    const gSlider = document.getElementById('g');\n    const gNum = document.getElementById('g-num');\n    const gValSpan = document.getElementById('g-val');\n\n    const dragSlider = document.getElementById('drag');\n    const dragNum = document.getElementById('drag-num');\n    const bValSpan = document.getElementById('b-val');\n\n    const showAnalytic = document.getElementById('show-analytic');\n\n    const playBtn = document.getElementById('play');\n    const pauseBtn = document.getElementById('pause');\n    const resetBtn = document.getElementById('reset');\n    const stepBtn = document.getElementById('step');\n\n    const timeRead = document.getElementById('time');\n    const posRead = document.getElementById('pos');\n    const velRead = document.getElementById('vel');\n    const accRead = document.getElementById('acc');\n\n    const canvas = document.getElementById('viewCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n\n    const plot = document.getElementById('plotCanvas');\n    const pctx = plot.getContext('2d', { alpha: true });\n\n    // 状态与参数\n    let params = {\n      h0: parseFloat(heightSlider.value), // 初始高度（m）\n      v0: parseFloat(v0Slider.value),     // 初速度（m/s，向下为正）\n      g: parseFloat(gSlider.value),       // 重力（m/s^2，向下为正）\n      b: parseFloat(dragSlider.value),    // 线性阻力系数（kg/s）\n      m: 1.0                              // 质量（kg），用于数值积分（设为1 kg）\n    };\n\n    // 仿真状态（数值解）\n    let state = {\n      t: 0,\n      y: params.h0, // 高度（m），以地面为 y=0，初始在 h0\n      v: params.v0, // 速度（m/s），向下为正\n      running: false\n    };\n\n    // 绘图尺度与尺寸\n    function getCanvasSize() {\n      // 获取实际绘制像素大小\n      const rect = canvas.getBoundingClientRect();\n      const scale = window.devicePixelRatio || 1;\n      canvas.width = Math.round(rect.width * scale);\n      canvas.height = Math.round(rect.height * scale);\n      // plot canvas positioned at bottom overlay — resize similarly\n      const prect = plot.getBoundingClientRect();\n      plot.width = Math.round(prect.width * scale);\n      plot.height = Math.round(prect.height * scale);\n      // returns pixel per meter for converting height to canvas y\n      // 留出顶部空间 20px 与底部 plot 高度\n      const topPadding = 16 * scale;\n      const bottomPlotHeight = plot.height;\n      const usablePx = canvas.height - bottomPlotHeight - topPadding - 20 * scale;\n      // 让最大高度（例如 1.2*h0 或至少 10m）可视化\n      const maxVisibleMeters = Math.max(params.h0 * 1.2, 10);\n      const pixelsPerMeter = usablePx / maxVisibleMeters;\n      return {scale, topPadding, bottomPlotHeight, pixelsPerMeter};\n    }\n\n    // 更新参数与同步 UI\n    function syncFromUI() {\n      params.h0 = parseFloat(heightNum.value) || 0;\n      heightSlider.value = params.h0;\n      h0ValSpan.textContent = params.h0;\n\n      params.v0 = parseFloat(v0Num.value) || 0;\n      v0Slider.value = params.v0;\n      v0ValSpan.textContent = params.v0;\n\n      params.g = parseFloat(gNum.value) || 9.81;\n      gSlider.value = params.g;\n      gValSpan.textContent = params.g;\n\n      params.b = parseFloat(dragNum.value) || 0;\n      dragSlider.value = params.b;\n      bValSpan.textContent = params.b;\n    }\n\n    // 事件绑定（同步滑块与数字框）\n    function bindRangeAndNumber(rangeEl, numEl, valSpan){\n      rangeEl.addEventListener('input', ()=> {\n        numEl.value = rangeEl.value;\n        syncFromUI();\n      });\n      numEl.addEventListener('change', ()=>{\n        // clamp within range\n        const min = parseFloat(rangeEl.min);\n        const max = parseFloat(rangeEl.max);\n        let v = parseFloat(numEl.value);\n        if (isNaN(v)) v = parseFloat(rangeEl.value);\n        v = Math.max(min, Math.min(max, v));\n        numEl.value = v;\n        rangeEl.value = v;\n        syncFromUI();\n      });\n    }\n    bindRangeAndNumber(heightSlider, heightNum, h0ValSpan);\n    bindRangeAndNumber(v0Slider, v0Num, v0ValSpan);\n    bindRangeAndNumber(gSlider, gNum, gValSpan);\n    bindRangeAndNumber(dragSlider, dragNum, bValSpan);\n\n    // 播放控制\n    playBtn.addEventListener('click', ()=>{\n      if (!state.running) {\n        state.running = true;\n        lastFrameTime = null;\n        requestAnimationFrame(mainLoop);\n      }\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.running = false;\n    });\n    resetBtn.addEventListener('click', ()=>{\n      // 重置初始状态（不改变参数）\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    });\n    stepBtn.addEventListener('click', ()=>{\n      // 单步 0.02 s\n      singleStep(0.02);\n      drawAll();\n    });\n\n    // 重置到默认并初始化绘图\n    function initialize() {\n      syncFromUI();\n      state.t = 0;\n      state.y = params.h0;\n      state.v = params.v0;\n      clearPlot();\n      drawAll();\n    }\n\n    // 数值积分：显式欧拉（小步长）用于 dv/dt = g - (b/m)*v 和 dy/dt = v\n    function integrate(dt) {\n      // acceleration (向下为正)\n      const a = params.g - (params.b / params.m) * state.v;\n      // 更新\n      state.v += a * dt;\n      state.y -= state.v * dt; // 注意：我们用 y 为高度（地面为0），v 为向下为正 => y 减小\n      state.t += dt;\n      return a;\n    }\n\n    // 单步封装：检查是否触地（y<=0）\n    function singleStep(dt) {\n      if (state.y <= 0) return; // 已触地\n      // 如果没有阻力且启用解析显示，解析和数值应一致 — 但我们仍使用数值解用于动画（便于比较）\n      const a = integrate(dt);\n      if (state.y <= 0) {\n        state.y = 0;\n        state.v = 0;\n        state.running = false;\n      }\n      // 更新读数与记录绘图点\n      updateReadouts(a);\n      appendPlotPoint();\n    }\n\n    // 画布绘图函数\n    function clearPlot() {\n      const s = getCanvasSize();\n      // 绘制背景的 view canvas\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n      // 绘制 lower plot background\n      pctx.clearRect(0,0,plot.width,plot.height);\n      pctx.fillStyle = 'rgba(255,255,255,0.6)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n      // 初始化 plot data arrays\n      plotData = [];\n      analyticData = [];\n    }\n\n    // 存储绘图数据点\n    let plotData = []; // 数值：{t,y}\n    let analyticData = []; // 解析（b=0）：{t,y}\n\n    function appendPlotPoint() {\n      plotData.push({t: state.t, y: state.y});\n      // analytic data point up to current t if b==0 or we still draw analytic optionally\n      if (showAnalytic.checked) {\n        // compute analytic y (y0 - (v0*t + 0.5*g*t^2)) since y is height decreasing\n        const t = state.t;\n        const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n        analyticData.push({t: t, y: Math.max(0, yAnal)});\n      }\n    }\n\n    function drawAll() {\n      // Setup sizes\n      const s = getCanvasSize();\n      // clear background\n      ctx.fillStyle = '#eaf2ff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n\n      // Draw ground line\n      const groundYpx = canvas.height - s.bottomPlotHeight - 6 * s.scale;\n      ctx.fillStyle = '#c4d8ff';\n      ctx.fillRect(0, groundYpx, canvas.width, 6 * s.scale);\n\n      // Convert current height (m) to pixel Y\n      const toPixelY = (yMeters) => {\n        // highest visible meters we mapped earlier:\n        const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n        const usablePx = canvas.height - s.bottomPlotHeight - s.topPadding - 20 * s.scale;\n        const ppm = usablePx / maxVisMeters;\n        // top zero at s.topPadding\n        const ypx = s.topPadding + (maxVisMeters - yMeters) * ppm;\n        return ypx;\n      };\n\n      // Draw grid/scale ticks every 1m\n      const maxVisMeters = Math.max(params.h0 * 1.2, 10);\n      const stepMeters = chooseStep(maxVisMeters);\n      ctx.strokeStyle = 'rgba(30,40,60,0.05)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.font = `${12 * s.scale}px system-ui`;\n      ctx.fillStyle = '#234';\n\n      for (let m = 0; m <= Math.ceil(maxVisMeters / stepMeters) * stepMeters; m += stepMeters) {\n        const yPx = toPixelY(m);\n        ctx.beginPath();\n        ctx.moveTo(0, yPx);\n        ctx.lineTo(canvas.width, yPx);\n        ctx.stroke();\n        // label on left\n        ctx.fillText(`${m.toFixed(0)} m`, 6 * s.scale, yPx - 4 * s.scale);\n      }\n\n      // Draw analytic curve (if requested)\n      if (showAnalytic.checked) {\n        // compute series of points for analytic curve until hits ground or up to certain time\n        const color = '#ff7a7a';\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        const steps = 200;\n        let started = false;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = params.h0 - (params.v0 * t + 0.5 * params.g * t * t);\n          if (yAnal <= 0) {\n            // reached ground, draw endpoint and break\n            const x = (t / maxT) * canvas.width;\n            const y = toPixelY(0);\n            if (!started) ctx.moveTo(x, y);\n            else ctx.lineTo(x, y);\n            break;\n          }\n          const x = (t / maxT) * canvas.width;\n          const y = toPixelY(yAnal);\n          if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw numerical solution path (stored in plotData)\n      if (plotData.length > 1) {\n        ctx.strokeStyle = '#3ad27a';\n        ctx.lineWidth = 2 * s.scale;\n        ctx.beginPath();\n        const maxT = Math.max(2, state.t + 1.5);\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = (p.t / maxT) * canvas.width;\n          const y = toPixelY(p.y);\n          if (i === 0) ctx.moveTo(x,y);\n          else ctx.lineTo(x,y);\n        }\n        ctx.stroke();\n      }\n\n      // Draw the ball at current numeric state\n      const ballX = canvas.width * 0.15;\n      const ballYpx = toPixelY(state.y);\n      const ballRadius = 14 * s.scale;\n      // shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\n      ctx.ellipse(ballX + 6 * s.scale, groundYpx - 6 * s.scale, 28 * s.scale, 6 * s.scale, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball\n      ctx.beginPath();\n      const grd = ctx.createLinearGradient(ballX - ballRadius, ballYpx - ballRadius, ballX + ballRadius, ballYpx + ballRadius);\n      grd.addColorStop(0, '#2b85ff');\n      grd.addColorStop(1, '#1d4db3');\n      ctx.fillStyle = grd;\n      ctx.arc(ballX, ballYpx, ballRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ball outline\n      ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n      ctx.lineWidth = 1 * s.scale;\n      ctx.stroke();\n\n      // Draw small text: current numeric and analytic positions on right\n      ctx.fillStyle = '#123';\n      ctx.font = `${14 * s.scale}px system-ui`;\n      ctx.fillText(`数值 y = ${state.y.toFixed(3)} m`, canvas.width * 0.55, s.topPadding + 20 * s.scale);\n      const vSign = state.v;\n      ctx.fillText(`v = ${vSign.toFixed(3)} m/s`, canvas.width * 0.55, s.topPadding + 44 * s.scale);\n      // draw ground label\n      ctx.fillText('地面', 8 * s.scale, groundYpx + 18 * s.scale);\n      // draw axis for time along bottom (just a reference)\n      drawBottomPlot();\n    }\n\n    // 选择合理的刻度步长（米）\n    function chooseStep(maxMeters) {\n      if (maxMeters <= 10) return 1;\n      if (maxMeters <= 30) return 2;\n      if (maxMeters <= 60) return 5;\n      return 10;\n    }\n\n    // 绘制底部趋势图（位置随时间）\n    function drawBottomPlot() {\n      const s = getCanvasSize();\n      // clear plot overlay\n      pctx.clearRect(0,0,plot.width,plot.height);\n      // background\n      pctx.fillStyle = 'rgba(255,255,255,0.82)';\n      pctx.fillRect(0,0,plot.width,plot.height);\n\n      // draw axes\n      pctx.strokeStyle = 'rgba(30,40,60,0.12)';\n      pctx.lineWidth = 1 * s.scale;\n      pctx.beginPath();\n      pctx.moveTo(40 * s.scale, 10 * s.scale);\n      pctx.lineTo(40 * s.scale, plot.height - 24 * s.scale);\n      pctx.lineTo(plot.width - 10 * s.scale, plot.height - 24 * s.scale);\n      pctx.stroke();\n\n      // determine time window\n      const maxT = Math.max(2, state.t + 1.5);\n      // draw numeric data (green)\n      if (plotData.length > 0) {\n        pctx.strokeStyle = '#3ad27a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        for (let i = 0; i < plotData.length; i++) {\n          const p = plotData[i];\n          const x = 40 * s.scale + (p.t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - p.y) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y);\n          else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // analytic (red)\n      if (showAnalytic.checked) {\n        pctx.strokeStyle = '#ff7a7a';\n        pctx.lineWidth = 2 * s.scale;\n        pctx.beginPath();\n        const steps = 150;\n        for (let i = 0; i <= steps; i++) {\n          const t = (i / steps) * maxT;\n          const yAnal = Math.max(0, params.h0 - (params.v0 * t + 0.5 * params.g * t * t));\n          const x = 40 * s.scale + (t / maxT) * (plot.width - 60 * s.scale);\n          const y = 10 * s.scale + ((params.h0 - yAnal) / Math.max(params.h0, 1)) * (plot.height - 44 * s.scale);\n          if (i === 0) pctx.moveTo(x,y); else pctx.lineTo(x,y);\n        }\n        pctx.stroke();\n      }\n\n      // axis labels\n      pctx.fillStyle = '#234';\n      pctx.font = `${11 * s.scale}px system-ui`;\n      pctx.fillText('t (s)', plot.width - 50 * s.scale, plot.height - 8 * s.scale);\n      pctx.fillText('下降量 (m)', 6 * s.scale, 14 * s.scale);\n    }\n\n    // 更新数值读出\n    function updateReadouts(acc){\n      timeRead.textContent = state.t.toFixed(2);\n      posRead.textContent = state.y.toFixed(3);\n      velRead.textContent = state.v.toFixed(3);\n      // 加速度显示为向下为正，因此显示为 +g... 但为更直观，显示为负值（向下加速使高度负二阶）\n      // 这里我们显示加速度的代数值（向下为正）\n      const a = acc === undefined ? (params.g - params.b / params.m * state.v) : acc;\n      accRead.textContent = a.toFixed(3);\n    }\n\n    // 主循环（使用 requestAnimationFrame，按真实时间步进）\n    let lastFrameTime = null;\n    function mainLoop(timestamp) {\n      if (!state.running) return;\n      if (!lastFrameTime) lastFrameTime = timestamp;\n      const dtSec = Math.min(0.05, (timestamp - lastFrameTime) / 1000); // 限制最大步长\n      lastFrameTime = timestamp;\n\n      // 做若干小步以提高数值稳定性（分割，避免过大 dt）\n      const subSteps = Math.max(1, Math.ceil(dtSec / 0.01));\n      let acc = 0;\n      for (let i = 0; i < subSteps; i++) {\n        acc = integrate(dtSec / subSteps);\n        appendPlotPoint();\n        if (state.y <= 0) {\n          state.y = 0;\n          state.v = 0;\n          state.running = false;\n          break;\n        }\n      }\n      updateReadouts(acc);\n      drawAll();\n\n      if (state.running) requestAnimationFrame(mainLoop);\n    }\n\n    // 初始化并监听窗口尺寸变化\n    window.addEventListener('resize', ()=> {\n      drawAll();\n    });\n\n    // 初始化\n    initialize();\n\n    // 键盘快捷键（空格播放/暂停，r 重置）\n    window.addEventListener('keydown', (e)=>{\n      if (e.code === 'Space') {\n        e.preventDefault();\n        if (state.running) pauseBtn.click(); else playBtn.click();\n      } else if (e.key === 'r' || e.key === 'R') {\n        resetBtn.click();\n      }\n    });\n\n    // 初次绘制\n    drawAll();",
              "parameters": [],
              "status": "success"
            },
            "attempts": 1
          }
        },
        {
          "stage": "quality_check",
          "timestamp": "2025-08-09T12:56:26.260Z",
          "checks": {
            "hasCode": false,
            "codeLength": 0,
            "htmlTagsFound": [],
            "syntaxErrors": [],
            "bracketMatching": true,
            "syntaxValid": true
          }
        }
      ],
      "finalResult": {
        "codeGenerated": false,
        "codeLength": 0,
        "hasQualityIssues": false,
        "issues": {
          "htmlTags": 0,
          "bracketErrors": false,
          "syntaxErrors": false
        }
      },
      "success": true,
      "errors": [],
      "endTime": "2025-08-09T12:56:26.260Z",
      "duration": 84061
    },
    {
      "name": "复杂交互系统",
      "prompt": "创建一个包含多个交互元素的复杂系统，包括按钮、滑块和动画效果",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T12:56:31.263Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T13:01:32.245Z",
          "response": {
            "error": "fetch failed",
            "stack": "TypeError: fetch failed\n    at node:internal/deps/undici/undici:15363:13\n    at async makeAPIRequest (file:///Users/yangchengxuan/Desktop/hackathone2/detailed_experiment_test.js:54:26)\n    at async runDetailedExperimentTest (file:///Users/yangchengxuan/Desktop/hackathone2/detailed_experiment_test.js:110:38)"
          }
        }
      ],
      "finalResult": null,
      "success": false,
      "errors": [
        {
          "message": "API请求失败: fetch failed",
          "stack": "Error: API请求失败: fetch failed\n    at runDetailedExperimentTest (file:///Users/yangchengxuan/Desktop/hackathone2/detailed_experiment_test.js:124:23)",
          "timestamp": "2025-08-09T13:01:32.245Z"
        }
      ],
      "endTime": "2025-08-09T13:01:32.245Z",
      "duration": 300982
    },
    {
      "name": "数学可视化",
      "prompt": "创建一个数学函数可视化工具，能够绘制sin和cos函数",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T13:01:37.247Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T13:06:38.598Z",
          "response": {
            "error": "fetch failed",
            "stack": "TypeError: fetch failed\n    at node:internal/deps/undici/undici:15363:13\n    at async makeAPIRequest (file:///Users/yangchengxuan/Desktop/hackathone2/detailed_experiment_test.js:54:26)\n    at async runDetailedExperimentTest (file:///Users/yangchengxuan/Desktop/hackathone2/detailed_experiment_test.js:110:38)"
          }
        }
      ],
      "finalResult": null,
      "success": false,
      "errors": [
        {
          "message": "API请求失败: fetch failed",
          "stack": "Error: API请求失败: fetch failed\n    at runDetailedExperimentTest (file:///Users/yangchengxuan/Desktop/hackathone2/detailed_experiment_test.js:124:23)",
          "timestamp": "2025-08-09T13:06:38.598Z"
        }
      ],
      "endTime": "2025-08-09T13:06:38.598Z",
      "duration": 301351
    }
  ],
  "summary": {
    "total": 3,
    "passed": 1,
    "failed": 2,
    "errors": [
      "复杂交互系统: API请求失败: fetch failed",
      "数学可视化: API请求失败: fetch failed"
    ]
  }
}