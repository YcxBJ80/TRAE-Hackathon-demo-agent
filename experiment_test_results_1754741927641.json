{
  "timestamp": "2025-08-09T12:12:15.463Z",
  "testCases": [
    {
      "name": "简单物理模拟",
      "prompt": "创建一个简单的重力球下落模拟",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T12:12:15.467Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T12:15:22.108Z",
          "response": {
            "status": 200,
            "statusText": "OK",
            "headers": {
              "access-control-allow-origin": "*",
              "connection": "keep-alive",
              "content-length": "31350",
              "content-type": "application/json; charset=utf-8",
              "date": "Sat, 09 Aug 2025 12:15:22 GMT",
              "etag": "W/\"7a76-ngwMcK4oLhlC9GwZQp6gs/AI6e0\"",
              "keep-alive": "timeout=5",
              "x-powered-by": "Express"
            },
            "data": {
              "success": true,
              "data": {
                "experiment_id": "6df24f7f-6163-4256-a2f8-d8458ebc3678",
                "title": "重力球下落模拟",
                "description": "摘要（简短）\n- 没有检索到针对“创建一个简单的重力球下落模拟”的特定 Wikipedia 条目结果。\n- 模拟基于自由落体和重力的基本物理：在近地面处重力加速度 g ≈ 9.81 m/s²，忽略空气阻力时位移 s = 1/2 g t²，速度 v = g t（来源参考: Wikipedia — \"自由落体\" 与 \"重力\"）。\n- 本示例实现一个交互式的重力球下落模拟，支持修改初始高度、重力 g、质量、线性/二次空气阻力、恢复系数（弹性碰撞）与时间缩放；并可实时可视化位置与速度曲线与动画。\n\n下面是完整可运行的 HTML 文件代码。将其保存为 .html 文件并在浏览器中打开即可运行。",
                "html_content": "<h1>重力球下落模拟</h1>\n  <p class=\"small\">说明：模拟基于经典力学。可调参数包括高度、重力、质量、空气阻力类型与系数、恢复系数与时间缩放。可切换播放/暂停/重置并查看高度/速度曲线。</p>\n\n  <div class=\"container\">\n    <div class=\"left\">\n      <canvas id=\"scene\" width=\"720\" height=\"420\" aria-label=\"球下落动画与曲线\"></canvas>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"controls\" role=\"region\" aria-label=\"模拟控制\">\n        <div class=\"row\">\n          <label for=\"heightRange\">初始高度 (m)</label>\n          <input id=\"heightRange\" type=\"range\" min=\"0\" max=\"50\" step=\"0.1\" value=\"10\">\n          <input id=\"heightNum\" type=\"number\" min=\"0\" max=\"1000\" step=\"0.1\" value=\"10\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"gRange\">重力 g (m/s²)</label>\n          <input id=\"gRange\" type=\"range\" min=\"0\" max=\"20\" step=\"0.01\" value=\"9.81\">\n          <input id=\"gNum\" type=\"number\" min=\"0\" max=\"100\" step=\"0.01\" value=\"9.81\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"massRange\">质量 m (kg)</label>\n          <input id=\"massRange\" type=\"range\" min=\"0.01\" max=\"10\" step=\"0.01\" value=\"1\">\n          <input id=\"massNum\" type=\"number\" min=\"0.01\" max=\"1000\" step=\"0.01\" value=\"1\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"dragType\">空气阻力</label>\n          <select id=\"dragType\">\n            <option value=\"none\">无</option>\n            <option value=\"linear\">线性阻力: F = -k v</option>\n            <option value=\"quadratic\">二次阻力: F = -k v |v|</option>\n          </select>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"dragRange\">阻力系数 k</label>\n          <input id=\"dragRange\" type=\"range\" min=\"0\" max=\"10\" step=\"0.01\" value=\"0.1\">\n          <input id=\"dragNum\" type=\"number\" min=\"0\" max=\"1000\" step=\"0.01\" value=\"0.1\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"restitutionRange\">恢复系数</label>\n          <input id=\"restitutionRange\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.6\">\n          <input id=\"restitutionNum\" type=\"number\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.6\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"timeScaleRange\">时间缩放</label>\n          <input id=\"timeScaleRange\" type=\"range\" min=\"0.1\" max=\"4\" step=\"0.1\" value=\"1\">\n          <input id=\"timeScaleNum\" type=\"number\" min=\"0.1\" max=\"10\" step=\"0.1\" value=\"1\">\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <button id=\"playBtn\">播放</button>\n          <button id=\"pauseBtn\">暂停</button>\n          <button id=\"resetBtn\">重置</button>\n        </div>\n\n        <div class=\"readouts\" aria-live=\"polite\">\n          <div class=\"panel\">\n            <div>时间 (s)</div>\n            <div id=\"timeDisplay\">0.00</div>\n          </div>\n          <div class=\"panel\">\n            <div>高度 (m)</div>\n            <div id=\"heightDisplay\">0.00</div>\n          </div>\n          <div class=\"panel\">\n            <div>速度 (m/s)</div>\n            <div id=\"velDisplay\">0.00</div>\n          </div>\n          <div class=\"panel\">\n            <div>弹跳次数</div>\n            <div id=\"bouncesDisplay\">0</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <div class=\"small\">方程（无空气阻力，初速度=0）: s = 1/2 g t²；v = g t</div>\n        </div>\n      </div>\n\n      <div style=\"height:12px;\"></div>\n\n      <div class=\"controls\" aria-label=\"图表显示\">\n        <div style=\"font-weight:600; margin-bottom:6px;\">实时曲线</div>\n        <canvas id=\"graph\" class=\"graph\" width=\"340\" height=\"160\" aria-label=\"高度和速度图\"></canvas>\n        <div style=\"margin-top:6px; font-size:0.85rem; color:#555;\">\n          绿色：高度 (m)； 橙色：速度 (m/s)\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <footer>\n    提示：拖动滑块或直接在数字框中输入数值。切换空气阻力可观察终端速度（有限速度）或理想无限增长的速度。\n  </footer>\n\n<script>\n/*\n  重力球下落模拟\n  - 采用半隐式欧拉（semi-implicit Euler）积分\n  - 支持线性与二次阻力\n  - 当小于阈值并接触地面时可停止或弹起（由恢复系数决定）\n  - 无外部依赖，单文件运行\n*/\n\n/* 获取 DOM 元素 */\nconst canvas = document.getElementById('scene');\nconst ctx = canvas.getContext('2d');\nconst graph = document.getElementById('graph');\nconst gctx = graph.getContext('2d');\n\nconst heightRange = document.getElementById('heightRange');\nconst heightNum = document.getElementById('heightNum');\nconst gRange = document.getElementById('gRange');\nconst gNum = document.getElementById('gNum');\nconst massRange = document.getElementById('massRange');\nconst massNum = document.getElementById('massNum');\nconst dragType = document.getElementById('dragType');\nconst dragRange = document.getElementById('dragRange');\nconst dragNum = document.getElementById('dragNum');\nconst restitutionRange = document.getElementById('restitutionRange');\nconst restitutionNum = document.getElementById('restitutionNum');\nconst timeScaleRange = document.getElementById('timeScaleRange');\nconst timeScaleNum = document.getElementById('timeScaleNum');\n\nconst playBtn = document.getElementById('playBtn');\nconst pauseBtn = document.getElementById('pauseBtn');\nconst resetBtn = document.getElementById('resetBtn');\n\nconst timeDisplay = document.getElementById('timeDisplay');\nconst heightDisplay = document.getElementById('heightDisplay');\nconst velDisplay = document.getElementById('velDisplay');\nconst bouncesDisplay = document.getElementById('bouncesDisplay');\n\n/* 参数同步工具 */\nfunction syncRangeNum(range, num) {\n  range.addEventListener('input', ()=> num.value = range.value);\n  num.addEventListener('input', ()=> range.value = num.value);\n}\nsyncRangeNum(heightRange, heightNum);\nsyncRangeNum(gRange, gNum);\nsyncRangeNum(massRange, massNum);\nsyncRangeNum(dragRange, dragNum);\nsyncRangeNum(restitutionRange, restitutionNum);\nsyncRangeNum(timeScaleRange, timeScaleNum);\n\n/* 初始物理状态（以 SI 单位） */\nlet params = {\n  height: parseFloat(heightRange.value), // m\n  g: parseFloat(gRange.value),\n  mass: parseFloat(massRange.value),\n  dragType: dragType.value,\n  k: parseFloat(dragRange.value),\n  restitution: parseFloat(restitutionRange.value),\n  timeScale: parseFloat(timeScaleRange.value)\n};\n\nlet state = {\n  y: params.height,   // 高度（m），地面为 y=0\n  v: 0,               // 向下为正速度（m/s）\n  t: 0,               // 模拟时间 s\n  running: false,\n  bounces: 0\n};\n\nfunction updateParamsFromUI(){\n  params.height = parseFloat(heightRange.value);\n  params.g = parseFloat(gRange.value);\n  params.mass = parseFloat(massRange.value);\n  params.dragType = dragType.value;\n  params.k = parseFloat(dragRange.value);\n  params.restitution = parseFloat(restitutionRange.value);\n  params.timeScale = parseFloat(timeScaleRange.value);\n}\n\n/* 图像与坐标设置 */\nconst W = canvas.width;\nconst H = canvas.height;\nconst groundY = H - 40; // 画布上的地面像素位置\nconst ballRadiusPx = 14;\n\n/* 将物理高度（m）映射为画布像素高度（y），需要某个缩放：\n   我们动态根据初始高度和一定余量设定像素/米比例 */\nfunction computeScale() {\n  const topMargin = 20;\n  const available = groundY - topMargin - ballRadiusPx;\n  // 期望容纳的高度范围：max(initial height, 10m)\n  const maxH = Math.max(params.height * 1.2, 10);\n  return available / maxH;\n}\n\n/* 绘制场景：球与地面 */\nfunction drawScene() {\n  ctx.clearRect(0,0,W,H);\n\n  // 背景渐变\n  const grad = ctx.createLinearGradient(0,0,0,H);\n  grad.addColorStop(0, '#f5fbff');\n  grad.addColorStop(1, '#ffffff');\n  ctx.fillStyle = grad;\n  ctx.fillRect(0,0,W,H);\n\n  // 地面\n  ctx.fillStyle = '#d9e6f2';\n  ctx.fillRect(0, groundY, W, H-groundY);\n  ctx.fillStyle = '#c0d2e8';\n  ctx.fillRect(0, groundY+2, W, 6);\n\n  // 绘制高度刻度\n  ctx.fillStyle = '#333';\n  ctx.font = '12px sans-serif';\n  ctx.textAlign = 'left';\n  ctx.fillText('地面', 8, groundY + 14);\n\n  // 计算 scale\n  const scale = computeScale();\n  const topMargin = 20;\n  // 物理高度 y -> pixel Y position\n  function yToPixel(yMeters) {\n    // higher meters -> smaller pixel (towards top)\n    return groundY - (yMeters * scale);\n  }\n\n  // 球位置\n  const ballX = W/2;\n  const ballY = yToPixel(state.y);\n\n  // 球影子（椭圆）\n  const shadowScale = 1 - Math.min(state.y / Math.max(params.height, 1), 1) * 0.8;\n  ctx.fillStyle = 'rgba(0,0,0,0.15)';\n  ctx.beginPath();\n  ctx.ellipse(ballX, groundY + 6, ballRadiusPx * 1.2 * shadowScale, ballRadiusPx * 0.5 * shadowScale, 0, 0, Math.PI*2);\n  ctx.fill();\n\n  // 球\n  const gradient = ctx.createRadialGradient(ballX - 6, ballY - 6, 2, ballX, ballY, ballRadiusPx*1.2);\n  gradient.addColorStop(0, '#fff7e6');\n  gradient.addColorStop(0.5, '#ffb74d');\n  gradient.addColorStop(1, '#ff8f00');\n  ctx.fillStyle = gradient;\n  ctx.beginPath();\n  ctx.arc(ballX, ballY, ballRadiusPx, 0, Math.PI*2);\n  ctx.fill();\n  ctx.strokeStyle = '#b56500';\n  ctx.lineWidth = 2;\n  ctx.stroke();\n\n  // 绘制高度刻度线（每隔一定米）\n  ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n  ctx.lineWidth = 1;\n  ctx.textAlign = 'right';\n  ctx.fillStyle = '#666';\n  ctx.font = '11px sans-serif';\n  const maxMeters = Math.max(params.height * 1.2, 10);\n  const meterStep = chooseNiceStep(maxMeters);\n  for(let m = 0; m <= maxMeters + 0.0001; m += meterStep){\n    const py = yToPixel(m);\n    ctx.beginPath();\n    ctx.moveTo(10, py);\n    ctx.lineTo(W-10, py);\n    ctx.stroke();\n    ctx.fillText(m.toFixed(0) + ' m', W - 12, py - 2);\n  }\n}\n\n/* 选择刻度步长，便于显示 */\nfunction chooseNiceStep(maxMeters){\n  // 选择 1,2,5,10,20,...\n  const candidates = [0.5,1,2,5,10,20,50];\n  for (let s of candidates){\n    if (maxMeters / s <= 12) return s;\n  }\n  return 100;\n}\n\n/* 图表绘制：清空并绘制曲线（高度与速度） */\nlet history = []; // {t, y, v}\nfunction drawGraph(){\n  const w = graph.width;\n  const h = graph.height;\n  gctx.clearRect(0,0,w,h);\n  gctx.fillStyle = '#fff';\n  gctx.fillRect(0,0,w,h);\n\n  // 背景网格\n  gctx.strokeStyle = '#f0f0f0';\n  gctx.lineWidth = 1;\n  for(let i=0;i<6;i++){\n    const yy = (i+1)*h/6;\n    gctx.beginPath(); gctx.moveTo(0,yy); gctx.lineTo(w,yy); gctx.stroke();\n  }\n\n  if (history.length < 2) return;\n\n  const t0 = history[0].t;\n  const t1 = history[history.length-1].t;\n  const dt = Math.max(0.0001, t1 - t0);\n\n  // find y max and v abs max for scaling\n  let yMax = 0;\n  let vMax = 0;\n  history.forEach(pt => {\n    if (pt.y > yMax) yMax = pt.y;\n    vMax = Math.max(vMax, Math.abs(pt.v));\n  });\n  yMax = Math.max(yMax, params.height, 1);\n  vMax = Math.max(vMax, 1);\n\n  // map functions\n  function tx(t){ return (t - t0) / dt * (w-20) + 10; }\n  function tyY(y){ return h - 10 - (y / yMax) * (h - 30); }\n  function tyV(v){ return h - 10 - ( (v + vMax) / (2*vMax) ) * (h - 30); }\n\n  // Draw height (green)\n  gctx.beginPath();\n  gctx.strokeStyle = '#2e8b57';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyY(pt.y);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Draw velocity (orange)\n  gctx.beginPath();\n  gctx.strokeStyle = '#ff8c00';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyV(pt.v);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Axes labels\n  gctx.fillStyle = '#333';\n  gctx.font = '11px sans-serif';\n  gctx.textAlign = 'left';\n  gctx.fillText('t (s): ' + t0.toFixed(2) + ' → ' + t1.toFixed(2), 10, 12);\n  gctx.fillStyle = '#2e8b57';\n  gctx.fillText('高度 (m)', 10, 26);\n  gctx.fillStyle = '#ff8c00';\n  gctx.fillText('速度 (m/s)', 100, 26);\n}\n\n/* 物理更新：半隐式欧拉 */\nfunction physicsStep(dtReal) {\n  // dtReal in seconds real time; apply timeScale\n  const dt = dtReal * params.timeScale;\n  // compute acceleration downward positive\n  let a = params.g; // (m/s^2)\n  if (params.dragType === 'linear') {\n    // Fdrag = -k v => a = g - (k/m) v (v positive downward)\n    a = params.g - (params.k / params.mass) * state.v;\n  } else if (params.dragType === 'quadratic') {\n    // Fdrag = -k v |v| => a = g - (k/m) v |v|\n    a = params.g - (params.k / params.mass) * state.v * Math.abs(state.v);\n  }\n\n  // semi-implicit Euler: v += a * dt; y += v * dt;\n  state.v += a * dt;\n  state.y -= state.v * dt; // subtract because y measured from ground upward -> but we store y as height above ground\n  state.t += dt;\n\n  // Ground collision\n  if (state.y <= 0) {\n    // set to ground\n    state.y = 0;\n    // if penetration, reflect velocity\n    if (Math.abs(state.v) > 1e-6) {\n      // bounce: reverse and apply restitution\n      state.v = -state.v * params.restitution;\n      state.bounces += 1;\n    } else {\n      state.v = 0;\n    }\n\n    // Stop bouncing if velocity is very small\n    if (Math.abs(state.v) < 0.05) {\n      state.v = 0;\n      // If timeScale is 0, keep running? We'll pause automatically when ball rests\n      // We'll choose to pause when ball is at rest on ground.\n      state.running = false;\n    }\n  }\n}\n\n/* Animation loop */\nlet lastTs = null;\nfunction loop(ts) {\n  if (!lastTs) lastTs = ts;\n  const dtMs = ts - lastTs;\n  lastTs = ts;\n\n  if (state.running) {\n    // update parameters from UI in case user changed on-the-fly\n    updateParamsFromUI();\n\n    // perform multiple small steps if dt large to improve stability\n    const maxStep = 20; // ms\n    let remaining = dtMs;\n    while (remaining > 0) {\n      const step = Math.min(remaining, maxStep);\n      physicsStep(step / 1000);\n      remaining -= step;\n      // record history\n      history.push({t: state.t, y: state.y, v: state.v});\n      if (history.length > 1000) history.shift();\n    }\n  }\n\n  // Draw\n  drawScene();\n  drawGraph();\n\n  // Update displays\n  timeDisplay.textContent = state.t.toFixed(2);\n  heightDisplay.textContent = state.y.toFixed(2);\n  velDisplay.textContent = state.v.toFixed(2);\n  bouncesDisplay.textContent = state.bounces;\n\n  requestAnimationFrame(loop);\n}\n\n/* 控件事件 */\nplayBtn.addEventListener('click', ()=>{\n  // if simulation finished (running=false and y==0 and v==0), reset bounces/time? We'll just resume if not moving or start\n  updateParamsFromUI();\n  if (!state.running && state.y <= 0 && state.v === 0 && state.t > 0) {\n    // do nothing special: allow restart from current state (resting)\n  }\n  state.running = true;\n});\n\npauseBtn.addEventListener('click', ()=>{\n  state.running = false;\n});\n\nresetBtn.addEventListener('click', ()=>{\n  updateParamsFromUI();\n  // reset state\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n});\n\n/* 当输入修改时立即应用到参数（不改变当前状态除非重置） */\n[heightRange, heightNum, gRange, gNum, massRange, massNum, dragType, dragRange, dragNum, restitutionRange, restitutionNum, timeScaleRange, timeScaleNum].forEach(el=>{\n  el.addEventListener('input', ()=>{\n    updateParamsFromUI();\n    // if height changed via UI and simulation 未开始，则更新初始高度显示; 若想强制立即移动球，可选择在界面上按重置\n  });\n});\n\n/* 初始化 */\nfunction init() {\n  updateParamsFromUI();\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n\n  // ensure numeric inputs reflect ranges\n  heightNum.value = heightRange.value;\n  gNum.value = gRange.value;\n  massNum.value = massRange.value;\n  dragNum.value = dragRange.value;\n  restitutionNum.value = restitutionRange.value;\n  timeScaleNum.value = timeScaleRange.value;\n\n  requestAnimationFrame(loop);\n}\n\ninit();\n\n/* 可选：当窗口大小改变时也调整画布显示（保持像素宽高），使视觉清晰 */\nwindow.addEventListener('resize', ()=> {\n  // keep canvas CSS size but actual pixel size already set; leaving as-is for simplicity\n});\n</script>",
                "css_content": "body { font-family: -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 16px; color: #222; }\n    h1 { margin-top: 0; }\n    .container { display: flex; gap: 16px; flex-wrap: wrap; }\n    .left { flex: 1 1 520px; min-width: 320px; }\n    .right { width: 360px; min-width: 300px; }\n    canvas { background: linear-gradient(#eef,#fff); border: 1px solid #ccc; display: block; width: 100%; height: 420px; }\n    .controls { background: #fafafa; border: 1px solid #e0e0e0; padding: 12px; border-radius: 6px; }\n    .row { display:flex; align-items:center; gap:8px; margin:8px 0; }\n    label { width: 120px; font-size: 0.95rem; color:#333; }\n    input[type=\"range\"] { flex:1; }\n    input[type=\"number\"] { width:84px; padding:4px; }\n    select { padding:4px; }\n    button { padding:8px 12px; margin-right:8px; }\n    .small { font-size:0.85rem; color:#555; }\n    .readouts { display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; }\n    .panel { background:#fff; border:1px solid #eee; padding:8px; border-radius:6px; min-width:110px; text-align:center; }\n    .graph { height:160px; border:1px solid #ddd; background:#fff; }\n    footer { margin-top:16px; font-size:0.85rem; color:#666; }\n    @media (max-width:800px){ .right { width:100%; } }",
                "js_content": "/*\n  重力球下落模拟\n  - 采用半隐式欧拉（semi-implicit Euler）积分\n  - 支持线性与二次阻力\n  - 当小于阈值并接触地面时可停止或弹起（由恢复系数决定）\n  - 无外部依赖，单文件运行\n*/\n\n/* 获取 DOM 元素 */\nconst canvas = document.getElementById('scene');\nconst ctx = canvas.getContext('2d');\nconst graph = document.getElementById('graph');\nconst gctx = graph.getContext('2d');\n\nconst heightRange = document.getElementById('heightRange');\nconst heightNum = document.getElementById('heightNum');\nconst gRange = document.getElementById('gRange');\nconst gNum = document.getElementById('gNum');\nconst massRange = document.getElementById('massRange');\nconst massNum = document.getElementById('massNum');\nconst dragType = document.getElementById('dragType');\nconst dragRange = document.getElementById('dragRange');\nconst dragNum = document.getElementById('dragNum');\nconst restitutionRange = document.getElementById('restitutionRange');\nconst restitutionNum = document.getElementById('restitutionNum');\nconst timeScaleRange = document.getElementById('timeScaleRange');\nconst timeScaleNum = document.getElementById('timeScaleNum');\n\nconst playBtn = document.getElementById('playBtn');\nconst pauseBtn = document.getElementById('pauseBtn');\nconst resetBtn = document.getElementById('resetBtn');\n\nconst timeDisplay = document.getElementById('timeDisplay');\nconst heightDisplay = document.getElementById('heightDisplay');\nconst velDisplay = document.getElementById('velDisplay');\nconst bouncesDisplay = document.getElementById('bouncesDisplay');\n\n/* 参数同步工具 */\nfunction syncRangeNum(range, num) {\n  range.addEventListener('input', ()=> num.value = range.value);\n  num.addEventListener('input', ()=> range.value = num.value);\n}\nsyncRangeNum(heightRange, heightNum);\nsyncRangeNum(gRange, gNum);\nsyncRangeNum(massRange, massNum);\nsyncRangeNum(dragRange, dragNum);\nsyncRangeNum(restitutionRange, restitutionNum);\nsyncRangeNum(timeScaleRange, timeScaleNum);\n\n/* 初始物理状态（以 SI 单位） */\nlet params = {\n  height: parseFloat(heightRange.value), // m\n  g: parseFloat(gRange.value),\n  mass: parseFloat(massRange.value),\n  dragType: dragType.value,\n  k: parseFloat(dragRange.value),\n  restitution: parseFloat(restitutionRange.value),\n  timeScale: parseFloat(timeScaleRange.value)\n};\n\nlet state = {\n  y: params.height,   // 高度（m），地面为 y=0\n  v: 0,               // 向下为正速度（m/s）\n  t: 0,               // 模拟时间 s\n  running: false,\n  bounces: 0\n};\n\nfunction updateParamsFromUI(){\n  params.height = parseFloat(heightRange.value);\n  params.g = parseFloat(gRange.value);\n  params.mass = parseFloat(massRange.value);\n  params.dragType = dragType.value;\n  params.k = parseFloat(dragRange.value);\n  params.restitution = parseFloat(restitutionRange.value);\n  params.timeScale = parseFloat(timeScaleRange.value);\n}\n\n/* 图像与坐标设置 */\nconst W = canvas.width;\nconst H = canvas.height;\nconst groundY = H - 40; // 画布上的地面像素位置\nconst ballRadiusPx = 14;\n\n/* 将物理高度（m）映射为画布像素高度（y），需要某个缩放：\n   我们动态根据初始高度和一定余量设定像素/米比例 */\nfunction computeScale() {\n  const topMargin = 20;\n  const available = groundY - topMargin - ballRadiusPx;\n  // 期望容纳的高度范围：max(initial height, 10m)\n  const maxH = Math.max(params.height * 1.2, 10);\n  return available / maxH;\n}\n\n/* 绘制场景：球与地面 */\nfunction drawScene() {\n  ctx.clearRect(0,0,W,H);\n\n  // 背景渐变\n  const grad = ctx.createLinearGradient(0,0,0,H);\n  grad.addColorStop(0, '#f5fbff');\n  grad.addColorStop(1, '#ffffff');\n  ctx.fillStyle = grad;\n  ctx.fillRect(0,0,W,H);\n\n  // 地面\n  ctx.fillStyle = '#d9e6f2';\n  ctx.fillRect(0, groundY, W, H-groundY);\n  ctx.fillStyle = '#c0d2e8';\n  ctx.fillRect(0, groundY+2, W, 6);\n\n  // 绘制高度刻度\n  ctx.fillStyle = '#333';\n  ctx.font = '12px sans-serif';\n  ctx.textAlign = 'left';\n  ctx.fillText('地面', 8, groundY + 14);\n\n  // 计算 scale\n  const scale = computeScale();\n  const topMargin = 20;\n  // 物理高度 y -> pixel Y position\n  function yToPixel(yMeters) {\n    // higher meters -> smaller pixel (towards top)\n    return groundY - (yMeters * scale);\n  }\n\n  // 球位置\n  const ballX = W/2;\n  const ballY = yToPixel(state.y);\n\n  // 球影子（椭圆）\n  const shadowScale = 1 - Math.min(state.y / Math.max(params.height, 1), 1) * 0.8;\n  ctx.fillStyle = 'rgba(0,0,0,0.15)';\n  ctx.beginPath();\n  ctx.ellipse(ballX, groundY + 6, ballRadiusPx * 1.2 * shadowScale, ballRadiusPx * 0.5 * shadowScale, 0, 0, Math.PI*2);\n  ctx.fill();\n\n  // 球\n  const gradient = ctx.createRadialGradient(ballX - 6, ballY - 6, 2, ballX, ballY, ballRadiusPx*1.2);\n  gradient.addColorStop(0, '#fff7e6');\n  gradient.addColorStop(0.5, '#ffb74d');\n  gradient.addColorStop(1, '#ff8f00');\n  ctx.fillStyle = gradient;\n  ctx.beginPath();\n  ctx.arc(ballX, ballY, ballRadiusPx, 0, Math.PI*2);\n  ctx.fill();\n  ctx.strokeStyle = '#b56500';\n  ctx.lineWidth = 2;\n  ctx.stroke();\n\n  // 绘制高度刻度线（每隔一定米）\n  ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n  ctx.lineWidth = 1;\n  ctx.textAlign = 'right';\n  ctx.fillStyle = '#666';\n  ctx.font = '11px sans-serif';\n  const maxMeters = Math.max(params.height * 1.2, 10);\n  const meterStep = chooseNiceStep(maxMeters);\n  for(let m = 0; m <= maxMeters + 0.0001; m += meterStep){\n    const py = yToPixel(m);\n    ctx.beginPath();\n    ctx.moveTo(10, py);\n    ctx.lineTo(W-10, py);\n    ctx.stroke();\n    ctx.fillText(m.toFixed(0) + ' m', W - 12, py - 2);\n  }\n}\n\n/* 选择刻度步长，便于显示 */\nfunction chooseNiceStep(maxMeters){\n  // 选择 1,2,5,10,20,...\n  const candidates = [0.5,1,2,5,10,20,50];\n  for (let s of candidates){\n    if (maxMeters / s <= 12) return s;\n  }\n  return 100;\n}\n\n/* 图表绘制：清空并绘制曲线（高度与速度） */\nlet history = []; // {t, y, v}\nfunction drawGraph(){\n  const w = graph.width;\n  const h = graph.height;\n  gctx.clearRect(0,0,w,h);\n  gctx.fillStyle = '#fff';\n  gctx.fillRect(0,0,w,h);\n\n  // 背景网格\n  gctx.strokeStyle = '#f0f0f0';\n  gctx.lineWidth = 1;\n  for(let i=0;i<6;i++){\n    const yy = (i+1)*h/6;\n    gctx.beginPath(); gctx.moveTo(0,yy); gctx.lineTo(w,yy); gctx.stroke();\n  }\n\n  if (history.length < 2) return;\n\n  const t0 = history[0].t;\n  const t1 = history[history.length-1].t;\n  const dt = Math.max(0.0001, t1 - t0);\n\n  // find y max and v abs max for scaling\n  let yMax = 0;\n  let vMax = 0;\n  history.forEach(pt => {\n    if (pt.y > yMax) yMax = pt.y;\n    vMax = Math.max(vMax, Math.abs(pt.v));\n  });\n  yMax = Math.max(yMax, params.height, 1);\n  vMax = Math.max(vMax, 1);\n\n  // map functions\n  function tx(t){ return (t - t0) / dt * (w-20) + 10; }\n  function tyY(y){ return h - 10 - (y / yMax) * (h - 30); }\n  function tyV(v){ return h - 10 - ( (v + vMax) / (2*vMax) ) * (h - 30); }\n\n  // Draw height (green)\n  gctx.beginPath();\n  gctx.strokeStyle = '#2e8b57';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyY(pt.y);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Draw velocity (orange)\n  gctx.beginPath();\n  gctx.strokeStyle = '#ff8c00';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyV(pt.v);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Axes labels\n  gctx.fillStyle = '#333';\n  gctx.font = '11px sans-serif';\n  gctx.textAlign = 'left';\n  gctx.fillText('t (s): ' + t0.toFixed(2) + ' → ' + t1.toFixed(2), 10, 12);\n  gctx.fillStyle = '#2e8b57';\n  gctx.fillText('高度 (m)', 10, 26);\n  gctx.fillStyle = '#ff8c00';\n  gctx.fillText('速度 (m/s)', 100, 26);\n}\n\n/* 物理更新：半隐式欧拉 */\nfunction physicsStep(dtReal) {\n  // dtReal in seconds real time; apply timeScale\n  const dt = dtReal * params.timeScale;\n  // compute acceleration downward positive\n  let a = params.g; // (m/s^2)\n  if (params.dragType === 'linear') {\n    // Fdrag = -k v => a = g - (k/m) v (v positive downward)\n    a = params.g - (params.k / params.mass) * state.v;\n  } else if (params.dragType === 'quadratic') {\n    // Fdrag = -k v |v| => a = g - (k/m) v |v|\n    a = params.g - (params.k / params.mass) * state.v * Math.abs(state.v);\n  }\n\n  // semi-implicit Euler: v += a * dt; y += v * dt;\n  state.v += a * dt;\n  state.y -= state.v * dt; // subtract because y measured from ground upward -> but we store y as height above ground\n  state.t += dt;\n\n  // Ground collision\n  if (state.y <= 0) {\n    // set to ground\n    state.y = 0;\n    // if penetration, reflect velocity\n    if (Math.abs(state.v) > 1e-6) {\n      // bounce: reverse and apply restitution\n      state.v = -state.v * params.restitution;\n      state.bounces += 1;\n    } else {\n      state.v = 0;\n    }\n\n    // Stop bouncing if velocity is very small\n    if (Math.abs(state.v) < 0.05) {\n      state.v = 0;\n      // If timeScale is 0, keep running? We'll pause automatically when ball rests\n      // We'll choose to pause when ball is at rest on ground.\n      state.running = false;\n    }\n  }\n}\n\n/* Animation loop */\nlet lastTs = null;\nfunction loop(ts) {\n  if (!lastTs) lastTs = ts;\n  const dtMs = ts - lastTs;\n  lastTs = ts;\n\n  if (state.running) {\n    // update parameters from UI in case user changed on-the-fly\n    updateParamsFromUI();\n\n    // perform multiple small steps if dt large to improve stability\n    const maxStep = 20; // ms\n    let remaining = dtMs;\n    while (remaining > 0) {\n      const step = Math.min(remaining, maxStep);\n      physicsStep(step / 1000);\n      remaining -= step;\n      // record history\n      history.push({t: state.t, y: state.y, v: state.v});\n      if (history.length > 1000) history.shift();\n    }\n  }\n\n  // Draw\n  drawScene();\n  drawGraph();\n\n  // Update displays\n  timeDisplay.textContent = state.t.toFixed(2);\n  heightDisplay.textContent = state.y.toFixed(2);\n  velDisplay.textContent = state.v.toFixed(2);\n  bouncesDisplay.textContent = state.bounces;\n\n  requestAnimationFrame(loop);\n}\n\n/* 控件事件 */\nplayBtn.addEventListener('click', ()=>{\n  // if simulation finished (running=false and y==0 and v==0), reset bounces/time? We'll just resume if not moving or start\n  updateParamsFromUI();\n  if (!state.running && state.y <= 0 && state.v === 0 && state.t > 0) {\n    // do nothing special: allow restart from current state (resting)\n  }\n  state.running = true;\n});\n\npauseBtn.addEventListener('click', ()=>{\n  state.running = false;\n});\n\nresetBtn.addEventListener('click', ()=>{\n  updateParamsFromUI();\n  // reset state\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n});\n\n/* 当输入修改时立即应用到参数（不改变当前状态除非重置） */\n[heightRange, heightNum, gRange, gNum, massRange, massNum, dragType, dragRange, dragNum, restitutionRange, restitutionNum, timeScaleRange, timeScaleNum].forEach(el=>{\n  el.addEventListener('input', ()=>{\n    updateParamsFromUI();\n    // if height changed via UI and simulation 未开始，则更新初始高度显示; 若想强制立即移动球，可选择在界面上按重置\n  });\n});\n\n/* 初始化 */\nfunction init() {\n  updateParamsFromUI();\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n\n  // ensure numeric inputs reflect ranges\n  heightNum.value = heightRange.value;\n  gNum.value = gRange.value;\n  massNum.value = massRange.value;\n  dragNum.value = dragRange.value;\n  restitutionNum.value = restitutionRange.value;\n  timeScaleNum.value = timeScaleRange.value;\n\n  requestAnimationFrame(loop);\n}\n\ninit();\n\n/* 可选：当窗口大小改变时也调整画布显示（保持像素宽高），使视觉清晰 */\nwindow.addEventListener('resize', ()=> {\n  // keep canvas CSS size but actual pixel size already set; leaving as-is for simplicity\n});",
                "parameters": [],
                "status": "success"
              },
              "attempts": 2
            },
            "rawData": "{\"success\":true,\"data\":{\"experiment_id\":\"6df24f7f-6163-4256-a2f8-d8458ebc3678\",\"title\":\"重力球下落模拟\",\"description\":\"摘要（简短）\\n- 没有检索到针对“创建一个简单的重力球下落模拟”的特定 Wikipedia 条目结果。\\n- 模拟基于自由落体和重力的基本物理：在近地面处重力加速度 g ≈ 9.81 m/s²，忽略空气阻力时位移 s = 1/2 g t²，速度 v = g t（来源参考: Wikipedia — \\\"自由落体\\\" 与 \\\"重力\\\"）。\\n- 本示例实现一个交互式的重力球下落模拟，支持修改初始高度、重力 g、质量、线性/二次空气阻力、恢复系数（弹性碰撞）与时间缩放；并可实时可视化位置与速度曲线与动画。\\n\\n下面是完整可运行的 HTML 文件代码。将其保存为 .html 文件并在浏览器中打开即可运行。\",\"html_content\":\"<h1>重力球下落模拟</h1>\\n  <p class=\\\"small\\\">说明：模拟基于经典力学。可调参数包括高度、重力、质量、空气阻力类型与系数、恢复系数与时间缩放。可切换播放/暂停/重置并查看高度/速度曲线。</p>\\n\\n  <div class=\\\"container\\\">\\n    <div class=\\\"left\\\">\\n      <canvas id=\\\"scene\\\" width=\\\"720\\\" height=\\\"420\\\" aria-label=\\\"球下落动画与曲线\\\"></canvas>\\n    </div>\\n\\n    <div class=\\\"right\\\">\\n      <div class=\\\"controls\\\" role=\\\"region\\\" aria-label=\\\"模拟控制\\\">\\n        <div class=\\\"row\\\">\\n          <label for=\\\"heightRange\\\">初始高度 (m)</label>\\n          <input id=\\\"heightRange\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"50\\\" step=\\\"0.1\\\" value=\\\"10\\\">\\n          <input id=\\\"heightNum\\\" type=\\\"number\\\" min=\\\"0\\\" max=\\\"1000\\\" step=\\\"0.1\\\" value=\\\"10\\\">\\n        </div>\\n\\n        <div class=\\\"row\\\">\\n          <label for=\\\"gRange\\\">重力 g (m/s²)</label>\\n          <input id=\\\"gRange\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"20\\\" step=\\\"0.01\\\" value=\\\"9.81\\\">\\n          <input id=\\\"gNum\\\" type=\\\"number\\\" min=\\\"0\\\" max=\\\"100\\\" step=\\\"0.01\\\" value=\\\"9.81\\\">\\n        </div>\\n\\n        <div class=\\\"row\\\">\\n          <label for=\\\"massRange\\\">质量 m (kg)</label>\\n          <input id=\\\"massRange\\\" type=\\\"range\\\" min=\\\"0.01\\\" max=\\\"10\\\" step=\\\"0.01\\\" value=\\\"1\\\">\\n          <input id=\\\"massNum\\\" type=\\\"number\\\" min=\\\"0.01\\\" max=\\\"1000\\\" step=\\\"0.01\\\" value=\\\"1\\\">\\n        </div>\\n\\n        <div class=\\\"row\\\">\\n          <label for=\\\"dragType\\\">空气阻力</label>\\n          <select id=\\\"dragType\\\">\\n            <option value=\\\"none\\\">无</option>\\n            <option value=\\\"linear\\\">线性阻力: F = -k v</option>\\n            <option value=\\\"quadratic\\\">二次阻力: F = -k v |v|</option>\\n          </select>\\n        </div>\\n\\n        <div class=\\\"row\\\">\\n          <label for=\\\"dragRange\\\">阻力系数 k</label>\\n          <input id=\\\"dragRange\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"10\\\" step=\\\"0.01\\\" value=\\\"0.1\\\">\\n          <input id=\\\"dragNum\\\" type=\\\"number\\\" min=\\\"0\\\" max=\\\"1000\\\" step=\\\"0.01\\\" value=\\\"0.1\\\">\\n        </div>\\n\\n        <div class=\\\"row\\\">\\n          <label for=\\\"restitutionRange\\\">恢复系数</label>\\n          <input id=\\\"restitutionRange\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"1\\\" step=\\\"0.01\\\" value=\\\"0.6\\\">\\n          <input id=\\\"restitutionNum\\\" type=\\\"number\\\" min=\\\"0\\\" max=\\\"1\\\" step=\\\"0.01\\\" value=\\\"0.6\\\">\\n        </div>\\n\\n        <div class=\\\"row\\\">\\n          <label for=\\\"timeScaleRange\\\">时间缩放</label>\\n          <input id=\\\"timeScaleRange\\\" type=\\\"range\\\" min=\\\"0.1\\\" max=\\\"4\\\" step=\\\"0.1\\\" value=\\\"1\\\">\\n          <input id=\\\"timeScaleNum\\\" type=\\\"number\\\" min=\\\"0.1\\\" max=\\\"10\\\" step=\\\"0.1\\\" value=\\\"1\\\">\\n        </div>\\n\\n        <div style=\\\"margin-top:8px;\\\">\\n          <button id=\\\"playBtn\\\">播放</button>\\n          <button id=\\\"pauseBtn\\\">暂停</button>\\n          <button id=\\\"resetBtn\\\">重置</button>\\n        </div>\\n\\n        <div class=\\\"readouts\\\" aria-live=\\\"polite\\\">\\n          <div class=\\\"panel\\\">\\n            <div>时间 (s)</div>\\n            <div id=\\\"timeDisplay\\\">0.00</div>\\n          </div>\\n          <div class=\\\"panel\\\">\\n            <div>高度 (m)</div>\\n            <div id=\\\"heightDisplay\\\">0.00</div>\\n          </div>\\n          <div class=\\\"panel\\\">\\n            <div>速度 (m/s)</div>\\n            <div id=\\\"velDisplay\\\">0.00</div>\\n          </div>\\n          <div class=\\\"panel\\\">\\n            <div>弹跳次数</div>\\n            <div id=\\\"bouncesDisplay\\\">0</div>\\n          </div>\\n        </div>\\n\\n        <div style=\\\"margin-top:10px;\\\">\\n          <div class=\\\"small\\\">方程（无空气阻力，初速度=0）: s = 1/2 g t²；v = g t</div>\\n        </div>\\n      </div>\\n\\n      <div style=\\\"height:12px;\\\"></div>\\n\\n      <div class=\\\"controls\\\" aria-label=\\\"图表显示\\\">\\n        <div style=\\\"font-weight:600; margin-bottom:6px;\\\">实时曲线</div>\\n        <canvas id=\\\"graph\\\" class=\\\"graph\\\" width=\\\"340\\\" height=\\\"160\\\" aria-label=\\\"高度和速度图\\\"></canvas>\\n        <div style=\\\"margin-top:6px; font-size:0.85rem; color:#555;\\\">\\n          绿色：高度 (m)； 橙色：速度 (m/s)\\n        </div>\\n      </div>\\n    </div>\\n  </div>\\n\\n  <footer>\\n    提示：拖动滑块或直接在数字框中输入数值。切换空气阻力可观察终端速度（有限速度）或理想无限增长的速度。\\n  </footer>\\n\\n<script>\\n/*\\n  重力球下落模拟\\n  - 采用半隐式欧拉（semi-implicit Euler）积分\\n  - 支持线性与二次阻力\\n  - 当小于阈值并接触地面时可停止或弹起（由恢复系数决定）\\n  - 无外部依赖，单文件运行\\n*/\\n\\n/* 获取 DOM 元素 */\\nconst canvas = document.getElementById('scene');\\nconst ctx = canvas.getContext('2d');\\nconst graph = document.getElementById('graph');\\nconst gctx = graph.getContext('2d');\\n\\nconst heightRange = document.getElementById('heightRange');\\nconst heightNum = document.getElementById('heightNum');\\nconst gRange = document.getElementById('gRange');\\nconst gNum = document.getElementById('gNum');\\nconst massRange = document.getElementById('massRange');\\nconst massNum = document.getElementById('massNum');\\nconst dragType = document.getElementById('dragType');\\nconst dragRange = document.getElementById('dragRange');\\nconst dragNum = document.getElementById('dragNum');\\nconst restitutionRange = document.getElementById('restitutionRange');\\nconst restitutionNum = document.getElementById('restitutionNum');\\nconst timeScaleRange = document.getElementById('timeScaleRange');\\nconst timeScaleNum = document.getElementById('timeScaleNum');\\n\\nconst playBtn = document.getElementById('playBtn');\\nconst pauseBtn = document.getElementById('pauseBtn');\\nconst resetBtn = document.getElementById('resetBtn');\\n\\nconst timeDisplay = document.getElementById('timeDisplay');\\nconst heightDisplay = document.getElementById('heightDisplay');\\nconst velDisplay = document.getElementById('velDisplay');\\nconst bouncesDisplay = document.getElementById('bouncesDisplay');\\n\\n/* 参数同步工具 */\\nfunction syncRangeNum(range, num) {\\n  range.addEventListener('input', ()=> num.value = range.value);\\n  num.addEventListener('input', ()=> range.value = num.value);\\n}\\nsyncRangeNum(heightRange, heightNum);\\nsyncRangeNum(gRange, gNum);\\nsyncRangeNum(massRange, massNum);\\nsyncRangeNum(dragRange, dragNum);\\nsyncRangeNum(restitutionRange, restitutionNum);\\nsyncRangeNum(timeScaleRange, timeScaleNum);\\n\\n/* 初始物理状态（以 SI 单位） */\\nlet params = {\\n  height: parseFloat(heightRange.value), // m\\n  g: parseFloat(gRange.value),\\n  mass: parseFloat(massRange.value),\\n  dragType: dragType.value,\\n  k: parseFloat(dragRange.value),\\n  restitution: parseFloat(restitutionRange.value),\\n  timeScale: parseFloat(timeScaleRange.value)\\n};\\n\\nlet state = {\\n  y: params.height,   // 高度（m），地面为 y=0\\n  v: 0,               // 向下为正速度（m/s）\\n  t: 0,               // 模拟时间 s\\n  running: false,\\n  bounces: 0\\n};\\n\\nfunction updateParamsFromUI(){\\n  params.height = parseFloat(heightRange.value);\\n  params.g = parseFloat(gRange.value);\\n  params.mass = parseFloat(massRange.value);\\n  params.dragType = dragType.value;\\n  params.k = parseFloat(dragRange.value);\\n  params.restitution = parseFloat(restitutionRange.value);\\n  params.timeScale = parseFloat(timeScaleRange.value);\\n}\\n\\n/* 图像与坐标设置 */\\nconst W = canvas.width;\\nconst H = canvas.height;\\nconst groundY = H - 40; // 画布上的地面像素位置\\nconst ballRadiusPx = 14;\\n\\n/* 将物理高度（m）映射为画布像素高度（y），需要某个缩放：\\n   我们动态根据初始高度和一定余量设定像素/米比例 */\\nfunction computeScale() {\\n  const topMargin = 20;\\n  const available = groundY - topMargin - ballRadiusPx;\\n  // 期望容纳的高度范围：max(initial height, 10m)\\n  const maxH = Math.max(params.height * 1.2, 10);\\n  return available / maxH;\\n}\\n\\n/* 绘制场景：球与地面 */\\nfunction drawScene() {\\n  ctx.clearRect(0,0,W,H);\\n\\n  // 背景渐变\\n  const grad = ctx.createLinearGradient(0,0,0,H);\\n  grad.addColorStop(0, '#f5fbff');\\n  grad.addColorStop(1, '#ffffff');\\n  ctx.fillStyle = grad;\\n  ctx.fillRect(0,0,W,H);\\n\\n  // 地面\\n  ctx.fillStyle = '#d9e6f2';\\n  ctx.fillRect(0, groundY, W, H-groundY);\\n  ctx.fillStyle = '#c0d2e8';\\n  ctx.fillRect(0, groundY+2, W, 6);\\n\\n  // 绘制高度刻度\\n  ctx.fillStyle = '#333';\\n  ctx.font = '12px sans-serif';\\n  ctx.textAlign = 'left';\\n  ctx.fillText('地面', 8, groundY + 14);\\n\\n  // 计算 scale\\n  const scale = computeScale();\\n  const topMargin = 20;\\n  // 物理高度 y -> pixel Y position\\n  function yToPixel(yMeters) {\\n    // higher meters -> smaller pixel (towards top)\\n    return groundY - (yMeters * scale);\\n  }\\n\\n  // 球位置\\n  const ballX = W/2;\\n  const ballY = yToPixel(state.y);\\n\\n  // 球影子（椭圆）\\n  const shadowScale = 1 - Math.min(state.y / Math.max(params.height, 1), 1) * 0.8;\\n  ctx.fillStyle = 'rgba(0,0,0,0.15)';\\n  ctx.beginPath();\\n  ctx.ellipse(ballX, groundY + 6, ballRadiusPx * 1.2 * shadowScale, ballRadiusPx * 0.5 * shadowScale, 0, 0, Math.PI*2);\\n  ctx.fill();\\n\\n  // 球\\n  const gradient = ctx.createRadialGradient(ballX - 6, ballY - 6, 2, ballX, ballY, ballRadiusPx*1.2);\\n  gradient.addColorStop(0, '#fff7e6');\\n  gradient.addColorStop(0.5, '#ffb74d');\\n  gradient.addColorStop(1, '#ff8f00');\\n  ctx.fillStyle = gradient;\\n  ctx.beginPath();\\n  ctx.arc(ballX, ballY, ballRadiusPx, 0, Math.PI*2);\\n  ctx.fill();\\n  ctx.strokeStyle = '#b56500';\\n  ctx.lineWidth = 2;\\n  ctx.stroke();\\n\\n  // 绘制高度刻度线（每隔一定米）\\n  ctx.strokeStyle = 'rgba(0,0,0,0.06)';\\n  ctx.lineWidth = 1;\\n  ctx.textAlign = 'right';\\n  ctx.fillStyle = '#666';\\n  ctx.font = '11px sans-serif';\\n  const maxMeters = Math.max(params.height * 1.2, 10);\\n  const meterStep = chooseNiceStep(maxMeters);\\n  for(let m = 0; m <= maxMeters + 0.0001; m += meterStep){\\n    const py = yToPixel(m);\\n    ctx.beginPath();\\n    ctx.moveTo(10, py);\\n    ctx.lineTo(W-10, py);\\n    ctx.stroke();\\n    ctx.fillText(m.toFixed(0) + ' m', W - 12, py - 2);\\n  }\\n}\\n\\n/* 选择刻度步长，便于显示 */\\nfunction chooseNiceStep(maxMeters){\\n  // 选择 1,2,5,10,20,...\\n  const candidates = [0.5,1,2,5,10,20,50];\\n  for (let s of candidates){\\n    if (maxMeters / s <= 12) return s;\\n  }\\n  return 100;\\n}\\n\\n/* 图表绘制：清空并绘制曲线（高度与速度） */\\nlet history = []; // {t, y, v}\\nfunction drawGraph(){\\n  const w = graph.width;\\n  const h = graph.height;\\n  gctx.clearRect(0,0,w,h);\\n  gctx.fillStyle = '#fff';\\n  gctx.fillRect(0,0,w,h);\\n\\n  // 背景网格\\n  gctx.strokeStyle = '#f0f0f0';\\n  gctx.lineWidth = 1;\\n  for(let i=0;i<6;i++){\\n    const yy = (i+1)*h/6;\\n    gctx.beginPath(); gctx.moveTo(0,yy); gctx.lineTo(w,yy); gctx.stroke();\\n  }\\n\\n  if (history.length < 2) return;\\n\\n  const t0 = history[0].t;\\n  const t1 = history[history.length-1].t;\\n  const dt = Math.max(0.0001, t1 - t0);\\n\\n  // find y max and v abs max for scaling\\n  let yMax = 0;\\n  let vMax = 0;\\n  history.forEach(pt => {\\n    if (pt.y > yMax) yMax = pt.y;\\n    vMax = Math.max(vMax, Math.abs(pt.v));\\n  });\\n  yMax = Math.max(yMax, params.height, 1);\\n  vMax = Math.max(vMax, 1);\\n\\n  // map functions\\n  function tx(t){ return (t - t0) / dt * (w-20) + 10; }\\n  function tyY(y){ return h - 10 - (y / yMax) * (h - 30); }\\n  function tyV(v){ return h - 10 - ( (v + vMax) / (2*vMax) ) * (h - 30); }\\n\\n  // Draw height (green)\\n  gctx.beginPath();\\n  gctx.strokeStyle = '#2e8b57';\\n  gctx.lineWidth = 2;\\n  history.forEach((pt,i)=>{\\n    const x = tx(pt.t);\\n    const y = tyY(pt.y);\\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\\n  });\\n  gctx.stroke();\\n\\n  // Draw velocity (orange)\\n  gctx.beginPath();\\n  gctx.strokeStyle = '#ff8c00';\\n  gctx.lineWidth = 2;\\n  history.forEach((pt,i)=>{\\n    const x = tx(pt.t);\\n    const y = tyV(pt.v);\\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\\n  });\\n  gctx.stroke();\\n\\n  // Axes labels\\n  gctx.fillStyle = '#333';\\n  gctx.font = '11px sans-serif';\\n  gctx.textAlign = 'left';\\n  gctx.fillText('t (s): ' + t0.toFixed(2) + ' → ' + t1.toFixed(2), 10, 12);\\n  gctx.fillStyle = '#2e8b57';\\n  gctx.fillText('高度 (m)', 10, 26);\\n  gctx.fillStyle = '#ff8c00';\\n  gctx.fillText('速度 (m/s)', 100, 26);\\n}\\n\\n/* 物理更新：半隐式欧拉 */\\nfunction physicsStep(dtReal) {\\n  // dtReal in seconds real time; apply timeScale\\n  const dt = dtReal * params.timeScale;\\n  // compute acceleration downward positive\\n  let a = params.g; // (m/s^2)\\n  if (params.dragType === 'linear') {\\n    // Fdrag = -k v => a = g - (k/m) v (v positive downward)\\n    a = params.g - (params.k / params.mass) * state.v;\\n  } else if (params.dragType === 'quadratic') {\\n    // Fdrag = -k v |v| => a = g - (k/m) v |v|\\n    a = params.g - (params.k / params.mass) * state.v * Math.abs(state.v);\\n  }\\n\\n  // semi-implicit Euler: v += a * dt; y += v * dt;\\n  state.v += a * dt;\\n  state.y -= state.v * dt; // subtract because y measured from ground upward -> but we store y as height above ground\\n  state.t += dt;\\n\\n  // Ground collision\\n  if (state.y <= 0) {\\n    // set to ground\\n    state.y = 0;\\n    // if penetration, reflect velocity\\n    if (Math.abs(state.v) > 1e-6) {\\n      // bounce: reverse and apply restitution\\n      state.v = -state.v * params.restitution;\\n      state.bounces += 1;\\n    } else {\\n      state.v = 0;\\n    }\\n\\n    // Stop bouncing if velocity is very small\\n    if (Math.abs(state.v) < 0.05) {\\n      state.v = 0;\\n      // If timeScale is 0, keep running? We'll pause automatically when ball rests\\n      // We'll choose to pause when ball is at rest on ground.\\n      state.running = false;\\n    }\\n  }\\n}\\n\\n/* Animation loop */\\nlet lastTs = null;\\nfunction loop(ts) {\\n  if (!lastTs) lastTs = ts;\\n  const dtMs = ts - lastTs;\\n  lastTs = ts;\\n\\n  if (state.running) {\\n    // update parameters from UI in case user changed on-the-fly\\n    updateParamsFromUI();\\n\\n    // perform multiple small steps if dt large to improve stability\\n    const maxStep = 20; // ms\\n    let remaining = dtMs;\\n    while (remaining > 0) {\\n      const step = Math.min(remaining, maxStep);\\n      physicsStep(step / 1000);\\n      remaining -= step;\\n      // record history\\n      history.push({t: state.t, y: state.y, v: state.v});\\n      if (history.length > 1000) history.shift();\\n    }\\n  }\\n\\n  // Draw\\n  drawScene();\\n  drawGraph();\\n\\n  // Update displays\\n  timeDisplay.textContent = state.t.toFixed(2);\\n  heightDisplay.textContent = state.y.toFixed(2);\\n  velDisplay.textContent = state.v.toFixed(2);\\n  bouncesDisplay.textContent = state.bounces;\\n\\n  requestAnimationFrame(loop);\\n}\\n\\n/* 控件事件 */\\nplayBtn.addEventListener('click', ()=>{\\n  // if simulation finished (running=false and y==0 and v==0), reset bounces/time? We'll just resume if not moving or start\\n  updateParamsFromUI();\\n  if (!state.running && state.y <= 0 && state.v === 0 && state.t > 0) {\\n    // do nothing special: allow restart from current state (resting)\\n  }\\n  state.running = true;\\n});\\n\\npauseBtn.addEventListener('click', ()=>{\\n  state.running = false;\\n});\\n\\nresetBtn.addEventListener('click', ()=>{\\n  updateParamsFromUI();\\n  // reset state\\n  state.t = 0;\\n  state.y = params.height;\\n  state.v = 0;\\n  state.running = false;\\n  state.bounces = 0;\\n  history = [{t:0, y:state.y, v:0}];\\n});\\n\\n/* 当输入修改时立即应用到参数（不改变当前状态除非重置） */\\n[heightRange, heightNum, gRange, gNum, massRange, massNum, dragType, dragRange, dragNum, restitutionRange, restitutionNum, timeScaleRange, timeScaleNum].forEach(el=>{\\n  el.addEventListener('input', ()=>{\\n    updateParamsFromUI();\\n    // if height changed via UI and simulation 未开始，则更新初始高度显示; 若想强制立即移动球，可选择在界面上按重置\\n  });\\n});\\n\\n/* 初始化 */\\nfunction init() {\\n  updateParamsFromUI();\\n  state.t = 0;\\n  state.y = params.height;\\n  state.v = 0;\\n  state.running = false;\\n  state.bounces = 0;\\n  history = [{t:0, y:state.y, v:0}];\\n\\n  // ensure numeric inputs reflect ranges\\n  heightNum.value = heightRange.value;\\n  gNum.value = gRange.value;\\n  massNum.value = massRange.value;\\n  dragNum.value = dragRange.value;\\n  restitutionNum.value = restitutionRange.value;\\n  timeScaleNum.value = timeScaleRange.value;\\n\\n  requestAnimationFrame(loop);\\n}\\n\\ninit();\\n\\n/* 可选：当窗口大小改变时也调整画布显示（保持像素宽高），使视觉清晰 */\\nwindow.addEventListener('resize', ()=> {\\n  // keep canvas CSS size but actual pixel size already set; leaving as-is for simplicity\\n});\\n</script>\",\"css_content\":\"body { font-family: -apple-system, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial; margin: 16px; color: #222; }\\n    h1 { margin-top: 0; }\\n    .container { display: flex; gap: 16px; flex-wrap: wrap; }\\n    .left { flex: 1 1 520px; min-width: 320px; }\\n    .right { width: 360px; min-width: 300px; }\\n    canvas { background: linear-gradient(#eef,#fff); border: 1px solid #ccc; display: block; width: 100%; height: 420px; }\\n    .controls { background: #fafafa; border: 1px solid #e0e0e0; padding: 12px; border-radius: 6px; }\\n    .row { display:flex; align-items:center; gap:8px; margin:8px 0; }\\n    label { width: 120px; font-size: 0.95rem; color:#333; }\\n    input[type=\\\"range\\\"] { flex:1; }\\n    input[type=\\\"number\\\"] { width:84px; padding:4px; }\\n    select { padding:4px; }\\n    button { padding:8px 12px; margin-right:8px; }\\n    .small { font-size:0.85rem; color:#555; }\\n    .readouts { display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; }\\n    .panel { background:#fff; border:1px solid #eee; padding:8px; border-radius:6px; min-width:110px; text-align:center; }\\n    .graph { height:160px; border:1px solid #ddd; background:#fff; }\\n    footer { margin-top:16px; font-size:0.85rem; color:#666; }\\n    @media (max-width:800px){ .right { width:100%; } }\",\"js_content\":\"/*\\n  重力球下落模拟\\n  - 采用半隐式欧拉（semi-implicit Euler）积分\\n  - 支持线性与二次阻力\\n  - 当小于阈值并接触地面时可停止或弹起（由恢复系数决定）\\n  - 无外部依赖，单文件运行\\n*/\\n\\n/* 获取 DOM 元素 */\\nconst canvas = document.getElementById('scene');\\nconst ctx = canvas.getContext('2d');\\nconst graph = document.getElementById('graph');\\nconst gctx = graph.getContext('2d');\\n\\nconst heightRange = document.getElementById('heightRange');\\nconst heightNum = document.getElementById('heightNum');\\nconst gRange = document.getElementById('gRange');\\nconst gNum = document.getElementById('gNum');\\nconst massRange = document.getElementById('massRange');\\nconst massNum = document.getElementById('massNum');\\nconst dragType = document.getElementById('dragType');\\nconst dragRange = document.getElementById('dragRange');\\nconst dragNum = document.getElementById('dragNum');\\nconst restitutionRange = document.getElementById('restitutionRange');\\nconst restitutionNum = document.getElementById('restitutionNum');\\nconst timeScaleRange = document.getElementById('timeScaleRange');\\nconst timeScaleNum = document.getElementById('timeScaleNum');\\n\\nconst playBtn = document.getElementById('playBtn');\\nconst pauseBtn = document.getElementById('pauseBtn');\\nconst resetBtn = document.getElementById('resetBtn');\\n\\nconst timeDisplay = document.getElementById('timeDisplay');\\nconst heightDisplay = document.getElementById('heightDisplay');\\nconst velDisplay = document.getElementById('velDisplay');\\nconst bouncesDisplay = document.getElementById('bouncesDisplay');\\n\\n/* 参数同步工具 */\\nfunction syncRangeNum(range, num) {\\n  range.addEventListener('input', ()=> num.value = range.value);\\n  num.addEventListener('input', ()=> range.value = num.value);\\n}\\nsyncRangeNum(heightRange, heightNum);\\nsyncRangeNum(gRange, gNum);\\nsyncRangeNum(massRange, massNum);\\nsyncRangeNum(dragRange, dragNum);\\nsyncRangeNum(restitutionRange, restitutionNum);\\nsyncRangeNum(timeScaleRange, timeScaleNum);\\n\\n/* 初始物理状态（以 SI 单位） */\\nlet params = {\\n  height: parseFloat(heightRange.value), // m\\n  g: parseFloat(gRange.value),\\n  mass: parseFloat(massRange.value),\\n  dragType: dragType.value,\\n  k: parseFloat(dragRange.value),\\n  restitution: parseFloat(restitutionRange.value),\\n  timeScale: parseFloat(timeScaleRange.value)\\n};\\n\\nlet state = {\\n  y: params.height,   // 高度（m），地面为 y=0\\n  v: 0,               // 向下为正速度（m/s）\\n  t: 0,               // 模拟时间 s\\n  running: false,\\n  bounces: 0\\n};\\n\\nfunction updateParamsFromUI(){\\n  params.height = parseFloat(heightRange.value);\\n  params.g = parseFloat(gRange.value);\\n  params.mass = parseFloat(massRange.value);\\n  params.dragType = dragType.value;\\n  params.k = parseFloat(dragRange.value);\\n  params.restitution = parseFloat(restitutionRange.value);\\n  params.timeScale = parseFloat(timeScaleRange.value);\\n}\\n\\n/* 图像与坐标设置 */\\nconst W = canvas.width;\\nconst H = canvas.height;\\nconst groundY = H - 40; // 画布上的地面像素位置\\nconst ballRadiusPx = 14;\\n\\n/* 将物理高度（m）映射为画布像素高度（y），需要某个缩放：\\n   我们动态根据初始高度和一定余量设定像素/米比例 */\\nfunction computeScale() {\\n  const topMargin = 20;\\n  const available = groundY - topMargin - ballRadiusPx;\\n  // 期望容纳的高度范围：max(initial height, 10m)\\n  const maxH = Math.max(params.height * 1.2, 10);\\n  return available / maxH;\\n}\\n\\n/* 绘制场景：球与地面 */\\nfunction drawScene() {\\n  ctx.clearRect(0,0,W,H);\\n\\n  // 背景渐变\\n  const grad = ctx.createLinearGradient(0,0,0,H);\\n  grad.addColorStop(0, '#f5fbff');\\n  grad.addColorStop(1, '#ffffff');\\n  ctx.fillStyle = grad;\\n  ctx.fillRect(0,0,W,H);\\n\\n  // 地面\\n  ctx.fillStyle = '#d9e6f2';\\n  ctx.fillRect(0, groundY, W, H-groundY);\\n  ctx.fillStyle = '#c0d2e8';\\n  ctx.fillRect(0, groundY+2, W, 6);\\n\\n  // 绘制高度刻度\\n  ctx.fillStyle = '#333';\\n  ctx.font = '12px sans-serif';\\n  ctx.textAlign = 'left';\\n  ctx.fillText('地面', 8, groundY + 14);\\n\\n  // 计算 scale\\n  const scale = computeScale();\\n  const topMargin = 20;\\n  // 物理高度 y -> pixel Y position\\n  function yToPixel(yMeters) {\\n    // higher meters -> smaller pixel (towards top)\\n    return groundY - (yMeters * scale);\\n  }\\n\\n  // 球位置\\n  const ballX = W/2;\\n  const ballY = yToPixel(state.y);\\n\\n  // 球影子（椭圆）\\n  const shadowScale = 1 - Math.min(state.y / Math.max(params.height, 1), 1) * 0.8;\\n  ctx.fillStyle = 'rgba(0,0,0,0.15)';\\n  ctx.beginPath();\\n  ctx.ellipse(ballX, groundY + 6, ballRadiusPx * 1.2 * shadowScale, ballRadiusPx * 0.5 * shadowScale, 0, 0, Math.PI*2);\\n  ctx.fill();\\n\\n  // 球\\n  const gradient = ctx.createRadialGradient(ballX - 6, ballY - 6, 2, ballX, ballY, ballRadiusPx*1.2);\\n  gradient.addColorStop(0, '#fff7e6');\\n  gradient.addColorStop(0.5, '#ffb74d');\\n  gradient.addColorStop(1, '#ff8f00');\\n  ctx.fillStyle = gradient;\\n  ctx.beginPath();\\n  ctx.arc(ballX, ballY, ballRadiusPx, 0, Math.PI*2);\\n  ctx.fill();\\n  ctx.strokeStyle = '#b56500';\\n  ctx.lineWidth = 2;\\n  ctx.stroke();\\n\\n  // 绘制高度刻度线（每隔一定米）\\n  ctx.strokeStyle = 'rgba(0,0,0,0.06)';\\n  ctx.lineWidth = 1;\\n  ctx.textAlign = 'right';\\n  ctx.fillStyle = '#666';\\n  ctx.font = '11px sans-serif';\\n  const maxMeters = Math.max(params.height * 1.2, 10);\\n  const meterStep = chooseNiceStep(maxMeters);\\n  for(let m = 0; m <= maxMeters + 0.0001; m += meterStep){\\n    const py = yToPixel(m);\\n    ctx.beginPath();\\n    ctx.moveTo(10, py);\\n    ctx.lineTo(W-10, py);\\n    ctx.stroke();\\n    ctx.fillText(m.toFixed(0) + ' m', W - 12, py - 2);\\n  }\\n}\\n\\n/* 选择刻度步长，便于显示 */\\nfunction chooseNiceStep(maxMeters){\\n  // 选择 1,2,5,10,20,...\\n  const candidates = [0.5,1,2,5,10,20,50];\\n  for (let s of candidates){\\n    if (maxMeters / s <= 12) return s;\\n  }\\n  return 100;\\n}\\n\\n/* 图表绘制：清空并绘制曲线（高度与速度） */\\nlet history = []; // {t, y, v}\\nfunction drawGraph(){\\n  const w = graph.width;\\n  const h = graph.height;\\n  gctx.clearRect(0,0,w,h);\\n  gctx.fillStyle = '#fff';\\n  gctx.fillRect(0,0,w,h);\\n\\n  // 背景网格\\n  gctx.strokeStyle = '#f0f0f0';\\n  gctx.lineWidth = 1;\\n  for(let i=0;i<6;i++){\\n    const yy = (i+1)*h/6;\\n    gctx.beginPath(); gctx.moveTo(0,yy); gctx.lineTo(w,yy); gctx.stroke();\\n  }\\n\\n  if (history.length < 2) return;\\n\\n  const t0 = history[0].t;\\n  const t1 = history[history.length-1].t;\\n  const dt = Math.max(0.0001, t1 - t0);\\n\\n  // find y max and v abs max for scaling\\n  let yMax = 0;\\n  let vMax = 0;\\n  history.forEach(pt => {\\n    if (pt.y > yMax) yMax = pt.y;\\n    vMax = Math.max(vMax, Math.abs(pt.v));\\n  });\\n  yMax = Math.max(yMax, params.height, 1);\\n  vMax = Math.max(vMax, 1);\\n\\n  // map functions\\n  function tx(t){ return (t - t0) / dt * (w-20) + 10; }\\n  function tyY(y){ return h - 10 - (y / yMax) * (h - 30); }\\n  function tyV(v){ return h - 10 - ( (v + vMax) / (2*vMax) ) * (h - 30); }\\n\\n  // Draw height (green)\\n  gctx.beginPath();\\n  gctx.strokeStyle = '#2e8b57';\\n  gctx.lineWidth = 2;\\n  history.forEach((pt,i)=>{\\n    const x = tx(pt.t);\\n    const y = tyY(pt.y);\\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\\n  });\\n  gctx.stroke();\\n\\n  // Draw velocity (orange)\\n  gctx.beginPath();\\n  gctx.strokeStyle = '#ff8c00';\\n  gctx.lineWidth = 2;\\n  history.forEach((pt,i)=>{\\n    const x = tx(pt.t);\\n    const y = tyV(pt.v);\\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\\n  });\\n  gctx.stroke();\\n\\n  // Axes labels\\n  gctx.fillStyle = '#333';\\n  gctx.font = '11px sans-serif';\\n  gctx.textAlign = 'left';\\n  gctx.fillText('t (s): ' + t0.toFixed(2) + ' → ' + t1.toFixed(2), 10, 12);\\n  gctx.fillStyle = '#2e8b57';\\n  gctx.fillText('高度 (m)', 10, 26);\\n  gctx.fillStyle = '#ff8c00';\\n  gctx.fillText('速度 (m/s)', 100, 26);\\n}\\n\\n/* 物理更新：半隐式欧拉 */\\nfunction physicsStep(dtReal) {\\n  // dtReal in seconds real time; apply timeScale\\n  const dt = dtReal * params.timeScale;\\n  // compute acceleration downward positive\\n  let a = params.g; // (m/s^2)\\n  if (params.dragType === 'linear') {\\n    // Fdrag = -k v => a = g - (k/m) v (v positive downward)\\n    a = params.g - (params.k / params.mass) * state.v;\\n  } else if (params.dragType === 'quadratic') {\\n    // Fdrag = -k v |v| => a = g - (k/m) v |v|\\n    a = params.g - (params.k / params.mass) * state.v * Math.abs(state.v);\\n  }\\n\\n  // semi-implicit Euler: v += a * dt; y += v * dt;\\n  state.v += a * dt;\\n  state.y -= state.v * dt; // subtract because y measured from ground upward -> but we store y as height above ground\\n  state.t += dt;\\n\\n  // Ground collision\\n  if (state.y <= 0) {\\n    // set to ground\\n    state.y = 0;\\n    // if penetration, reflect velocity\\n    if (Math.abs(state.v) > 1e-6) {\\n      // bounce: reverse and apply restitution\\n      state.v = -state.v * params.restitution;\\n      state.bounces += 1;\\n    } else {\\n      state.v = 0;\\n    }\\n\\n    // Stop bouncing if velocity is very small\\n    if (Math.abs(state.v) < 0.05) {\\n      state.v = 0;\\n      // If timeScale is 0, keep running? We'll pause automatically when ball rests\\n      // We'll choose to pause when ball is at rest on ground.\\n      state.running = false;\\n    }\\n  }\\n}\\n\\n/* Animation loop */\\nlet lastTs = null;\\nfunction loop(ts) {\\n  if (!lastTs) lastTs = ts;\\n  const dtMs = ts - lastTs;\\n  lastTs = ts;\\n\\n  if (state.running) {\\n    // update parameters from UI in case user changed on-the-fly\\n    updateParamsFromUI();\\n\\n    // perform multiple small steps if dt large to improve stability\\n    const maxStep = 20; // ms\\n    let remaining = dtMs;\\n    while (remaining > 0) {\\n      const step = Math.min(remaining, maxStep);\\n      physicsStep(step / 1000);\\n      remaining -= step;\\n      // record history\\n      history.push({t: state.t, y: state.y, v: state.v});\\n      if (history.length > 1000) history.shift();\\n    }\\n  }\\n\\n  // Draw\\n  drawScene();\\n  drawGraph();\\n\\n  // Update displays\\n  timeDisplay.textContent = state.t.toFixed(2);\\n  heightDisplay.textContent = state.y.toFixed(2);\\n  velDisplay.textContent = state.v.toFixed(2);\\n  bouncesDisplay.textContent = state.bounces;\\n\\n  requestAnimationFrame(loop);\\n}\\n\\n/* 控件事件 */\\nplayBtn.addEventListener('click', ()=>{\\n  // if simulation finished (running=false and y==0 and v==0), reset bounces/time? We'll just resume if not moving or start\\n  updateParamsFromUI();\\n  if (!state.running && state.y <= 0 && state.v === 0 && state.t > 0) {\\n    // do nothing special: allow restart from current state (resting)\\n  }\\n  state.running = true;\\n});\\n\\npauseBtn.addEventListener('click', ()=>{\\n  state.running = false;\\n});\\n\\nresetBtn.addEventListener('click', ()=>{\\n  updateParamsFromUI();\\n  // reset state\\n  state.t = 0;\\n  state.y = params.height;\\n  state.v = 0;\\n  state.running = false;\\n  state.bounces = 0;\\n  history = [{t:0, y:state.y, v:0}];\\n});\\n\\n/* 当输入修改时立即应用到参数（不改变当前状态除非重置） */\\n[heightRange, heightNum, gRange, gNum, massRange, massNum, dragType, dragRange, dragNum, restitutionRange, restitutionNum, timeScaleRange, timeScaleNum].forEach(el=>{\\n  el.addEventListener('input', ()=>{\\n    updateParamsFromUI();\\n    // if height changed via UI and simulation 未开始，则更新初始高度显示; 若想强制立即移动球，可选择在界面上按重置\\n  });\\n});\\n\\n/* 初始化 */\\nfunction init() {\\n  updateParamsFromUI();\\n  state.t = 0;\\n  state.y = params.height;\\n  state.v = 0;\\n  state.running = false;\\n  state.bounces = 0;\\n  history = [{t:0, y:state.y, v:0}];\\n\\n  // ensure numeric inputs reflect ranges\\n  heightNum.value = heightRange.value;\\n  gNum.value = gRange.value;\\n  massNum.value = massRange.value;\\n  dragNum.value = dragRange.value;\\n  restitutionNum.value = restitutionRange.value;\\n  timeScaleNum.value = timeScaleRange.value;\\n\\n  requestAnimationFrame(loop);\\n}\\n\\ninit();\\n\\n/* 可选：当窗口大小改变时也调整画布显示（保持像素宽高），使视觉清晰 */\\nwindow.addEventListener('resize', ()=> {\\n  // keep canvas CSS size but actual pixel size already set; leaving as-is for simplicity\\n});\",\"parameters\":[],\"status\":\"success\"},\"attempts\":2}"
          }
        },
        {
          "stage": "data_analysis",
          "timestamp": "2025-08-09T12:15:22.109Z",
          "dataType": "object",
          "keys": [
            "success",
            "data",
            "attempts"
          ],
          "data": {
            "success": true,
            "data": {
              "experiment_id": "6df24f7f-6163-4256-a2f8-d8458ebc3678",
              "title": "重力球下落模拟",
              "description": "摘要（简短）\n- 没有检索到针对“创建一个简单的重力球下落模拟”的特定 Wikipedia 条目结果。\n- 模拟基于自由落体和重力的基本物理：在近地面处重力加速度 g ≈ 9.81 m/s²，忽略空气阻力时位移 s = 1/2 g t²，速度 v = g t（来源参考: Wikipedia — \"自由落体\" 与 \"重力\"）。\n- 本示例实现一个交互式的重力球下落模拟，支持修改初始高度、重力 g、质量、线性/二次空气阻力、恢复系数（弹性碰撞）与时间缩放；并可实时可视化位置与速度曲线与动画。\n\n下面是完整可运行的 HTML 文件代码。将其保存为 .html 文件并在浏览器中打开即可运行。",
              "html_content": "<h1>重力球下落模拟</h1>\n  <p class=\"small\">说明：模拟基于经典力学。可调参数包括高度、重力、质量、空气阻力类型与系数、恢复系数与时间缩放。可切换播放/暂停/重置并查看高度/速度曲线。</p>\n\n  <div class=\"container\">\n    <div class=\"left\">\n      <canvas id=\"scene\" width=\"720\" height=\"420\" aria-label=\"球下落动画与曲线\"></canvas>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"controls\" role=\"region\" aria-label=\"模拟控制\">\n        <div class=\"row\">\n          <label for=\"heightRange\">初始高度 (m)</label>\n          <input id=\"heightRange\" type=\"range\" min=\"0\" max=\"50\" step=\"0.1\" value=\"10\">\n          <input id=\"heightNum\" type=\"number\" min=\"0\" max=\"1000\" step=\"0.1\" value=\"10\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"gRange\">重力 g (m/s²)</label>\n          <input id=\"gRange\" type=\"range\" min=\"0\" max=\"20\" step=\"0.01\" value=\"9.81\">\n          <input id=\"gNum\" type=\"number\" min=\"0\" max=\"100\" step=\"0.01\" value=\"9.81\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"massRange\">质量 m (kg)</label>\n          <input id=\"massRange\" type=\"range\" min=\"0.01\" max=\"10\" step=\"0.01\" value=\"1\">\n          <input id=\"massNum\" type=\"number\" min=\"0.01\" max=\"1000\" step=\"0.01\" value=\"1\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"dragType\">空气阻力</label>\n          <select id=\"dragType\">\n            <option value=\"none\">无</option>\n            <option value=\"linear\">线性阻力: F = -k v</option>\n            <option value=\"quadratic\">二次阻力: F = -k v |v|</option>\n          </select>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"dragRange\">阻力系数 k</label>\n          <input id=\"dragRange\" type=\"range\" min=\"0\" max=\"10\" step=\"0.01\" value=\"0.1\">\n          <input id=\"dragNum\" type=\"number\" min=\"0\" max=\"1000\" step=\"0.01\" value=\"0.1\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"restitutionRange\">恢复系数</label>\n          <input id=\"restitutionRange\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.6\">\n          <input id=\"restitutionNum\" type=\"number\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.6\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"timeScaleRange\">时间缩放</label>\n          <input id=\"timeScaleRange\" type=\"range\" min=\"0.1\" max=\"4\" step=\"0.1\" value=\"1\">\n          <input id=\"timeScaleNum\" type=\"number\" min=\"0.1\" max=\"10\" step=\"0.1\" value=\"1\">\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <button id=\"playBtn\">播放</button>\n          <button id=\"pauseBtn\">暂停</button>\n          <button id=\"resetBtn\">重置</button>\n        </div>\n\n        <div class=\"readouts\" aria-live=\"polite\">\n          <div class=\"panel\">\n            <div>时间 (s)</div>\n            <div id=\"timeDisplay\">0.00</div>\n          </div>\n          <div class=\"panel\">\n            <div>高度 (m)</div>\n            <div id=\"heightDisplay\">0.00</div>\n          </div>\n          <div class=\"panel\">\n            <div>速度 (m/s)</div>\n            <div id=\"velDisplay\">0.00</div>\n          </div>\n          <div class=\"panel\">\n            <div>弹跳次数</div>\n            <div id=\"bouncesDisplay\">0</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <div class=\"small\">方程（无空气阻力，初速度=0）: s = 1/2 g t²；v = g t</div>\n        </div>\n      </div>\n\n      <div style=\"height:12px;\"></div>\n\n      <div class=\"controls\" aria-label=\"图表显示\">\n        <div style=\"font-weight:600; margin-bottom:6px;\">实时曲线</div>\n        <canvas id=\"graph\" class=\"graph\" width=\"340\" height=\"160\" aria-label=\"高度和速度图\"></canvas>\n        <div style=\"margin-top:6px; font-size:0.85rem; color:#555;\">\n          绿色：高度 (m)； 橙色：速度 (m/s)\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <footer>\n    提示：拖动滑块或直接在数字框中输入数值。切换空气阻力可观察终端速度（有限速度）或理想无限增长的速度。\n  </footer>\n\n<script>\n/*\n  重力球下落模拟\n  - 采用半隐式欧拉（semi-implicit Euler）积分\n  - 支持线性与二次阻力\n  - 当小于阈值并接触地面时可停止或弹起（由恢复系数决定）\n  - 无外部依赖，单文件运行\n*/\n\n/* 获取 DOM 元素 */\nconst canvas = document.getElementById('scene');\nconst ctx = canvas.getContext('2d');\nconst graph = document.getElementById('graph');\nconst gctx = graph.getContext('2d');\n\nconst heightRange = document.getElementById('heightRange');\nconst heightNum = document.getElementById('heightNum');\nconst gRange = document.getElementById('gRange');\nconst gNum = document.getElementById('gNum');\nconst massRange = document.getElementById('massRange');\nconst massNum = document.getElementById('massNum');\nconst dragType = document.getElementById('dragType');\nconst dragRange = document.getElementById('dragRange');\nconst dragNum = document.getElementById('dragNum');\nconst restitutionRange = document.getElementById('restitutionRange');\nconst restitutionNum = document.getElementById('restitutionNum');\nconst timeScaleRange = document.getElementById('timeScaleRange');\nconst timeScaleNum = document.getElementById('timeScaleNum');\n\nconst playBtn = document.getElementById('playBtn');\nconst pauseBtn = document.getElementById('pauseBtn');\nconst resetBtn = document.getElementById('resetBtn');\n\nconst timeDisplay = document.getElementById('timeDisplay');\nconst heightDisplay = document.getElementById('heightDisplay');\nconst velDisplay = document.getElementById('velDisplay');\nconst bouncesDisplay = document.getElementById('bouncesDisplay');\n\n/* 参数同步工具 */\nfunction syncRangeNum(range, num) {\n  range.addEventListener('input', ()=> num.value = range.value);\n  num.addEventListener('input', ()=> range.value = num.value);\n}\nsyncRangeNum(heightRange, heightNum);\nsyncRangeNum(gRange, gNum);\nsyncRangeNum(massRange, massNum);\nsyncRangeNum(dragRange, dragNum);\nsyncRangeNum(restitutionRange, restitutionNum);\nsyncRangeNum(timeScaleRange, timeScaleNum);\n\n/* 初始物理状态（以 SI 单位） */\nlet params = {\n  height: parseFloat(heightRange.value), // m\n  g: parseFloat(gRange.value),\n  mass: parseFloat(massRange.value),\n  dragType: dragType.value,\n  k: parseFloat(dragRange.value),\n  restitution: parseFloat(restitutionRange.value),\n  timeScale: parseFloat(timeScaleRange.value)\n};\n\nlet state = {\n  y: params.height,   // 高度（m），地面为 y=0\n  v: 0,               // 向下为正速度（m/s）\n  t: 0,               // 模拟时间 s\n  running: false,\n  bounces: 0\n};\n\nfunction updateParamsFromUI(){\n  params.height = parseFloat(heightRange.value);\n  params.g = parseFloat(gRange.value);\n  params.mass = parseFloat(massRange.value);\n  params.dragType = dragType.value;\n  params.k = parseFloat(dragRange.value);\n  params.restitution = parseFloat(restitutionRange.value);\n  params.timeScale = parseFloat(timeScaleRange.value);\n}\n\n/* 图像与坐标设置 */\nconst W = canvas.width;\nconst H = canvas.height;\nconst groundY = H - 40; // 画布上的地面像素位置\nconst ballRadiusPx = 14;\n\n/* 将物理高度（m）映射为画布像素高度（y），需要某个缩放：\n   我们动态根据初始高度和一定余量设定像素/米比例 */\nfunction computeScale() {\n  const topMargin = 20;\n  const available = groundY - topMargin - ballRadiusPx;\n  // 期望容纳的高度范围：max(initial height, 10m)\n  const maxH = Math.max(params.height * 1.2, 10);\n  return available / maxH;\n}\n\n/* 绘制场景：球与地面 */\nfunction drawScene() {\n  ctx.clearRect(0,0,W,H);\n\n  // 背景渐变\n  const grad = ctx.createLinearGradient(0,0,0,H);\n  grad.addColorStop(0, '#f5fbff');\n  grad.addColorStop(1, '#ffffff');\n  ctx.fillStyle = grad;\n  ctx.fillRect(0,0,W,H);\n\n  // 地面\n  ctx.fillStyle = '#d9e6f2';\n  ctx.fillRect(0, groundY, W, H-groundY);\n  ctx.fillStyle = '#c0d2e8';\n  ctx.fillRect(0, groundY+2, W, 6);\n\n  // 绘制高度刻度\n  ctx.fillStyle = '#333';\n  ctx.font = '12px sans-serif';\n  ctx.textAlign = 'left';\n  ctx.fillText('地面', 8, groundY + 14);\n\n  // 计算 scale\n  const scale = computeScale();\n  const topMargin = 20;\n  // 物理高度 y -> pixel Y position\n  function yToPixel(yMeters) {\n    // higher meters -> smaller pixel (towards top)\n    return groundY - (yMeters * scale);\n  }\n\n  // 球位置\n  const ballX = W/2;\n  const ballY = yToPixel(state.y);\n\n  // 球影子（椭圆）\n  const shadowScale = 1 - Math.min(state.y / Math.max(params.height, 1), 1) * 0.8;\n  ctx.fillStyle = 'rgba(0,0,0,0.15)';\n  ctx.beginPath();\n  ctx.ellipse(ballX, groundY + 6, ballRadiusPx * 1.2 * shadowScale, ballRadiusPx * 0.5 * shadowScale, 0, 0, Math.PI*2);\n  ctx.fill();\n\n  // 球\n  const gradient = ctx.createRadialGradient(ballX - 6, ballY - 6, 2, ballX, ballY, ballRadiusPx*1.2);\n  gradient.addColorStop(0, '#fff7e6');\n  gradient.addColorStop(0.5, '#ffb74d');\n  gradient.addColorStop(1, '#ff8f00');\n  ctx.fillStyle = gradient;\n  ctx.beginPath();\n  ctx.arc(ballX, ballY, ballRadiusPx, 0, Math.PI*2);\n  ctx.fill();\n  ctx.strokeStyle = '#b56500';\n  ctx.lineWidth = 2;\n  ctx.stroke();\n\n  // 绘制高度刻度线（每隔一定米）\n  ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n  ctx.lineWidth = 1;\n  ctx.textAlign = 'right';\n  ctx.fillStyle = '#666';\n  ctx.font = '11px sans-serif';\n  const maxMeters = Math.max(params.height * 1.2, 10);\n  const meterStep = chooseNiceStep(maxMeters);\n  for(let m = 0; m <= maxMeters + 0.0001; m += meterStep){\n    const py = yToPixel(m);\n    ctx.beginPath();\n    ctx.moveTo(10, py);\n    ctx.lineTo(W-10, py);\n    ctx.stroke();\n    ctx.fillText(m.toFixed(0) + ' m', W - 12, py - 2);\n  }\n}\n\n/* 选择刻度步长，便于显示 */\nfunction chooseNiceStep(maxMeters){\n  // 选择 1,2,5,10,20,...\n  const candidates = [0.5,1,2,5,10,20,50];\n  for (let s of candidates){\n    if (maxMeters / s <= 12) return s;\n  }\n  return 100;\n}\n\n/* 图表绘制：清空并绘制曲线（高度与速度） */\nlet history = []; // {t, y, v}\nfunction drawGraph(){\n  const w = graph.width;\n  const h = graph.height;\n  gctx.clearRect(0,0,w,h);\n  gctx.fillStyle = '#fff';\n  gctx.fillRect(0,0,w,h);\n\n  // 背景网格\n  gctx.strokeStyle = '#f0f0f0';\n  gctx.lineWidth = 1;\n  for(let i=0;i<6;i++){\n    const yy = (i+1)*h/6;\n    gctx.beginPath(); gctx.moveTo(0,yy); gctx.lineTo(w,yy); gctx.stroke();\n  }\n\n  if (history.length < 2) return;\n\n  const t0 = history[0].t;\n  const t1 = history[history.length-1].t;\n  const dt = Math.max(0.0001, t1 - t0);\n\n  // find y max and v abs max for scaling\n  let yMax = 0;\n  let vMax = 0;\n  history.forEach(pt => {\n    if (pt.y > yMax) yMax = pt.y;\n    vMax = Math.max(vMax, Math.abs(pt.v));\n  });\n  yMax = Math.max(yMax, params.height, 1);\n  vMax = Math.max(vMax, 1);\n\n  // map functions\n  function tx(t){ return (t - t0) / dt * (w-20) + 10; }\n  function tyY(y){ return h - 10 - (y / yMax) * (h - 30); }\n  function tyV(v){ return h - 10 - ( (v + vMax) / (2*vMax) ) * (h - 30); }\n\n  // Draw height (green)\n  gctx.beginPath();\n  gctx.strokeStyle = '#2e8b57';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyY(pt.y);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Draw velocity (orange)\n  gctx.beginPath();\n  gctx.strokeStyle = '#ff8c00';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyV(pt.v);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Axes labels\n  gctx.fillStyle = '#333';\n  gctx.font = '11px sans-serif';\n  gctx.textAlign = 'left';\n  gctx.fillText('t (s): ' + t0.toFixed(2) + ' → ' + t1.toFixed(2), 10, 12);\n  gctx.fillStyle = '#2e8b57';\n  gctx.fillText('高度 (m)', 10, 26);\n  gctx.fillStyle = '#ff8c00';\n  gctx.fillText('速度 (m/s)', 100, 26);\n}\n\n/* 物理更新：半隐式欧拉 */\nfunction physicsStep(dtReal) {\n  // dtReal in seconds real time; apply timeScale\n  const dt = dtReal * params.timeScale;\n  // compute acceleration downward positive\n  let a = params.g; // (m/s^2)\n  if (params.dragType === 'linear') {\n    // Fdrag = -k v => a = g - (k/m) v (v positive downward)\n    a = params.g - (params.k / params.mass) * state.v;\n  } else if (params.dragType === 'quadratic') {\n    // Fdrag = -k v |v| => a = g - (k/m) v |v|\n    a = params.g - (params.k / params.mass) * state.v * Math.abs(state.v);\n  }\n\n  // semi-implicit Euler: v += a * dt; y += v * dt;\n  state.v += a * dt;\n  state.y -= state.v * dt; // subtract because y measured from ground upward -> but we store y as height above ground\n  state.t += dt;\n\n  // Ground collision\n  if (state.y <= 0) {\n    // set to ground\n    state.y = 0;\n    // if penetration, reflect velocity\n    if (Math.abs(state.v) > 1e-6) {\n      // bounce: reverse and apply restitution\n      state.v = -state.v * params.restitution;\n      state.bounces += 1;\n    } else {\n      state.v = 0;\n    }\n\n    // Stop bouncing if velocity is very small\n    if (Math.abs(state.v) < 0.05) {\n      state.v = 0;\n      // If timeScale is 0, keep running? We'll pause automatically when ball rests\n      // We'll choose to pause when ball is at rest on ground.\n      state.running = false;\n    }\n  }\n}\n\n/* Animation loop */\nlet lastTs = null;\nfunction loop(ts) {\n  if (!lastTs) lastTs = ts;\n  const dtMs = ts - lastTs;\n  lastTs = ts;\n\n  if (state.running) {\n    // update parameters from UI in case user changed on-the-fly\n    updateParamsFromUI();\n\n    // perform multiple small steps if dt large to improve stability\n    const maxStep = 20; // ms\n    let remaining = dtMs;\n    while (remaining > 0) {\n      const step = Math.min(remaining, maxStep);\n      physicsStep(step / 1000);\n      remaining -= step;\n      // record history\n      history.push({t: state.t, y: state.y, v: state.v});\n      if (history.length > 1000) history.shift();\n    }\n  }\n\n  // Draw\n  drawScene();\n  drawGraph();\n\n  // Update displays\n  timeDisplay.textContent = state.t.toFixed(2);\n  heightDisplay.textContent = state.y.toFixed(2);\n  velDisplay.textContent = state.v.toFixed(2);\n  bouncesDisplay.textContent = state.bounces;\n\n  requestAnimationFrame(loop);\n}\n\n/* 控件事件 */\nplayBtn.addEventListener('click', ()=>{\n  // if simulation finished (running=false and y==0 and v==0), reset bounces/time? We'll just resume if not moving or start\n  updateParamsFromUI();\n  if (!state.running && state.y <= 0 && state.v === 0 && state.t > 0) {\n    // do nothing special: allow restart from current state (resting)\n  }\n  state.running = true;\n});\n\npauseBtn.addEventListener('click', ()=>{\n  state.running = false;\n});\n\nresetBtn.addEventListener('click', ()=>{\n  updateParamsFromUI();\n  // reset state\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n});\n\n/* 当输入修改时立即应用到参数（不改变当前状态除非重置） */\n[heightRange, heightNum, gRange, gNum, massRange, massNum, dragType, dragRange, dragNum, restitutionRange, restitutionNum, timeScaleRange, timeScaleNum].forEach(el=>{\n  el.addEventListener('input', ()=>{\n    updateParamsFromUI();\n    // if height changed via UI and simulation 未开始，则更新初始高度显示; 若想强制立即移动球，可选择在界面上按重置\n  });\n});\n\n/* 初始化 */\nfunction init() {\n  updateParamsFromUI();\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n\n  // ensure numeric inputs reflect ranges\n  heightNum.value = heightRange.value;\n  gNum.value = gRange.value;\n  massNum.value = massRange.value;\n  dragNum.value = dragRange.value;\n  restitutionNum.value = restitutionRange.value;\n  timeScaleNum.value = timeScaleRange.value;\n\n  requestAnimationFrame(loop);\n}\n\ninit();\n\n/* 可选：当窗口大小改变时也调整画布显示（保持像素宽高），使视觉清晰 */\nwindow.addEventListener('resize', ()=> {\n  // keep canvas CSS size but actual pixel size already set; leaving as-is for simplicity\n});\n</script>",
              "css_content": "body { font-family: -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 16px; color: #222; }\n    h1 { margin-top: 0; }\n    .container { display: flex; gap: 16px; flex-wrap: wrap; }\n    .left { flex: 1 1 520px; min-width: 320px; }\n    .right { width: 360px; min-width: 300px; }\n    canvas { background: linear-gradient(#eef,#fff); border: 1px solid #ccc; display: block; width: 100%; height: 420px; }\n    .controls { background: #fafafa; border: 1px solid #e0e0e0; padding: 12px; border-radius: 6px; }\n    .row { display:flex; align-items:center; gap:8px; margin:8px 0; }\n    label { width: 120px; font-size: 0.95rem; color:#333; }\n    input[type=\"range\"] { flex:1; }\n    input[type=\"number\"] { width:84px; padding:4px; }\n    select { padding:4px; }\n    button { padding:8px 12px; margin-right:8px; }\n    .small { font-size:0.85rem; color:#555; }\n    .readouts { display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; }\n    .panel { background:#fff; border:1px solid #eee; padding:8px; border-radius:6px; min-width:110px; text-align:center; }\n    .graph { height:160px; border:1px solid #ddd; background:#fff; }\n    footer { margin-top:16px; font-size:0.85rem; color:#666; }\n    @media (max-width:800px){ .right { width:100%; } }",
              "js_content": "/*\n  重力球下落模拟\n  - 采用半隐式欧拉（semi-implicit Euler）积分\n  - 支持线性与二次阻力\n  - 当小于阈值并接触地面时可停止或弹起（由恢复系数决定）\n  - 无外部依赖，单文件运行\n*/\n\n/* 获取 DOM 元素 */\nconst canvas = document.getElementById('scene');\nconst ctx = canvas.getContext('2d');\nconst graph = document.getElementById('graph');\nconst gctx = graph.getContext('2d');\n\nconst heightRange = document.getElementById('heightRange');\nconst heightNum = document.getElementById('heightNum');\nconst gRange = document.getElementById('gRange');\nconst gNum = document.getElementById('gNum');\nconst massRange = document.getElementById('massRange');\nconst massNum = document.getElementById('massNum');\nconst dragType = document.getElementById('dragType');\nconst dragRange = document.getElementById('dragRange');\nconst dragNum = document.getElementById('dragNum');\nconst restitutionRange = document.getElementById('restitutionRange');\nconst restitutionNum = document.getElementById('restitutionNum');\nconst timeScaleRange = document.getElementById('timeScaleRange');\nconst timeScaleNum = document.getElementById('timeScaleNum');\n\nconst playBtn = document.getElementById('playBtn');\nconst pauseBtn = document.getElementById('pauseBtn');\nconst resetBtn = document.getElementById('resetBtn');\n\nconst timeDisplay = document.getElementById('timeDisplay');\nconst heightDisplay = document.getElementById('heightDisplay');\nconst velDisplay = document.getElementById('velDisplay');\nconst bouncesDisplay = document.getElementById('bouncesDisplay');\n\n/* 参数同步工具 */\nfunction syncRangeNum(range, num) {\n  range.addEventListener('input', ()=> num.value = range.value);\n  num.addEventListener('input', ()=> range.value = num.value);\n}\nsyncRangeNum(heightRange, heightNum);\nsyncRangeNum(gRange, gNum);\nsyncRangeNum(massRange, massNum);\nsyncRangeNum(dragRange, dragNum);\nsyncRangeNum(restitutionRange, restitutionNum);\nsyncRangeNum(timeScaleRange, timeScaleNum);\n\n/* 初始物理状态（以 SI 单位） */\nlet params = {\n  height: parseFloat(heightRange.value), // m\n  g: parseFloat(gRange.value),\n  mass: parseFloat(massRange.value),\n  dragType: dragType.value,\n  k: parseFloat(dragRange.value),\n  restitution: parseFloat(restitutionRange.value),\n  timeScale: parseFloat(timeScaleRange.value)\n};\n\nlet state = {\n  y: params.height,   // 高度（m），地面为 y=0\n  v: 0,               // 向下为正速度（m/s）\n  t: 0,               // 模拟时间 s\n  running: false,\n  bounces: 0\n};\n\nfunction updateParamsFromUI(){\n  params.height = parseFloat(heightRange.value);\n  params.g = parseFloat(gRange.value);\n  params.mass = parseFloat(massRange.value);\n  params.dragType = dragType.value;\n  params.k = parseFloat(dragRange.value);\n  params.restitution = parseFloat(restitutionRange.value);\n  params.timeScale = parseFloat(timeScaleRange.value);\n}\n\n/* 图像与坐标设置 */\nconst W = canvas.width;\nconst H = canvas.height;\nconst groundY = H - 40; // 画布上的地面像素位置\nconst ballRadiusPx = 14;\n\n/* 将物理高度（m）映射为画布像素高度（y），需要某个缩放：\n   我们动态根据初始高度和一定余量设定像素/米比例 */\nfunction computeScale() {\n  const topMargin = 20;\n  const available = groundY - topMargin - ballRadiusPx;\n  // 期望容纳的高度范围：max(initial height, 10m)\n  const maxH = Math.max(params.height * 1.2, 10);\n  return available / maxH;\n}\n\n/* 绘制场景：球与地面 */\nfunction drawScene() {\n  ctx.clearRect(0,0,W,H);\n\n  // 背景渐变\n  const grad = ctx.createLinearGradient(0,0,0,H);\n  grad.addColorStop(0, '#f5fbff');\n  grad.addColorStop(1, '#ffffff');\n  ctx.fillStyle = grad;\n  ctx.fillRect(0,0,W,H);\n\n  // 地面\n  ctx.fillStyle = '#d9e6f2';\n  ctx.fillRect(0, groundY, W, H-groundY);\n  ctx.fillStyle = '#c0d2e8';\n  ctx.fillRect(0, groundY+2, W, 6);\n\n  // 绘制高度刻度\n  ctx.fillStyle = '#333';\n  ctx.font = '12px sans-serif';\n  ctx.textAlign = 'left';\n  ctx.fillText('地面', 8, groundY + 14);\n\n  // 计算 scale\n  const scale = computeScale();\n  const topMargin = 20;\n  // 物理高度 y -> pixel Y position\n  function yToPixel(yMeters) {\n    // higher meters -> smaller pixel (towards top)\n    return groundY - (yMeters * scale);\n  }\n\n  // 球位置\n  const ballX = W/2;\n  const ballY = yToPixel(state.y);\n\n  // 球影子（椭圆）\n  const shadowScale = 1 - Math.min(state.y / Math.max(params.height, 1), 1) * 0.8;\n  ctx.fillStyle = 'rgba(0,0,0,0.15)';\n  ctx.beginPath();\n  ctx.ellipse(ballX, groundY + 6, ballRadiusPx * 1.2 * shadowScale, ballRadiusPx * 0.5 * shadowScale, 0, 0, Math.PI*2);\n  ctx.fill();\n\n  // 球\n  const gradient = ctx.createRadialGradient(ballX - 6, ballY - 6, 2, ballX, ballY, ballRadiusPx*1.2);\n  gradient.addColorStop(0, '#fff7e6');\n  gradient.addColorStop(0.5, '#ffb74d');\n  gradient.addColorStop(1, '#ff8f00');\n  ctx.fillStyle = gradient;\n  ctx.beginPath();\n  ctx.arc(ballX, ballY, ballRadiusPx, 0, Math.PI*2);\n  ctx.fill();\n  ctx.strokeStyle = '#b56500';\n  ctx.lineWidth = 2;\n  ctx.stroke();\n\n  // 绘制高度刻度线（每隔一定米）\n  ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n  ctx.lineWidth = 1;\n  ctx.textAlign = 'right';\n  ctx.fillStyle = '#666';\n  ctx.font = '11px sans-serif';\n  const maxMeters = Math.max(params.height * 1.2, 10);\n  const meterStep = chooseNiceStep(maxMeters);\n  for(let m = 0; m <= maxMeters + 0.0001; m += meterStep){\n    const py = yToPixel(m);\n    ctx.beginPath();\n    ctx.moveTo(10, py);\n    ctx.lineTo(W-10, py);\n    ctx.stroke();\n    ctx.fillText(m.toFixed(0) + ' m', W - 12, py - 2);\n  }\n}\n\n/* 选择刻度步长，便于显示 */\nfunction chooseNiceStep(maxMeters){\n  // 选择 1,2,5,10,20,...\n  const candidates = [0.5,1,2,5,10,20,50];\n  for (let s of candidates){\n    if (maxMeters / s <= 12) return s;\n  }\n  return 100;\n}\n\n/* 图表绘制：清空并绘制曲线（高度与速度） */\nlet history = []; // {t, y, v}\nfunction drawGraph(){\n  const w = graph.width;\n  const h = graph.height;\n  gctx.clearRect(0,0,w,h);\n  gctx.fillStyle = '#fff';\n  gctx.fillRect(0,0,w,h);\n\n  // 背景网格\n  gctx.strokeStyle = '#f0f0f0';\n  gctx.lineWidth = 1;\n  for(let i=0;i<6;i++){\n    const yy = (i+1)*h/6;\n    gctx.beginPath(); gctx.moveTo(0,yy); gctx.lineTo(w,yy); gctx.stroke();\n  }\n\n  if (history.length < 2) return;\n\n  const t0 = history[0].t;\n  const t1 = history[history.length-1].t;\n  const dt = Math.max(0.0001, t1 - t0);\n\n  // find y max and v abs max for scaling\n  let yMax = 0;\n  let vMax = 0;\n  history.forEach(pt => {\n    if (pt.y > yMax) yMax = pt.y;\n    vMax = Math.max(vMax, Math.abs(pt.v));\n  });\n  yMax = Math.max(yMax, params.height, 1);\n  vMax = Math.max(vMax, 1);\n\n  // map functions\n  function tx(t){ return (t - t0) / dt * (w-20) + 10; }\n  function tyY(y){ return h - 10 - (y / yMax) * (h - 30); }\n  function tyV(v){ return h - 10 - ( (v + vMax) / (2*vMax) ) * (h - 30); }\n\n  // Draw height (green)\n  gctx.beginPath();\n  gctx.strokeStyle = '#2e8b57';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyY(pt.y);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Draw velocity (orange)\n  gctx.beginPath();\n  gctx.strokeStyle = '#ff8c00';\n  gctx.lineWidth = 2;\n  history.forEach((pt,i)=>{\n    const x = tx(pt.t);\n    const y = tyV(pt.v);\n    i===0 ? gctx.moveTo(x,y) : gctx.lineTo(x,y);\n  });\n  gctx.stroke();\n\n  // Axes labels\n  gctx.fillStyle = '#333';\n  gctx.font = '11px sans-serif';\n  gctx.textAlign = 'left';\n  gctx.fillText('t (s): ' + t0.toFixed(2) + ' → ' + t1.toFixed(2), 10, 12);\n  gctx.fillStyle = '#2e8b57';\n  gctx.fillText('高度 (m)', 10, 26);\n  gctx.fillStyle = '#ff8c00';\n  gctx.fillText('速度 (m/s)', 100, 26);\n}\n\n/* 物理更新：半隐式欧拉 */\nfunction physicsStep(dtReal) {\n  // dtReal in seconds real time; apply timeScale\n  const dt = dtReal * params.timeScale;\n  // compute acceleration downward positive\n  let a = params.g; // (m/s^2)\n  if (params.dragType === 'linear') {\n    // Fdrag = -k v => a = g - (k/m) v (v positive downward)\n    a = params.g - (params.k / params.mass) * state.v;\n  } else if (params.dragType === 'quadratic') {\n    // Fdrag = -k v |v| => a = g - (k/m) v |v|\n    a = params.g - (params.k / params.mass) * state.v * Math.abs(state.v);\n  }\n\n  // semi-implicit Euler: v += a * dt; y += v * dt;\n  state.v += a * dt;\n  state.y -= state.v * dt; // subtract because y measured from ground upward -> but we store y as height above ground\n  state.t += dt;\n\n  // Ground collision\n  if (state.y <= 0) {\n    // set to ground\n    state.y = 0;\n    // if penetration, reflect velocity\n    if (Math.abs(state.v) > 1e-6) {\n      // bounce: reverse and apply restitution\n      state.v = -state.v * params.restitution;\n      state.bounces += 1;\n    } else {\n      state.v = 0;\n    }\n\n    // Stop bouncing if velocity is very small\n    if (Math.abs(state.v) < 0.05) {\n      state.v = 0;\n      // If timeScale is 0, keep running? We'll pause automatically when ball rests\n      // We'll choose to pause when ball is at rest on ground.\n      state.running = false;\n    }\n  }\n}\n\n/* Animation loop */\nlet lastTs = null;\nfunction loop(ts) {\n  if (!lastTs) lastTs = ts;\n  const dtMs = ts - lastTs;\n  lastTs = ts;\n\n  if (state.running) {\n    // update parameters from UI in case user changed on-the-fly\n    updateParamsFromUI();\n\n    // perform multiple small steps if dt large to improve stability\n    const maxStep = 20; // ms\n    let remaining = dtMs;\n    while (remaining > 0) {\n      const step = Math.min(remaining, maxStep);\n      physicsStep(step / 1000);\n      remaining -= step;\n      // record history\n      history.push({t: state.t, y: state.y, v: state.v});\n      if (history.length > 1000) history.shift();\n    }\n  }\n\n  // Draw\n  drawScene();\n  drawGraph();\n\n  // Update displays\n  timeDisplay.textContent = state.t.toFixed(2);\n  heightDisplay.textContent = state.y.toFixed(2);\n  velDisplay.textContent = state.v.toFixed(2);\n  bouncesDisplay.textContent = state.bounces;\n\n  requestAnimationFrame(loop);\n}\n\n/* 控件事件 */\nplayBtn.addEventListener('click', ()=>{\n  // if simulation finished (running=false and y==0 and v==0), reset bounces/time? We'll just resume if not moving or start\n  updateParamsFromUI();\n  if (!state.running && state.y <= 0 && state.v === 0 && state.t > 0) {\n    // do nothing special: allow restart from current state (resting)\n  }\n  state.running = true;\n});\n\npauseBtn.addEventListener('click', ()=>{\n  state.running = false;\n});\n\nresetBtn.addEventListener('click', ()=>{\n  updateParamsFromUI();\n  // reset state\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n});\n\n/* 当输入修改时立即应用到参数（不改变当前状态除非重置） */\n[heightRange, heightNum, gRange, gNum, massRange, massNum, dragType, dragRange, dragNum, restitutionRange, restitutionNum, timeScaleRange, timeScaleNum].forEach(el=>{\n  el.addEventListener('input', ()=>{\n    updateParamsFromUI();\n    // if height changed via UI and simulation 未开始，则更新初始高度显示; 若想强制立即移动球，可选择在界面上按重置\n  });\n});\n\n/* 初始化 */\nfunction init() {\n  updateParamsFromUI();\n  state.t = 0;\n  state.y = params.height;\n  state.v = 0;\n  state.running = false;\n  state.bounces = 0;\n  history = [{t:0, y:state.y, v:0}];\n\n  // ensure numeric inputs reflect ranges\n  heightNum.value = heightRange.value;\n  gNum.value = gRange.value;\n  massNum.value = massRange.value;\n  dragNum.value = dragRange.value;\n  restitutionNum.value = restitutionRange.value;\n  timeScaleNum.value = timeScaleRange.value;\n\n  requestAnimationFrame(loop);\n}\n\ninit();\n\n/* 可选：当窗口大小改变时也调整画布显示（保持像素宽高），使视觉清晰 */\nwindow.addEventListener('resize', ()=> {\n  // keep canvas CSS size but actual pixel size already set; leaving as-is for simplicity\n});",
              "parameters": [],
              "status": "success"
            },
            "attempts": 2
          }
        },
        {
          "stage": "quality_check",
          "timestamp": "2025-08-09T12:15:22.109Z",
          "checks": {
            "hasCode": false,
            "codeLength": 0,
            "htmlTagsFound": [],
            "syntaxErrors": [],
            "bracketMatching": true,
            "syntaxValid": true
          }
        }
      ],
      "finalResult": {
        "codeGenerated": false,
        "codeLength": 0,
        "hasQualityIssues": false,
        "issues": {
          "htmlTags": 0,
          "bracketErrors": false,
          "syntaxErrors": false
        }
      },
      "success": true,
      "errors": [],
      "endTime": "2025-08-09T12:15:22.109Z",
      "duration": 186642
    },
    {
      "name": "复杂交互系统",
      "prompt": "创建一个包含多个交互元素的复杂系统，包括按钮、滑块和动画效果",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T12:15:27.111Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T12:17:15.542Z",
          "response": {
            "status": 200,
            "statusText": "OK",
            "headers": {
              "access-control-allow-origin": "*",
              "connection": "keep-alive",
              "content-length": "41198",
              "content-type": "application/json; charset=utf-8",
              "date": "Sat, 09 Aug 2025 12:17:15 GMT",
              "etag": "W/\"a0ee-xHq59pktjgRnE9D6tdh6zCNQgJI\"",
              "keep-alive": "timeout=5",
              "x-powered-by": "Express"
            },
            "data": {
              "success": true,
              "data": {
                "experiment_id": "92f59345-9bc7-4b25-88d9-9c53f9c9559c",
                "title": "交互式粒子系统演示（按钮、滑块、动画）",
                "description": "摘要\n- 未能找到与请求精确匹配的 Wikipedia 页面（没有可检索到的特定条目）。因此下面的演示基于常见的人机交互与动画实现原则：按钮用于触发离散动作，滑块用于调节连续参数，动画由 requestAnimationFrame 驱动，状态管理清晰、可读，便于交互与可访问性。\n- 本示例演示一个包含多个交互元素的复杂系统：粒子仿真（可视化动画），包含按钮、滑块、开关、颜色选择器和鼠标拖拽交互，支持实时参数调整、暂停/单步/重置与可视化选项（尾迹、碰撞、包裹等）。代码为自包含 HTML + JavaScript + CSS，无外部依赖，注释完整，便于学习和扩展。\n\n完整 HTML 代码：",
                "html_content": "<div class=\"app\" id=\"app\">\n  <div class=\"canvas-wrap\" aria-live=\"polite\">\n    <canvas id=\"canvas\" tabindex=\"0\" aria-label=\"粒子动画画布\"></canvas>\n    <div class=\"info-bar\" role=\"status\" aria-atomic=\"true\">\n      <div class=\"stat\" id=\"fps\">FPS: --</div>\n      <div class=\"stat\" id=\"count\">粒子数: --</div>\n      <div class=\"stat\" id=\"mode\">模式: 立即更新</div>\n      <div style=\"margin-left:auto;color:var(--muted);font-size:13px\">按空格暂停/继续 • C 清空 • B 爆发</div>\n    </div>\n    <div class=\"footer-note small\">在画布上点击生成粒子；拖拽可设置初速度向量；使用“爆发”生成大量粒子。</div>\n  </div>\n\n  <aside class=\"panel\" role=\"region\" aria-label=\"控制面板\">\n    <h2>控制面板</h2>\n\n    <div class=\"section\">\n      <div class=\"controls\">\n        <button id=\"btnStart\" class=\"btn-primary\" aria-pressed=\"true\">暂停</button>\n        <button id=\"btnStep\">单步</button>\n        <button id=\"btnReset\">重置</button>\n        <button id=\"btnBurst\">爆发（B）</button>\n        <button id=\"btnClear\">清空（C）</button>\n      </div>\n      <div class=\"hint\">交互提示：点画布生成一个粒子；拖动设置初速度；长按爆发连续生成。</div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">运动参数</h3>\n      <div class=\"control-item\">\n        <label for=\"sGravity\">重力 (Gravity): <span id=\"valGravity\">0.12</span></label>\n        <input id=\"sGravity\" type=\"range\" min=\"-1\" max=\"1\" step=\"0.01\" value=\"0.12\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sWind\">风 (Wind): <span id=\"valWind\">0.00</span></label>\n        <input id=\"sWind\" type=\"range\" min=\"-1\" max=\"1\" step=\"0.01\" value=\"0.00\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sVisc\">阻尼 (Viscosity): <span id=\"valVisc\">0.01</span></label>\n        <input id=\"sVisc\" type=\"range\" min=\"0\" max=\"0.1\" step=\"0.001\" value=\"0.01\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sSize\">粒子大小 (radius): <span id=\"valSize\">4</span></label>\n        <input id=\"sSize\" type=\"range\" min=\"1\" max=\"12\" step=\"1\" value=\"4\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sSpeed\">初始速度 (speed): <span id=\"valSpeed\">2.5</span></label>\n        <input id=\"sSpeed\" type=\"range\" min=\"0\" max=\"8\" step=\"0.1\" value=\"2.5\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sRate\">每次生成数量 (spawn per click): <span id=\"valRate\">1</span></label>\n        <input id=\"sRate\" type=\"range\" min=\"1\" max=\"30\" step=\"1\" value=\"1\" />\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">行为与显示</h3>\n      <div class=\"control-item toggle\">\n        <input id=\"chkTrails\" type=\"checkbox\" checked />\n        <label for=\"chkTrails\">尾迹 (Trails)</label>\n      </div>\n      <div class=\"control-item toggle\">\n        <input id=\"chkCollide\" type=\"checkbox\" />\n        <label for=\"chkCollide\">边界弹性碰撞 (Bounce)</label>\n      </div>\n      <div class=\"control-item toggle\">\n        <input id=\"chkWrap\" type=\"checkbox\" />\n        <label for=\"chkWrap\">穿越边界 (Wrap around)</label>\n      </div>\n      <div class=\"control-item\">\n        <label for=\"selectColor\">颜色模式</label>\n        <select id=\"selectColor\" class=\"full\" aria-label=\"颜色模式选择\">\n          <option value=\"random\">随机色</option>\n          <option value=\"gradient\" selected>渐变色</option>\n          <option value=\"solid\">单一颜色</option>\n        </select>\n      </div>\n      <div class=\"control-item\" id=\"solidColorWrap\" style=\"display:none\">\n        <label for=\"solidColor\">选择颜色</label>\n        <input id=\"solidColor\" class=\"color-input\" type=\"color\" value=\"#3ee5c1\" />\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">交互与导出</h3>\n      <div class=\"control-item\">\n        <button id=\"btnSave\">导出状态 (JSON)</button>\n        <button id=\"btnLoad\">导入状态 (粘贴 JSON)</button>\n      </div>\n      <div class=\"control-item\">\n        <label for=\"speedMode\">渲染模式</label>\n        <select id=\"speedMode\" class=\"full\">\n          <option value=\"live\">立即更新（默认）</option>\n          <option value=\"fixed\">固定步长（更稳定）</option>\n        </select>\n      </div>\n      <div class=\"hint\">可保存当前粒子位置与参数为 JSON，之后可粘贴恢复。</div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">快捷键</h3>\n      <div class=\"small\">\n        <div><span class=\"kbd\">Space</span> 暂停/继续</div>\n        <div><span class=\"kbd\">C</span> 清空</div>\n        <div><span class=\"kbd\">B</span> 爆发</div>\n      </div>\n    </div>\n\n    <div style=\"height:30px\"></div>\n  </aside>\n</div>\n\n<script>\n/*\n  交互式粒子系统\n  - 支持：开始/暂停、单步、重置、爆发、清空\n  - 参数实时控制：重力、风、阻尼、粒子大小、初速度、生成数量\n  - 显示选项：尾迹、碰撞/包裹、颜色模式\n  - 鼠标交互：点击生成；拖拽设置初速度\n  - 导出/导入当前状态（JSON）\n  - 无外部依赖，兼容现代浏览器\n*/\n\n/* ---------- 全局与帮助函数 ---------- */\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d', { alpha: true });\nlet DPR = Math.max(1, window.devicePixelRatio || 1);\n\n/* resize canvas to displayed size */\nfunction resizeCanvas(){\n  const rect = canvas.getBoundingClientRect();\n  canvas.width = Math.round(rect.width * DPR);\n  canvas.height = Math.round(rect.height * DPR);\n  ctx.setTransform(DPR,0,0,DPR,0,0); // use CSS pixels in drawing\n}\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\n\n/* ---------- 控件引用 ---------- */\nconst btnStart = document.getElementById('btnStart');\nconst btnStep = document.getElementById('btnStep');\nconst btnReset = document.getElementById('btnReset');\nconst btnBurst = document.getElementById('btnBurst');\nconst btnClear = document.getElementById('btnClear');\nconst btnSave = document.getElementById('btnSave');\nconst btnLoad = document.getElementById('btnLoad');\n\nconst sGravity = document.getElementById('sGravity');\nconst sWind = document.getElementById('sWind');\nconst sVisc = document.getElementById('sVisc');\nconst sSize = document.getElementById('sSize');\nconst sSpeed = document.getElementById('sSpeed');\nconst sRate = document.getElementById('sRate');\n\nconst valGravity = document.getElementById('valGravity');\nconst valWind = document.getElementById('valWind');\nconst valVisc = document.getElementById('valVisc');\nconst valSize = document.getElementById('valSize');\nconst valSpeed = document.getElementById('valSpeed');\nconst valRate = document.getElementById('valRate');\n\nconst chkTrails = document.getElementById('chkTrails');\nconst chkCollide = document.getElementById('chkCollide');\nconst chkWrap = document.getElementById('chkWrap');\nconst selectColor = document.getElementById('selectColor');\nconst solidColorWrap = document.getElementById('solidColorWrap');\nconst solidColor = document.getElementById('solidColor');\n\nconst fpsEl = document.getElementById('fps');\nconst countEl = document.getElementById('count');\nconst modeEl = document.getElementById('mode');\nconst speedMode = document.getElementById('speedMode');\n\n/* ---------- 仿真参数与状态 ---------- */\nlet running = true;\nlet lastTime = performance.now();\nlet accumulator = 0;\nlet fixedDt = 1/60; // for fixed step\n\nconst state = {\n  gravity: parseFloat(sGravity.value),\n  wind: parseFloat(sWind.value),\n  visc: parseFloat(sVisc.value),\n  radius: parseFloat(sSize.value),\n  initialSpeed: parseFloat(sSpeed.value),\n  spawnPerClick: parseInt(sRate.value,10),\n  trails: chkTrails.checked,\n  collide: chkCollide.checked,\n  wrap: chkWrap.checked,\n  colorMode: selectColor.value,\n  solidColor: solidColor.value,\n  particles: []\n};\n\n/* ---------- 粒子类 ---------- */\nclass Particle {\n  constructor(x,y,vx,vy,r,color){\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.r = r;\n    this.color = color || randomColor();\n    this.age = 0;\n    this.maxAge = 10 + Math.random()*20;\n  }\n  step(dt){\n    // forces: gravity downward, wind horizontal\n    this.vy += state.gravity * dt * 60; // scale to feel right\n    this.vx += state.wind * dt * 60;\n    // viscosity (simple velocity damping)\n    this.vx *= (1 - state.visc);\n    this.vy *= (1 - state.visc);\n    // integrate\n    this.x += this.vx * dt * 60;\n    this.y += this.vy * dt * 60;\n    this.age += dt;\n  }\n}\n\n/* ---------- 辅助 ---------- */\nfunction randomColor(){\n  // return a pastel-like random color\n  const h = Math.floor(Math.random()*360);\n  const s = 70 + Math.random()*20;\n  const l = 50 + Math.random()*10;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\nfunction gradientColor(t){\n  // t in [0,1]\n  const h = (200 + 160 * t) % 360;\n  const s = 70;\n  const l = 60 - 20*t;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\n/* ---------- 粒子管理 ---------- */\nfunction spawnParticle(x,y,angle,speed){\n  const r = state.radius;\n  const speedVal = speed ?? (state.initialSpeed + (Math.random()-0.5)*0.5);\n  const vx = Math.cos(angle) * speedVal;\n  const vy = Math.sin(angle) * speedVal;\n  let color;\n  if(state.colorMode === 'random') color = randomColor();\n  else if(state.colorMode === 'gradient') color = gradientColor(Math.random());\n  else color = state.solidColor;\n  const p = new Particle(x,y,vx,vy,r,color);\n  state.particles.push(p);\n  return p;\n}\n\nfunction spawnBurst(x,y,n){\n  for(let i=0;i<n;i++){\n    const ang = Math.random()*Math.PI*2;\n    const sp = state.initialSpeed + Math.random()*3;\n    spawnParticle(x,y,ang,sp);\n  }\n}\n\nfunction resetSimulation(){\n  state.particles.length = 0;\n  // place a few sample particles\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  for(let i=0;i<8;i++){\n    spawnBurst(cx + (Math.random()-0.5)*200, cy + (Math.random()-0.5)*120, 1);\n  }\n}\n\n/* ---------- 物理与边界 ---------- */\nfunction handleBounds(p){\n  const w = canvas.clientWidth;\n  const h = canvas.clientHeight;\n  if(state.wrap){\n    if(p.x < -p.r) p.x = w + p.r;\n    if(p.x > w + p.r) p.x = -p.r;\n    if(p.y < -p.r) p.y = h + p.r;\n    if(p.y > h + p.r) p.y = -p.r;\n  } else if(state.collide){\n    // simple elastic collision with walls\n    if(p.x - p.r < 0){\n      p.x = p.r; p.vx = Math.abs(p.vx)*0.8;\n    }\n    if(p.x + p.r > w){\n      p.x = w - p.r; p.vx = -Math.abs(p.vx)*0.8;\n    }\n    if(p.y - p.r < 0){\n      p.y = p.r; p.vy = Math.abs(p.vy)*0.8;\n    }\n    if(p.y + p.r > h){\n      p.y = h - p.r; p.vy = -Math.abs(p.vy)*0.8;\n    }\n  } else {\n    // leave as-is (may go off-screen)\n  }\n}\n\n/* ---------- 渲染 ---------- */\nfunction render(){\n  // Clear or fade for trails\n  if(state.trails){\n    // draw semi-transparent rect to create trail fading\n    ctx.fillStyle = 'rgba(5,8,14,0.15)';\n    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  } else {\n    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  }\n\n  // draw particles\n  for(const p of state.particles){\n    ctx.beginPath();\n    ctx.fillStyle = p.color;\n    ctx.globalAlpha = Math.max(0.1, 1 - p.age/p.maxAge);\n    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);\n    ctx.fill();\n    // small highlight\n    ctx.globalAlpha = 0.18;\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(p.x - p.r*0.25, p.y - p.r*0.25, Math.max(0.5,p.r*0.5), 0, Math.PI*2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n  }\n}\n\n/* ---------- 仿真步进 ---------- */\nfunction step(dt){\n  // dt in seconds\n  const removals = [];\n  for(let i=0;i<state.particles.length;i++){\n    const p = state.particles[i];\n    p.step(dt);\n    handleBounds(p);\n    // ageing removal\n    if(p.age > p.maxAge){\n      removals.push(i);\n    }\n  }\n  // remove old particles (reverse order)\n  for(let i=removals.length-1;i>=0;i--){\n    state.particles.splice(removals[i],1);\n  }\n}\n\n/* ---------- 主循环 ---------- */\nlet frames = 0;\nlet fpsTimer = performance.now();\n\nfunction loop(now){\n  const dtMs = now - lastTime;\n  lastTime = now;\n  const dt = Math.min(0.05, dtMs/1000); // clamp for big lags\n\n  if(running){\n    if(speedMode.value === 'live'){\n      step(dt);\n    } else {\n      // fixed step with accumulator\n      accumulator += dt;\n      const maxSteps = 5;\n      let steps = 0;\n      while(accumulator >= fixedDt && steps < maxSteps){\n        step(fixedDt);\n        accumulator -= fixedDt;\n        steps++;\n      }\n    }\n  }\n  render();\n\n  // update stats every 250ms\n  frames++;\n  if(now - fpsTimer >= 250){\n    const fps = Math.round(frames * 1000 / (now - fpsTimer));\n    fpsEl.textContent = `FPS: ${fps}`;\n    countEl.textContent = `粒子数: ${state.particles.length}`;\n    modeEl.textContent = `模式: ${speedMode.value === 'live' ? '立即更新' : '固定步长'}`;\n    fpsTimer = now;\n    frames = 0;\n  }\n\n  requestAnimationFrame(loop);\n}\n\n/* ---------- 事件：控件和交互 ---------- */\nbtnStart.addEventListener('click', ()=>{\n  running = !running;\n  btnStart.textContent = running ? '暂停' : '继续';\n  btnStart.classList.toggle('btn-primary', !running);\n  btnStart.setAttribute('aria-pressed', String(!running));\n});\n\nbtnStep.addEventListener('click', ()=>{\n  step(1/60);\n  render();\n});\n\nbtnReset.addEventListener('click', ()=>{\n  state.particles.length = 0;\n  resetSimulation();\n});\n\nbtnClear.addEventListener('click', ()=>{\n  state.particles.length = 0;\n});\n\nbtnBurst.addEventListener('click', ()=>{\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  spawnBurst(cx,cy,60);\n});\n\nbtnSave.addEventListener('click', ()=>{\n  const data = {\n    params: {\n      gravity: state.gravity,\n      wind: state.wind,\n      visc: state.visc,\n      radius: state.radius,\n      initialSpeed: state.initialSpeed,\n      spawnPerClick: state.spawnPerClick,\n      trails: state.trails,\n      collide: state.collide,\n      wrap: state.wrap,\n      colorMode: state.colorMode,\n      solidColor: state.solidColor\n    },\n    particles: state.particles.map(p=>({x:p.x,y:p.y,vx:p.vx,vy:p.vy,r:p.r,color:p.color,age:p.age,maxAge:p.maxAge}))\n  };\n  const text = JSON.stringify(data, null, 2);\n  // show in a new window for copy\n  const w = window.open('', '_blank');\n  w.document.title = '导出 - 粒子状态';\n  const pre = w.document.createElement('pre');\n  pre.textContent = text;\n  w.document.body.appendChild(pre);\n});\n\nbtnLoad.addEventListener('click', ()=>{\n  const text = prompt('粘贴之前导出的 JSON（覆盖当前）:');\n  if(!text) return;\n  try{\n    const data = JSON.parse(text);\n    if(data.params){\n      Object.assign(state, {\n        gravity: data.params.gravity,\n        wind: data.params.wind,\n        visc: data.params.visc,\n        radius: data.params.radius,\n        initialSpeed: data.params.initialSpeed,\n        spawnPerClick: data.params.spawnPerClick,\n        trails: data.params.trails,\n        collide: data.params.collide,\n        wrap: data.params.wrap,\n        colorMode: data.params.colorMode,\n        solidColor: data.params.solidColor\n      });\n      // update UI to reflect\n      sGravity.value = state.gravity; sWind.value = state.wind; sVisc.value = state.visc;\n      sSize.value = state.radius; sSpeed.value = state.initialSpeed; sRate.value = state.spawnPerClick;\n      chkTrails.checked = state.trails; chkCollide.checked = state.collide; chkWrap.checked = state.wrap;\n      selectColor.value = state.colorMode; solidColor.value = state.solidColor;\n      updateValuesDisplay();\n    }\n    state.particles.length = 0;\n    if(Array.isArray(data.particles)){\n      for(const pp of data.particles){\n        const p = new Particle(pp.x, pp.y, pp.vx, pp.vy, pp.r, pp.color);\n        p.age = pp.age || 0; p.maxAge = pp.maxAge || 20;\n        state.particles.push(p);\n      }\n    }\n  } catch(e){\n    alert('无效的 JSON：' + e.message);\n  }\n});\n\n/* sliders change handlers */\nfunction updateValuesDisplay(){\n  valGravity.textContent = parseFloat(sGravity.value).toFixed(2);\n  valWind.textContent = parseFloat(sWind.value).toFixed(2);\n  valVisc.textContent = parseFloat(sVisc.value).toFixed(3);\n  valSize.textContent = parseFloat(sSize.value);\n  valSpeed.textContent = parseFloat(sSpeed.value);\n  valRate.textContent = parseInt(sRate.value,10);\n\n  // update state\n  state.gravity = parseFloat(sGravity.value);\n  state.wind = parseFloat(sWind.value);\n  state.visc = parseFloat(sVisc.value);\n  state.radius = parseFloat(sSize.value);\n  state.initialSpeed = parseFloat(sSpeed.value);\n  state.spawnPerClick = parseInt(sRate.value,10);\n  state.solidColor = solidColor.value;\n  state.colorMode = selectColor.value;\n  state.trails = chkTrails.checked;\n  state.collide = chkCollide.checked;\n  state.wrap = chkWrap.checked;\n}\n[sGravity,sWind,sVisc,sSize,sSpeed,sRate,chkTrails,chkCollide,chkWrap,selectColor,solidColor].forEach(el=>{\n  el.addEventListener('input', updateValuesDisplay);\n});\n\n/* change color selection shows color input */\nselectColor.addEventListener('change', ()=>{\n  solidColorWrap.style.display = selectColor.value === 'solid' ? 'block':'none';\n  updateValuesDisplay();\n});\n\n/* ---------- 鼠标交互（点击/拖拽） ---------- */\nlet dragging = false;\nlet dragStart = null;\nlet dragCurrent = null;\ncanvas.addEventListener('pointerdown', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = true;\n  dragStart = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  dragCurrent = {...dragStart};\n  canvas.setPointerCapture(e.pointerId);\n  // if user clicks without drag, spawn after pointerup\n});\n\ncanvas.addEventListener('pointermove', (e)=>{\n  if(!dragging) return;\n  const rect = canvas.getBoundingClientRect();\n  dragCurrent = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // draw preview velocity vector (overlay)\n  // we'll draw it in a lightweight way by rendering on top after main render\n  render();\n  // draw vector\n  ctx.save();\n  ctx.strokeStyle = 'rgba(255,255,255,0.7)';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(dragStart.x, dragStart.y);\n  ctx.lineTo(dragCurrent.x, dragCurrent.y);\n  ctx.stroke();\n  // small circle at start\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\n  ctx.beginPath();\n  ctx.arc(dragStart.x, dragStart.y, 4, 0, Math.PI*2);\n  ctx.fill();\n  ctx.restore();\n});\n\ncanvas.addEventListener('pointerup', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = false;\n  const up = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // compute velocity from drag vector\n  let vx = 0, vy = 0;\n  const dx = up.x - dragStart.x, dy = up.y - dragStart.y;\n  const dist = Math.hypot(dx,dy);\n  if(dist > 6){\n    const angle = Math.atan2(dy,dx);\n    const speed = Math.min(10, dist/10 + state.initialSpeed*0.2);\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  } else {\n    // small random direction\n    const angle = Math.random()*Math.PI*2;\n    const speed = state.initialSpeed;\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  }\n  // spawn spawnPerClick particles at click position\n  const n = state.spawnPerClick;\n  for(let i=0;i<n;i++){\n    const jitter = (i - n/2) * 2;\n    spawnParticle(dragStart.x + jitter, dragStart.y + jitter, Math.atan2(vy, vx) + (Math.random()-0.5)*0.4, Math.hypot(vx,vy)*(0.9 + Math.random()*0.2));\n  }\n  render();\n});\n\n/* keyboard shortcuts */\nwindow.addEventListener('keydown', (e)=>{\n  if(e.code === 'Space'){\n    e.preventDefault();\n    btnStart.click();\n  } else if(e.key.toLowerCase() === 'c'){\n    btnClear.click();\n  } else if(e.key.toLowerCase() === 'b'){\n    btnBurst.click();\n  }\n});\n\n/* prevent context menu on canvas for convenience */\ncanvas.addEventListener('contextmenu', (e)=>e.preventDefault());\n\n/* ---------- 初始化 ---------- */\nupdateValuesDisplay();\nresetSimulation();\nrequestAnimationFrame((t)=>{\n  lastTime = t;\n  fpsTimer = t;\n  loop(t);\n});\n\n/* handle Resize HiDPI on load and orientation change */\nwindow.addEventListener('orientationchange', ()=>{\n  setTimeout(()=>{ resizeCanvas(); }, 200);\n});\n/* keep canvas size correct when CSS changes */\nconst ro = new ResizeObserver(()=>{ resizeCanvas(); });\nro.observe(canvas);\n\n/* end of script */\n</script>",
                "css_content": ":root{\n    --bg:#0f1724;\n    --panel:#0b1220cc;\n    --accent:#4fd1c5;\n    --muted:#9aa6b2;\n    --glass: rgba(255,255,255,0.03);\n  }\n  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;color:#e6eef6;background:linear-gradient(180deg,var(--bg),#071023);}\n  .app{\n    display:flex;\n    gap:16px;\n    padding:18px;\n    box-sizing:border-box;\n    align-items:flex-start;\n    min-height:100vh;\n  }\n  .canvas-wrap{\n    flex:1 1 70%;\n    min-width:360px;\n    border-radius:12px;\n    overflow:hidden;\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    box-shadow: 0 6px 30px rgba(2,6,23,0.7), inset 0 1px 0 rgba(255,255,255,0.02);\n    position:relative;\n    padding:12px;\n  }\n  canvas{\n    width:100%;\n    height:70vh;\n    display:block;\n    border-radius:8px;\n    background: radial-gradient(circle at 20% 10%, rgba(255,255,255,0.02), transparent 10%),\n                linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03));\n    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\n  }\n  .info-bar{\n    display:flex;\n    gap:12px;\n    align-items:center;\n    margin-top:10px;\n    color:var(--muted);\n    font-size:13px;\n  }\n  .panel{\n    width:360px;\n    background:var(--panel);\n    border-radius:12px;\n    padding:14px;\n    box-shadow: 0 8px 30px rgba(2,6,23,0.6);\n    color:#e6eef6;\n    flex-shrink:0;\n    max-height:calc(100vh - 36px);\n    overflow:auto;\n  }\n  h2{margin:0 0 10px 0;font-size:16px}\n  .section{margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid rgba(255,255,255,0.03)}\n  .controls{display:flex;flex-wrap:wrap;gap:8px}\n  button{\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    border:1px solid rgba(255,255,255,0.04);\n    color:var(--accent);\n    padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;\n    transition:transform .08s ease,box-shadow .08s;\n  }\n  button:active{transform:translateY(1px)}\n  .btn-primary{background:linear-gradient(90deg,#0ea5a8,#38bdf8); color:#012; border:none; box-shadow:0 6px 18px rgba(14,165,168,0.12);}\n  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px;}\n  .row{display:flex;align-items:center;gap:8px}\n  .full{width:100%}\n  input[type=\"range\"]{width:100%}\n  .control-item{margin-bottom:10px}\n  .small{font-size:12px;color:var(--muted)}\n  .stat{background:var(--glass);padding:8px 10px;border-radius:8px;color:var(--muted);font-size:13px}\n  .footer-note{font-size:12px;color:var(--muted);margin-top:10px}\n  .kbd{background:rgba(255,255,255,0.04);padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}\n  .color-input{height:34px;padding:0;border-radius:6px;border:none;cursor:pointer}\n  .toggle{display:flex;align-items:center;gap:8px}\n  .hint{font-size:12px;color:var(--muted);margin-top:6px}\n  a{color:var(--accent)}\n  /* Make scrollbars subtle */\n  .panel::-webkit-scrollbar{width:10px;height:10px}\n  .panel::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.03);border-radius:8px}\n  @media (max-width:900px){\n    .app{flex-direction:column;padding:12px}\n    .canvas-wrap{order:2}\n    .panel{order:1;width:100%}\n    canvas{height:50vh}\n  }",
                "js_content": "/*\n  交互式粒子系统\n  - 支持：开始/暂停、单步、重置、爆发、清空\n  - 参数实时控制：重力、风、阻尼、粒子大小、初速度、生成数量\n  - 显示选项：尾迹、碰撞/包裹、颜色模式\n  - 鼠标交互：点击生成；拖拽设置初速度\n  - 导出/导入当前状态（JSON）\n  - 无外部依赖，兼容现代浏览器\n*/\n\n/* ---------- 全局与帮助函数 ---------- */\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d', { alpha: true });\nlet DPR = Math.max(1, window.devicePixelRatio || 1);\n\n/* resize canvas to displayed size */\nfunction resizeCanvas(){\n  const rect = canvas.getBoundingClientRect();\n  canvas.width = Math.round(rect.width * DPR);\n  canvas.height = Math.round(rect.height * DPR);\n  ctx.setTransform(DPR,0,0,DPR,0,0); // use CSS pixels in drawing\n}\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\n\n/* ---------- 控件引用 ---------- */\nconst btnStart = document.getElementById('btnStart');\nconst btnStep = document.getElementById('btnStep');\nconst btnReset = document.getElementById('btnReset');\nconst btnBurst = document.getElementById('btnBurst');\nconst btnClear = document.getElementById('btnClear');\nconst btnSave = document.getElementById('btnSave');\nconst btnLoad = document.getElementById('btnLoad');\n\nconst sGravity = document.getElementById('sGravity');\nconst sWind = document.getElementById('sWind');\nconst sVisc = document.getElementById('sVisc');\nconst sSize = document.getElementById('sSize');\nconst sSpeed = document.getElementById('sSpeed');\nconst sRate = document.getElementById('sRate');\n\nconst valGravity = document.getElementById('valGravity');\nconst valWind = document.getElementById('valWind');\nconst valVisc = document.getElementById('valVisc');\nconst valSize = document.getElementById('valSize');\nconst valSpeed = document.getElementById('valSpeed');\nconst valRate = document.getElementById('valRate');\n\nconst chkTrails = document.getElementById('chkTrails');\nconst chkCollide = document.getElementById('chkCollide');\nconst chkWrap = document.getElementById('chkWrap');\nconst selectColor = document.getElementById('selectColor');\nconst solidColorWrap = document.getElementById('solidColorWrap');\nconst solidColor = document.getElementById('solidColor');\n\nconst fpsEl = document.getElementById('fps');\nconst countEl = document.getElementById('count');\nconst modeEl = document.getElementById('mode');\nconst speedMode = document.getElementById('speedMode');\n\n/* ---------- 仿真参数与状态 ---------- */\nlet running = true;\nlet lastTime = performance.now();\nlet accumulator = 0;\nlet fixedDt = 1/60; // for fixed step\n\nconst state = {\n  gravity: parseFloat(sGravity.value),\n  wind: parseFloat(sWind.value),\n  visc: parseFloat(sVisc.value),\n  radius: parseFloat(sSize.value),\n  initialSpeed: parseFloat(sSpeed.value),\n  spawnPerClick: parseInt(sRate.value,10),\n  trails: chkTrails.checked,\n  collide: chkCollide.checked,\n  wrap: chkWrap.checked,\n  colorMode: selectColor.value,\n  solidColor: solidColor.value,\n  particles: []\n};\n\n/* ---------- 粒子类 ---------- */\nclass Particle {\n  constructor(x,y,vx,vy,r,color){\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.r = r;\n    this.color = color || randomColor();\n    this.age = 0;\n    this.maxAge = 10 + Math.random()*20;\n  }\n  step(dt){\n    // forces: gravity downward, wind horizontal\n    this.vy += state.gravity * dt * 60; // scale to feel right\n    this.vx += state.wind * dt * 60;\n    // viscosity (simple velocity damping)\n    this.vx *= (1 - state.visc);\n    this.vy *= (1 - state.visc);\n    // integrate\n    this.x += this.vx * dt * 60;\n    this.y += this.vy * dt * 60;\n    this.age += dt;\n  }\n}\n\n/* ---------- 辅助 ---------- */\nfunction randomColor(){\n  // return a pastel-like random color\n  const h = Math.floor(Math.random()*360);\n  const s = 70 + Math.random()*20;\n  const l = 50 + Math.random()*10;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\nfunction gradientColor(t){\n  // t in [0,1]\n  const h = (200 + 160 * t) % 360;\n  const s = 70;\n  const l = 60 - 20*t;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\n/* ---------- 粒子管理 ---------- */\nfunction spawnParticle(x,y,angle,speed){\n  const r = state.radius;\n  const speedVal = speed ?? (state.initialSpeed + (Math.random()-0.5)*0.5);\n  const vx = Math.cos(angle) * speedVal;\n  const vy = Math.sin(angle) * speedVal;\n  let color;\n  if(state.colorMode === 'random') color = randomColor();\n  else if(state.colorMode === 'gradient') color = gradientColor(Math.random());\n  else color = state.solidColor;\n  const p = new Particle(x,y,vx,vy,r,color);\n  state.particles.push(p);\n  return p;\n}\n\nfunction spawnBurst(x,y,n){\n  for(let i=0;i<n;i++){\n    const ang = Math.random()*Math.PI*2;\n    const sp = state.initialSpeed + Math.random()*3;\n    spawnParticle(x,y,ang,sp);\n  }\n}\n\nfunction resetSimulation(){\n  state.particles.length = 0;\n  // place a few sample particles\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  for(let i=0;i<8;i++){\n    spawnBurst(cx + (Math.random()-0.5)*200, cy + (Math.random()-0.5)*120, 1);\n  }\n}\n\n/* ---------- 物理与边界 ---------- */\nfunction handleBounds(p){\n  const w = canvas.clientWidth;\n  const h = canvas.clientHeight;\n  if(state.wrap){\n    if(p.x < -p.r) p.x = w + p.r;\n    if(p.x > w + p.r) p.x = -p.r;\n    if(p.y < -p.r) p.y = h + p.r;\n    if(p.y > h + p.r) p.y = -p.r;\n  } else if(state.collide){\n    // simple elastic collision with walls\n    if(p.x - p.r < 0){\n      p.x = p.r; p.vx = Math.abs(p.vx)*0.8;\n    }\n    if(p.x + p.r > w){\n      p.x = w - p.r; p.vx = -Math.abs(p.vx)*0.8;\n    }\n    if(p.y - p.r < 0){\n      p.y = p.r; p.vy = Math.abs(p.vy)*0.8;\n    }\n    if(p.y + p.r > h){\n      p.y = h - p.r; p.vy = -Math.abs(p.vy)*0.8;\n    }\n  } else {\n    // leave as-is (may go off-screen)\n  }\n}\n\n/* ---------- 渲染 ---------- */\nfunction render(){\n  // Clear or fade for trails\n  if(state.trails){\n    // draw semi-transparent rect to create trail fading\n    ctx.fillStyle = 'rgba(5,8,14,0.15)';\n    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  } else {\n    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  }\n\n  // draw particles\n  for(const p of state.particles){\n    ctx.beginPath();\n    ctx.fillStyle = p.color;\n    ctx.globalAlpha = Math.max(0.1, 1 - p.age/p.maxAge);\n    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);\n    ctx.fill();\n    // small highlight\n    ctx.globalAlpha = 0.18;\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(p.x - p.r*0.25, p.y - p.r*0.25, Math.max(0.5,p.r*0.5), 0, Math.PI*2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n  }\n}\n\n/* ---------- 仿真步进 ---------- */\nfunction step(dt){\n  // dt in seconds\n  const removals = [];\n  for(let i=0;i<state.particles.length;i++){\n    const p = state.particles[i];\n    p.step(dt);\n    handleBounds(p);\n    // ageing removal\n    if(p.age > p.maxAge){\n      removals.push(i);\n    }\n  }\n  // remove old particles (reverse order)\n  for(let i=removals.length-1;i>=0;i--){\n    state.particles.splice(removals[i],1);\n  }\n}\n\n/* ---------- 主循环 ---------- */\nlet frames = 0;\nlet fpsTimer = performance.now();\n\nfunction loop(now){\n  const dtMs = now - lastTime;\n  lastTime = now;\n  const dt = Math.min(0.05, dtMs/1000); // clamp for big lags\n\n  if(running){\n    if(speedMode.value === 'live'){\n      step(dt);\n    } else {\n      // fixed step with accumulator\n      accumulator += dt;\n      const maxSteps = 5;\n      let steps = 0;\n      while(accumulator >= fixedDt && steps < maxSteps){\n        step(fixedDt);\n        accumulator -= fixedDt;\n        steps++;\n      }\n    }\n  }\n  render();\n\n  // update stats every 250ms\n  frames++;\n  if(now - fpsTimer >= 250){\n    const fps = Math.round(frames * 1000 / (now - fpsTimer));\n    fpsEl.textContent = `FPS: ${fps}`;\n    countEl.textContent = `粒子数: ${state.particles.length}`;\n    modeEl.textContent = `模式: ${speedMode.value === 'live' ? '立即更新' : '固定步长'}`;\n    fpsTimer = now;\n    frames = 0;\n  }\n\n  requestAnimationFrame(loop);\n}\n\n/* ---------- 事件：控件和交互 ---------- */\nbtnStart.addEventListener('click', ()=>{\n  running = !running;\n  btnStart.textContent = running ? '暂停' : '继续';\n  btnStart.classList.toggle('btn-primary', !running);\n  btnStart.setAttribute('aria-pressed', String(!running));\n});\n\nbtnStep.addEventListener('click', ()=>{\n  step(1/60);\n  render();\n});\n\nbtnReset.addEventListener('click', ()=>{\n  state.particles.length = 0;\n  resetSimulation();\n});\n\nbtnClear.addEventListener('click', ()=>{\n  state.particles.length = 0;\n});\n\nbtnBurst.addEventListener('click', ()=>{\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  spawnBurst(cx,cy,60);\n});\n\nbtnSave.addEventListener('click', ()=>{\n  const data = {\n    params: {\n      gravity: state.gravity,\n      wind: state.wind,\n      visc: state.visc,\n      radius: state.radius,\n      initialSpeed: state.initialSpeed,\n      spawnPerClick: state.spawnPerClick,\n      trails: state.trails,\n      collide: state.collide,\n      wrap: state.wrap,\n      colorMode: state.colorMode,\n      solidColor: state.solidColor\n    },\n    particles: state.particles.map(p=>({x:p.x,y:p.y,vx:p.vx,vy:p.vy,r:p.r,color:p.color,age:p.age,maxAge:p.maxAge}))\n  };\n  const text = JSON.stringify(data, null, 2);\n  // show in a new window for copy\n  const w = window.open('', '_blank');\n  w.document.title = '导出 - 粒子状态';\n  const pre = w.document.createElement('pre');\n  pre.textContent = text;\n  w.document.body.appendChild(pre);\n});\n\nbtnLoad.addEventListener('click', ()=>{\n  const text = prompt('粘贴之前导出的 JSON（覆盖当前）:');\n  if(!text) return;\n  try{\n    const data = JSON.parse(text);\n    if(data.params){\n      Object.assign(state, {\n        gravity: data.params.gravity,\n        wind: data.params.wind,\n        visc: data.params.visc,\n        radius: data.params.radius,\n        initialSpeed: data.params.initialSpeed,\n        spawnPerClick: data.params.spawnPerClick,\n        trails: data.params.trails,\n        collide: data.params.collide,\n        wrap: data.params.wrap,\n        colorMode: data.params.colorMode,\n        solidColor: data.params.solidColor\n      });\n      // update UI to reflect\n      sGravity.value = state.gravity; sWind.value = state.wind; sVisc.value = state.visc;\n      sSize.value = state.radius; sSpeed.value = state.initialSpeed; sRate.value = state.spawnPerClick;\n      chkTrails.checked = state.trails; chkCollide.checked = state.collide; chkWrap.checked = state.wrap;\n      selectColor.value = state.colorMode; solidColor.value = state.solidColor;\n      updateValuesDisplay();\n    }\n    state.particles.length = 0;\n    if(Array.isArray(data.particles)){\n      for(const pp of data.particles){\n        const p = new Particle(pp.x, pp.y, pp.vx, pp.vy, pp.r, pp.color);\n        p.age = pp.age || 0; p.maxAge = pp.maxAge || 20;\n        state.particles.push(p);\n      }\n    }\n  } catch(e){\n    alert('无效的 JSON：' + e.message);\n  }\n});\n\n/* sliders change handlers */\nfunction updateValuesDisplay(){\n  valGravity.textContent = parseFloat(sGravity.value).toFixed(2);\n  valWind.textContent = parseFloat(sWind.value).toFixed(2);\n  valVisc.textContent = parseFloat(sVisc.value).toFixed(3);\n  valSize.textContent = parseFloat(sSize.value);\n  valSpeed.textContent = parseFloat(sSpeed.value);\n  valRate.textContent = parseInt(sRate.value,10);\n\n  // update state\n  state.gravity = parseFloat(sGravity.value);\n  state.wind = parseFloat(sWind.value);\n  state.visc = parseFloat(sVisc.value);\n  state.radius = parseFloat(sSize.value);\n  state.initialSpeed = parseFloat(sSpeed.value);\n  state.spawnPerClick = parseInt(sRate.value,10);\n  state.solidColor = solidColor.value;\n  state.colorMode = selectColor.value;\n  state.trails = chkTrails.checked;\n  state.collide = chkCollide.checked;\n  state.wrap = chkWrap.checked;\n}\n[sGravity,sWind,sVisc,sSize,sSpeed,sRate,chkTrails,chkCollide,chkWrap,selectColor,solidColor].forEach(el=>{\n  el.addEventListener('input', updateValuesDisplay);\n});\n\n/* change color selection shows color input */\nselectColor.addEventListener('change', ()=>{\n  solidColorWrap.style.display = selectColor.value === 'solid' ? 'block':'none';\n  updateValuesDisplay();\n});\n\n/* ---------- 鼠标交互（点击/拖拽） ---------- */\nlet dragging = false;\nlet dragStart = null;\nlet dragCurrent = null;\ncanvas.addEventListener('pointerdown', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = true;\n  dragStart = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  dragCurrent = {...dragStart};\n  canvas.setPointerCapture(e.pointerId);\n  // if user clicks without drag, spawn after pointerup\n});\n\ncanvas.addEventListener('pointermove', (e)=>{\n  if(!dragging) return;\n  const rect = canvas.getBoundingClientRect();\n  dragCurrent = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // draw preview velocity vector (overlay)\n  // we'll draw it in a lightweight way by rendering on top after main render\n  render();\n  // draw vector\n  ctx.save();\n  ctx.strokeStyle = 'rgba(255,255,255,0.7)';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(dragStart.x, dragStart.y);\n  ctx.lineTo(dragCurrent.x, dragCurrent.y);\n  ctx.stroke();\n  // small circle at start\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\n  ctx.beginPath();\n  ctx.arc(dragStart.x, dragStart.y, 4, 0, Math.PI*2);\n  ctx.fill();\n  ctx.restore();\n});\n\ncanvas.addEventListener('pointerup', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = false;\n  const up = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // compute velocity from drag vector\n  let vx = 0, vy = 0;\n  const dx = up.x - dragStart.x, dy = up.y - dragStart.y;\n  const dist = Math.hypot(dx,dy);\n  if(dist > 6){\n    const angle = Math.atan2(dy,dx);\n    const speed = Math.min(10, dist/10 + state.initialSpeed*0.2);\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  } else {\n    // small random direction\n    const angle = Math.random()*Math.PI*2;\n    const speed = state.initialSpeed;\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  }\n  // spawn spawnPerClick particles at click position\n  const n = state.spawnPerClick;\n  for(let i=0;i<n;i++){\n    const jitter = (i - n/2) * 2;\n    spawnParticle(dragStart.x + jitter, dragStart.y + jitter, Math.atan2(vy, vx) + (Math.random()-0.5)*0.4, Math.hypot(vx,vy)*(0.9 + Math.random()*0.2));\n  }\n  render();\n});\n\n/* keyboard shortcuts */\nwindow.addEventListener('keydown', (e)=>{\n  if(e.code === 'Space'){\n    e.preventDefault();\n    btnStart.click();\n  } else if(e.key.toLowerCase() === 'c'){\n    btnClear.click();\n  } else if(e.key.toLowerCase() === 'b'){\n    btnBurst.click();\n  }\n});\n\n/* prevent context menu on canvas for convenience */\ncanvas.addEventListener('contextmenu', (e)=>e.preventDefault());\n\n/* ---------- 初始化 ---------- */\nupdateValuesDisplay();\nresetSimulation();\nrequestAnimationFrame((t)=>{\n  lastTime = t;\n  fpsTimer = t;\n  loop(t);\n});\n\n/* handle Resize HiDPI on load and orientation change */\nwindow.addEventListener('orientationchange', ()=>{\n  setTimeout(()=>{ resizeCanvas(); }, 200);\n});\n/* keep canvas size correct when CSS changes */\nconst ro = new ResizeObserver(()=>{ resizeCanvas(); });\nro.observe(canvas);\n\n/* end of script */",
                "parameters": [],
                "status": "success"
              },
              "attempts": 2
            },
            "rawData": "{\"success\":true,\"data\":{\"experiment_id\":\"92f59345-9bc7-4b25-88d9-9c53f9c9559c\",\"title\":\"交互式粒子系统演示（按钮、滑块、动画）\",\"description\":\"摘要\\n- 未能找到与请求精确匹配的 Wikipedia 页面（没有可检索到的特定条目）。因此下面的演示基于常见的人机交互与动画实现原则：按钮用于触发离散动作，滑块用于调节连续参数，动画由 requestAnimationFrame 驱动，状态管理清晰、可读，便于交互与可访问性。\\n- 本示例演示一个包含多个交互元素的复杂系统：粒子仿真（可视化动画），包含按钮、滑块、开关、颜色选择器和鼠标拖拽交互，支持实时参数调整、暂停/单步/重置与可视化选项（尾迹、碰撞、包裹等）。代码为自包含 HTML + JavaScript + CSS，无外部依赖，注释完整，便于学习和扩展。\\n\\n完整 HTML 代码：\",\"html_content\":\"<div class=\\\"app\\\" id=\\\"app\\\">\\n  <div class=\\\"canvas-wrap\\\" aria-live=\\\"polite\\\">\\n    <canvas id=\\\"canvas\\\" tabindex=\\\"0\\\" aria-label=\\\"粒子动画画布\\\"></canvas>\\n    <div class=\\\"info-bar\\\" role=\\\"status\\\" aria-atomic=\\\"true\\\">\\n      <div class=\\\"stat\\\" id=\\\"fps\\\">FPS: --</div>\\n      <div class=\\\"stat\\\" id=\\\"count\\\">粒子数: --</div>\\n      <div class=\\\"stat\\\" id=\\\"mode\\\">模式: 立即更新</div>\\n      <div style=\\\"margin-left:auto;color:var(--muted);font-size:13px\\\">按空格暂停/继续 • C 清空 • B 爆发</div>\\n    </div>\\n    <div class=\\\"footer-note small\\\">在画布上点击生成粒子；拖拽可设置初速度向量；使用“爆发”生成大量粒子。</div>\\n  </div>\\n\\n  <aside class=\\\"panel\\\" role=\\\"region\\\" aria-label=\\\"控制面板\\\">\\n    <h2>控制面板</h2>\\n\\n    <div class=\\\"section\\\">\\n      <div class=\\\"controls\\\">\\n        <button id=\\\"btnStart\\\" class=\\\"btn-primary\\\" aria-pressed=\\\"true\\\">暂停</button>\\n        <button id=\\\"btnStep\\\">单步</button>\\n        <button id=\\\"btnReset\\\">重置</button>\\n        <button id=\\\"btnBurst\\\">爆发（B）</button>\\n        <button id=\\\"btnClear\\\">清空（C）</button>\\n      </div>\\n      <div class=\\\"hint\\\">交互提示：点画布生成一个粒子；拖动设置初速度；长按爆发连续生成。</div>\\n    </div>\\n\\n    <div class=\\\"section\\\">\\n      <h3 style=\\\"margin:6px 0 8px 0\\\">运动参数</h3>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"sGravity\\\">重力 (Gravity): <span id=\\\"valGravity\\\">0.12</span></label>\\n        <input id=\\\"sGravity\\\" type=\\\"range\\\" min=\\\"-1\\\" max=\\\"1\\\" step=\\\"0.01\\\" value=\\\"0.12\\\" />\\n      </div>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"sWind\\\">风 (Wind): <span id=\\\"valWind\\\">0.00</span></label>\\n        <input id=\\\"sWind\\\" type=\\\"range\\\" min=\\\"-1\\\" max=\\\"1\\\" step=\\\"0.01\\\" value=\\\"0.00\\\" />\\n      </div>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"sVisc\\\">阻尼 (Viscosity): <span id=\\\"valVisc\\\">0.01</span></label>\\n        <input id=\\\"sVisc\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"0.1\\\" step=\\\"0.001\\\" value=\\\"0.01\\\" />\\n      </div>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"sSize\\\">粒子大小 (radius): <span id=\\\"valSize\\\">4</span></label>\\n        <input id=\\\"sSize\\\" type=\\\"range\\\" min=\\\"1\\\" max=\\\"12\\\" step=\\\"1\\\" value=\\\"4\\\" />\\n      </div>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"sSpeed\\\">初始速度 (speed): <span id=\\\"valSpeed\\\">2.5</span></label>\\n        <input id=\\\"sSpeed\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"8\\\" step=\\\"0.1\\\" value=\\\"2.5\\\" />\\n      </div>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"sRate\\\">每次生成数量 (spawn per click): <span id=\\\"valRate\\\">1</span></label>\\n        <input id=\\\"sRate\\\" type=\\\"range\\\" min=\\\"1\\\" max=\\\"30\\\" step=\\\"1\\\" value=\\\"1\\\" />\\n      </div>\\n    </div>\\n\\n    <div class=\\\"section\\\">\\n      <h3 style=\\\"margin:6px 0 8px 0\\\">行为与显示</h3>\\n      <div class=\\\"control-item toggle\\\">\\n        <input id=\\\"chkTrails\\\" type=\\\"checkbox\\\" checked />\\n        <label for=\\\"chkTrails\\\">尾迹 (Trails)</label>\\n      </div>\\n      <div class=\\\"control-item toggle\\\">\\n        <input id=\\\"chkCollide\\\" type=\\\"checkbox\\\" />\\n        <label for=\\\"chkCollide\\\">边界弹性碰撞 (Bounce)</label>\\n      </div>\\n      <div class=\\\"control-item toggle\\\">\\n        <input id=\\\"chkWrap\\\" type=\\\"checkbox\\\" />\\n        <label for=\\\"chkWrap\\\">穿越边界 (Wrap around)</label>\\n      </div>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"selectColor\\\">颜色模式</label>\\n        <select id=\\\"selectColor\\\" class=\\\"full\\\" aria-label=\\\"颜色模式选择\\\">\\n          <option value=\\\"random\\\">随机色</option>\\n          <option value=\\\"gradient\\\" selected>渐变色</option>\\n          <option value=\\\"solid\\\">单一颜色</option>\\n        </select>\\n      </div>\\n      <div class=\\\"control-item\\\" id=\\\"solidColorWrap\\\" style=\\\"display:none\\\">\\n        <label for=\\\"solidColor\\\">选择颜色</label>\\n        <input id=\\\"solidColor\\\" class=\\\"color-input\\\" type=\\\"color\\\" value=\\\"#3ee5c1\\\" />\\n      </div>\\n    </div>\\n\\n    <div class=\\\"section\\\">\\n      <h3 style=\\\"margin:6px 0 8px 0\\\">交互与导出</h3>\\n      <div class=\\\"control-item\\\">\\n        <button id=\\\"btnSave\\\">导出状态 (JSON)</button>\\n        <button id=\\\"btnLoad\\\">导入状态 (粘贴 JSON)</button>\\n      </div>\\n      <div class=\\\"control-item\\\">\\n        <label for=\\\"speedMode\\\">渲染模式</label>\\n        <select id=\\\"speedMode\\\" class=\\\"full\\\">\\n          <option value=\\\"live\\\">立即更新（默认）</option>\\n          <option value=\\\"fixed\\\">固定步长（更稳定）</option>\\n        </select>\\n      </div>\\n      <div class=\\\"hint\\\">可保存当前粒子位置与参数为 JSON，之后可粘贴恢复。</div>\\n    </div>\\n\\n    <div class=\\\"section\\\">\\n      <h3 style=\\\"margin:6px 0 8px 0\\\">快捷键</h3>\\n      <div class=\\\"small\\\">\\n        <div><span class=\\\"kbd\\\">Space</span> 暂停/继续</div>\\n        <div><span class=\\\"kbd\\\">C</span> 清空</div>\\n        <div><span class=\\\"kbd\\\">B</span> 爆发</div>\\n      </div>\\n    </div>\\n\\n    <div style=\\\"height:30px\\\"></div>\\n  </aside>\\n</div>\\n\\n<script>\\n/*\\n  交互式粒子系统\\n  - 支持：开始/暂停、单步、重置、爆发、清空\\n  - 参数实时控制：重力、风、阻尼、粒子大小、初速度、生成数量\\n  - 显示选项：尾迹、碰撞/包裹、颜色模式\\n  - 鼠标交互：点击生成；拖拽设置初速度\\n  - 导出/导入当前状态（JSON）\\n  - 无外部依赖，兼容现代浏览器\\n*/\\n\\n/* ---------- 全局与帮助函数 ---------- */\\nconst canvas = document.getElementById('canvas');\\nconst ctx = canvas.getContext('2d', { alpha: true });\\nlet DPR = Math.max(1, window.devicePixelRatio || 1);\\n\\n/* resize canvas to displayed size */\\nfunction resizeCanvas(){\\n  const rect = canvas.getBoundingClientRect();\\n  canvas.width = Math.round(rect.width * DPR);\\n  canvas.height = Math.round(rect.height * DPR);\\n  ctx.setTransform(DPR,0,0,DPR,0,0); // use CSS pixels in drawing\\n}\\nwindow.addEventListener('resize', resizeCanvas);\\nresizeCanvas();\\n\\n/* ---------- 控件引用 ---------- */\\nconst btnStart = document.getElementById('btnStart');\\nconst btnStep = document.getElementById('btnStep');\\nconst btnReset = document.getElementById('btnReset');\\nconst btnBurst = document.getElementById('btnBurst');\\nconst btnClear = document.getElementById('btnClear');\\nconst btnSave = document.getElementById('btnSave');\\nconst btnLoad = document.getElementById('btnLoad');\\n\\nconst sGravity = document.getElementById('sGravity');\\nconst sWind = document.getElementById('sWind');\\nconst sVisc = document.getElementById('sVisc');\\nconst sSize = document.getElementById('sSize');\\nconst sSpeed = document.getElementById('sSpeed');\\nconst sRate = document.getElementById('sRate');\\n\\nconst valGravity = document.getElementById('valGravity');\\nconst valWind = document.getElementById('valWind');\\nconst valVisc = document.getElementById('valVisc');\\nconst valSize = document.getElementById('valSize');\\nconst valSpeed = document.getElementById('valSpeed');\\nconst valRate = document.getElementById('valRate');\\n\\nconst chkTrails = document.getElementById('chkTrails');\\nconst chkCollide = document.getElementById('chkCollide');\\nconst chkWrap = document.getElementById('chkWrap');\\nconst selectColor = document.getElementById('selectColor');\\nconst solidColorWrap = document.getElementById('solidColorWrap');\\nconst solidColor = document.getElementById('solidColor');\\n\\nconst fpsEl = document.getElementById('fps');\\nconst countEl = document.getElementById('count');\\nconst modeEl = document.getElementById('mode');\\nconst speedMode = document.getElementById('speedMode');\\n\\n/* ---------- 仿真参数与状态 ---------- */\\nlet running = true;\\nlet lastTime = performance.now();\\nlet accumulator = 0;\\nlet fixedDt = 1/60; // for fixed step\\n\\nconst state = {\\n  gravity: parseFloat(sGravity.value),\\n  wind: parseFloat(sWind.value),\\n  visc: parseFloat(sVisc.value),\\n  radius: parseFloat(sSize.value),\\n  initialSpeed: parseFloat(sSpeed.value),\\n  spawnPerClick: parseInt(sRate.value,10),\\n  trails: chkTrails.checked,\\n  collide: chkCollide.checked,\\n  wrap: chkWrap.checked,\\n  colorMode: selectColor.value,\\n  solidColor: solidColor.value,\\n  particles: []\\n};\\n\\n/* ---------- 粒子类 ---------- */\\nclass Particle {\\n  constructor(x,y,vx,vy,r,color){\\n    this.x = x;\\n    this.y = y;\\n    this.vx = vx;\\n    this.vy = vy;\\n    this.r = r;\\n    this.color = color || randomColor();\\n    this.age = 0;\\n    this.maxAge = 10 + Math.random()*20;\\n  }\\n  step(dt){\\n    // forces: gravity downward, wind horizontal\\n    this.vy += state.gravity * dt * 60; // scale to feel right\\n    this.vx += state.wind * dt * 60;\\n    // viscosity (simple velocity damping)\\n    this.vx *= (1 - state.visc);\\n    this.vy *= (1 - state.visc);\\n    // integrate\\n    this.x += this.vx * dt * 60;\\n    this.y += this.vy * dt * 60;\\n    this.age += dt;\\n  }\\n}\\n\\n/* ---------- 辅助 ---------- */\\nfunction randomColor(){\\n  // return a pastel-like random color\\n  const h = Math.floor(Math.random()*360);\\n  const s = 70 + Math.random()*20;\\n  const l = 50 + Math.random()*10;\\n  return `hsl(${h}deg ${s}% ${l}%)`;\\n}\\n\\nfunction gradientColor(t){\\n  // t in [0,1]\\n  const h = (200 + 160 * t) % 360;\\n  const s = 70;\\n  const l = 60 - 20*t;\\n  return `hsl(${h}deg ${s}% ${l}%)`;\\n}\\n\\n/* ---------- 粒子管理 ---------- */\\nfunction spawnParticle(x,y,angle,speed){\\n  const r = state.radius;\\n  const speedVal = speed ?? (state.initialSpeed + (Math.random()-0.5)*0.5);\\n  const vx = Math.cos(angle) * speedVal;\\n  const vy = Math.sin(angle) * speedVal;\\n  let color;\\n  if(state.colorMode === 'random') color = randomColor();\\n  else if(state.colorMode === 'gradient') color = gradientColor(Math.random());\\n  else color = state.solidColor;\\n  const p = new Particle(x,y,vx,vy,r,color);\\n  state.particles.push(p);\\n  return p;\\n}\\n\\nfunction spawnBurst(x,y,n){\\n  for(let i=0;i<n;i++){\\n    const ang = Math.random()*Math.PI*2;\\n    const sp = state.initialSpeed + Math.random()*3;\\n    spawnParticle(x,y,ang,sp);\\n  }\\n}\\n\\nfunction resetSimulation(){\\n  state.particles.length = 0;\\n  // place a few sample particles\\n  const cx = canvas.clientWidth/2;\\n  const cy = canvas.clientHeight/2;\\n  for(let i=0;i<8;i++){\\n    spawnBurst(cx + (Math.random()-0.5)*200, cy + (Math.random()-0.5)*120, 1);\\n  }\\n}\\n\\n/* ---------- 物理与边界 ---------- */\\nfunction handleBounds(p){\\n  const w = canvas.clientWidth;\\n  const h = canvas.clientHeight;\\n  if(state.wrap){\\n    if(p.x < -p.r) p.x = w + p.r;\\n    if(p.x > w + p.r) p.x = -p.r;\\n    if(p.y < -p.r) p.y = h + p.r;\\n    if(p.y > h + p.r) p.y = -p.r;\\n  } else if(state.collide){\\n    // simple elastic collision with walls\\n    if(p.x - p.r < 0){\\n      p.x = p.r; p.vx = Math.abs(p.vx)*0.8;\\n    }\\n    if(p.x + p.r > w){\\n      p.x = w - p.r; p.vx = -Math.abs(p.vx)*0.8;\\n    }\\n    if(p.y - p.r < 0){\\n      p.y = p.r; p.vy = Math.abs(p.vy)*0.8;\\n    }\\n    if(p.y + p.r > h){\\n      p.y = h - p.r; p.vy = -Math.abs(p.vy)*0.8;\\n    }\\n  } else {\\n    // leave as-is (may go off-screen)\\n  }\\n}\\n\\n/* ---------- 渲染 ---------- */\\nfunction render(){\\n  // Clear or fade for trails\\n  if(state.trails){\\n    // draw semi-transparent rect to create trail fading\\n    ctx.fillStyle = 'rgba(5,8,14,0.15)';\\n    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);\\n  } else {\\n    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);\\n  }\\n\\n  // draw particles\\n  for(const p of state.particles){\\n    ctx.beginPath();\\n    ctx.fillStyle = p.color;\\n    ctx.globalAlpha = Math.max(0.1, 1 - p.age/p.maxAge);\\n    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);\\n    ctx.fill();\\n    // small highlight\\n    ctx.globalAlpha = 0.18;\\n    ctx.fillStyle = '#ffffff';\\n    ctx.beginPath();\\n    ctx.arc(p.x - p.r*0.25, p.y - p.r*0.25, Math.max(0.5,p.r*0.5), 0, Math.PI*2);\\n    ctx.fill();\\n    ctx.globalAlpha = 1;\\n  }\\n}\\n\\n/* ---------- 仿真步进 ---------- */\\nfunction step(dt){\\n  // dt in seconds\\n  const removals = [];\\n  for(let i=0;i<state.particles.length;i++){\\n    const p = state.particles[i];\\n    p.step(dt);\\n    handleBounds(p);\\n    // ageing removal\\n    if(p.age > p.maxAge){\\n      removals.push(i);\\n    }\\n  }\\n  // remove old particles (reverse order)\\n  for(let i=removals.length-1;i>=0;i--){\\n    state.particles.splice(removals[i],1);\\n  }\\n}\\n\\n/* ---------- 主循环 ---------- */\\nlet frames = 0;\\nlet fpsTimer = performance.now();\\n\\nfunction loop(now){\\n  const dtMs = now - lastTime;\\n  lastTime = now;\\n  const dt = Math.min(0.05, dtMs/1000); // clamp for big lags\\n\\n  if(running){\\n    if(speedMode.value === 'live'){\\n      step(dt);\\n    } else {\\n      // fixed step with accumulator\\n      accumulator += dt;\\n      const maxSteps = 5;\\n      let steps = 0;\\n      while(accumulator >= fixedDt && steps < maxSteps){\\n        step(fixedDt);\\n        accumulator -= fixedDt;\\n        steps++;\\n      }\\n    }\\n  }\\n  render();\\n\\n  // update stats every 250ms\\n  frames++;\\n  if(now - fpsTimer >= 250){\\n    const fps = Math.round(frames * 1000 / (now - fpsTimer));\\n    fpsEl.textContent = `FPS: ${fps}`;\\n    countEl.textContent = `粒子数: ${state.particles.length}`;\\n    modeEl.textContent = `模式: ${speedMode.value === 'live' ? '立即更新' : '固定步长'}`;\\n    fpsTimer = now;\\n    frames = 0;\\n  }\\n\\n  requestAnimationFrame(loop);\\n}\\n\\n/* ---------- 事件：控件和交互 ---------- */\\nbtnStart.addEventListener('click', ()=>{\\n  running = !running;\\n  btnStart.textContent = running ? '暂停' : '继续';\\n  btnStart.classList.toggle('btn-primary', !running);\\n  btnStart.setAttribute('aria-pressed', String(!running));\\n});\\n\\nbtnStep.addEventListener('click', ()=>{\\n  step(1/60);\\n  render();\\n});\\n\\nbtnReset.addEventListener('click', ()=>{\\n  state.particles.length = 0;\\n  resetSimulation();\\n});\\n\\nbtnClear.addEventListener('click', ()=>{\\n  state.particles.length = 0;\\n});\\n\\nbtnBurst.addEventListener('click', ()=>{\\n  const cx = canvas.clientWidth/2;\\n  const cy = canvas.clientHeight/2;\\n  spawnBurst(cx,cy,60);\\n});\\n\\nbtnSave.addEventListener('click', ()=>{\\n  const data = {\\n    params: {\\n      gravity: state.gravity,\\n      wind: state.wind,\\n      visc: state.visc,\\n      radius: state.radius,\\n      initialSpeed: state.initialSpeed,\\n      spawnPerClick: state.spawnPerClick,\\n      trails: state.trails,\\n      collide: state.collide,\\n      wrap: state.wrap,\\n      colorMode: state.colorMode,\\n      solidColor: state.solidColor\\n    },\\n    particles: state.particles.map(p=>({x:p.x,y:p.y,vx:p.vx,vy:p.vy,r:p.r,color:p.color,age:p.age,maxAge:p.maxAge}))\\n  };\\n  const text = JSON.stringify(data, null, 2);\\n  // show in a new window for copy\\n  const w = window.open('', '_blank');\\n  w.document.title = '导出 - 粒子状态';\\n  const pre = w.document.createElement('pre');\\n  pre.textContent = text;\\n  w.document.body.appendChild(pre);\\n});\\n\\nbtnLoad.addEventListener('click', ()=>{\\n  const text = prompt('粘贴之前导出的 JSON（覆盖当前）:');\\n  if(!text) return;\\n  try{\\n    const data = JSON.parse(text);\\n    if(data.params){\\n      Object.assign(state, {\\n        gravity: data.params.gravity,\\n        wind: data.params.wind,\\n        visc: data.params.visc,\\n        radius: data.params.radius,\\n        initialSpeed: data.params.initialSpeed,\\n        spawnPerClick: data.params.spawnPerClick,\\n        trails: data.params.trails,\\n        collide: data.params.collide,\\n        wrap: data.params.wrap,\\n        colorMode: data.params.colorMode,\\n        solidColor: data.params.solidColor\\n      });\\n      // update UI to reflect\\n      sGravity.value = state.gravity; sWind.value = state.wind; sVisc.value = state.visc;\\n      sSize.value = state.radius; sSpeed.value = state.initialSpeed; sRate.value = state.spawnPerClick;\\n      chkTrails.checked = state.trails; chkCollide.checked = state.collide; chkWrap.checked = state.wrap;\\n      selectColor.value = state.colorMode; solidColor.value = state.solidColor;\\n      updateValuesDisplay();\\n    }\\n    state.particles.length = 0;\\n    if(Array.isArray(data.particles)){\\n      for(const pp of data.particles){\\n        const p = new Particle(pp.x, pp.y, pp.vx, pp.vy, pp.r, pp.color);\\n        p.age = pp.age || 0; p.maxAge = pp.maxAge || 20;\\n        state.particles.push(p);\\n      }\\n    }\\n  } catch(e){\\n    alert('无效的 JSON：' + e.message);\\n  }\\n});\\n\\n/* sliders change handlers */\\nfunction updateValuesDisplay(){\\n  valGravity.textContent = parseFloat(sGravity.value).toFixed(2);\\n  valWind.textContent = parseFloat(sWind.value).toFixed(2);\\n  valVisc.textContent = parseFloat(sVisc.value).toFixed(3);\\n  valSize.textContent = parseFloat(sSize.value);\\n  valSpeed.textContent = parseFloat(sSpeed.value);\\n  valRate.textContent = parseInt(sRate.value,10);\\n\\n  // update state\\n  state.gravity = parseFloat(sGravity.value);\\n  state.wind = parseFloat(sWind.value);\\n  state.visc = parseFloat(sVisc.value);\\n  state.radius = parseFloat(sSize.value);\\n  state.initialSpeed = parseFloat(sSpeed.value);\\n  state.spawnPerClick = parseInt(sRate.value,10);\\n  state.solidColor = solidColor.value;\\n  state.colorMode = selectColor.value;\\n  state.trails = chkTrails.checked;\\n  state.collide = chkCollide.checked;\\n  state.wrap = chkWrap.checked;\\n}\\n[sGravity,sWind,sVisc,sSize,sSpeed,sRate,chkTrails,chkCollide,chkWrap,selectColor,solidColor].forEach(el=>{\\n  el.addEventListener('input', updateValuesDisplay);\\n});\\n\\n/* change color selection shows color input */\\nselectColor.addEventListener('change', ()=>{\\n  solidColorWrap.style.display = selectColor.value === 'solid' ? 'block':'none';\\n  updateValuesDisplay();\\n});\\n\\n/* ---------- 鼠标交互（点击/拖拽） ---------- */\\nlet dragging = false;\\nlet dragStart = null;\\nlet dragCurrent = null;\\ncanvas.addEventListener('pointerdown', (e)=>{\\n  const rect = canvas.getBoundingClientRect();\\n  dragging = true;\\n  dragStart = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\\n  dragCurrent = {...dragStart};\\n  canvas.setPointerCapture(e.pointerId);\\n  // if user clicks without drag, spawn after pointerup\\n});\\n\\ncanvas.addEventListener('pointermove', (e)=>{\\n  if(!dragging) return;\\n  const rect = canvas.getBoundingClientRect();\\n  dragCurrent = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\\n  // draw preview velocity vector (overlay)\\n  // we'll draw it in a lightweight way by rendering on top after main render\\n  render();\\n  // draw vector\\n  ctx.save();\\n  ctx.strokeStyle = 'rgba(255,255,255,0.7)';\\n  ctx.lineWidth = 2;\\n  ctx.beginPath();\\n  ctx.moveTo(dragStart.x, dragStart.y);\\n  ctx.lineTo(dragCurrent.x, dragCurrent.y);\\n  ctx.stroke();\\n  // small circle at start\\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\\n  ctx.beginPath();\\n  ctx.arc(dragStart.x, dragStart.y, 4, 0, Math.PI*2);\\n  ctx.fill();\\n  ctx.restore();\\n});\\n\\ncanvas.addEventListener('pointerup', (e)=>{\\n  const rect = canvas.getBoundingClientRect();\\n  dragging = false;\\n  const up = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\\n  // compute velocity from drag vector\\n  let vx = 0, vy = 0;\\n  const dx = up.x - dragStart.x, dy = up.y - dragStart.y;\\n  const dist = Math.hypot(dx,dy);\\n  if(dist > 6){\\n    const angle = Math.atan2(dy,dx);\\n    const speed = Math.min(10, dist/10 + state.initialSpeed*0.2);\\n    vx = Math.cos(angle) * speed;\\n    vy = Math.sin(angle) * speed;\\n  } else {\\n    // small random direction\\n    const angle = Math.random()*Math.PI*2;\\n    const speed = state.initialSpeed;\\n    vx = Math.cos(angle) * speed;\\n    vy = Math.sin(angle) * speed;\\n  }\\n  // spawn spawnPerClick particles at click position\\n  const n = state.spawnPerClick;\\n  for(let i=0;i<n;i++){\\n    const jitter = (i - n/2) * 2;\\n    spawnParticle(dragStart.x + jitter, dragStart.y + jitter, Math.atan2(vy, vx) + (Math.random()-0.5)*0.4, Math.hypot(vx,vy)*(0.9 + Math.random()*0.2));\\n  }\\n  render();\\n});\\n\\n/* keyboard shortcuts */\\nwindow.addEventListener('keydown', (e)=>{\\n  if(e.code === 'Space'){\\n    e.preventDefault();\\n    btnStart.click();\\n  } else if(e.key.toLowerCase() === 'c'){\\n    btnClear.click();\\n  } else if(e.key.toLowerCase() === 'b'){\\n    btnBurst.click();\\n  }\\n});\\n\\n/* prevent context menu on canvas for convenience */\\ncanvas.addEventListener('contextmenu', (e)=>e.preventDefault());\\n\\n/* ---------- 初始化 ---------- */\\nupdateValuesDisplay();\\nresetSimulation();\\nrequestAnimationFrame((t)=>{\\n  lastTime = t;\\n  fpsTimer = t;\\n  loop(t);\\n});\\n\\n/* handle Resize HiDPI on load and orientation change */\\nwindow.addEventListener('orientationchange', ()=>{\\n  setTimeout(()=>{ resizeCanvas(); }, 200);\\n});\\n/* keep canvas size correct when CSS changes */\\nconst ro = new ResizeObserver(()=>{ resizeCanvas(); });\\nro.observe(canvas);\\n\\n/* end of script */\\n</script>\",\"css_content\":\":root{\\n    --bg:#0f1724;\\n    --panel:#0b1220cc;\\n    --accent:#4fd1c5;\\n    --muted:#9aa6b2;\\n    --glass: rgba(255,255,255,0.03);\\n  }\\n  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\\\"Helvetica Neue\\\",Arial;color:#e6eef6;background:linear-gradient(180deg,var(--bg),#071023);}\\n  .app{\\n    display:flex;\\n    gap:16px;\\n    padding:18px;\\n    box-sizing:border-box;\\n    align-items:flex-start;\\n    min-height:100vh;\\n  }\\n  .canvas-wrap{\\n    flex:1 1 70%;\\n    min-width:360px;\\n    border-radius:12px;\\n    overflow:hidden;\\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\\n    box-shadow: 0 6px 30px rgba(2,6,23,0.7), inset 0 1px 0 rgba(255,255,255,0.02);\\n    position:relative;\\n    padding:12px;\\n  }\\n  canvas{\\n    width:100%;\\n    height:70vh;\\n    display:block;\\n    border-radius:8px;\\n    background: radial-gradient(circle at 20% 10%, rgba(255,255,255,0.02), transparent 10%),\\n                linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03));\\n    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\\n  }\\n  .info-bar{\\n    display:flex;\\n    gap:12px;\\n    align-items:center;\\n    margin-top:10px;\\n    color:var(--muted);\\n    font-size:13px;\\n  }\\n  .panel{\\n    width:360px;\\n    background:var(--panel);\\n    border-radius:12px;\\n    padding:14px;\\n    box-shadow: 0 8px 30px rgba(2,6,23,0.6);\\n    color:#e6eef6;\\n    flex-shrink:0;\\n    max-height:calc(100vh - 36px);\\n    overflow:auto;\\n  }\\n  h2{margin:0 0 10px 0;font-size:16px}\\n  .section{margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid rgba(255,255,255,0.03)}\\n  .controls{display:flex;flex-wrap:wrap;gap:8px}\\n  button{\\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\\n    border:1px solid rgba(255,255,255,0.04);\\n    color:var(--accent);\\n    padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;\\n    transition:transform .08s ease,box-shadow .08s;\\n  }\\n  button:active{transform:translateY(1px)}\\n  .btn-primary{background:linear-gradient(90deg,#0ea5a8,#38bdf8); color:#012; border:none; box-shadow:0 6px 18px rgba(14,165,168,0.12);}\\n  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px;}\\n  .row{display:flex;align-items:center;gap:8px}\\n  .full{width:100%}\\n  input[type=\\\"range\\\"]{width:100%}\\n  .control-item{margin-bottom:10px}\\n  .small{font-size:12px;color:var(--muted)}\\n  .stat{background:var(--glass);padding:8px 10px;border-radius:8px;color:var(--muted);font-size:13px}\\n  .footer-note{font-size:12px;color:var(--muted);margin-top:10px}\\n  .kbd{background:rgba(255,255,255,0.04);padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}\\n  .color-input{height:34px;padding:0;border-radius:6px;border:none;cursor:pointer}\\n  .toggle{display:flex;align-items:center;gap:8px}\\n  .hint{font-size:12px;color:var(--muted);margin-top:6px}\\n  a{color:var(--accent)}\\n  /* Make scrollbars subtle */\\n  .panel::-webkit-scrollbar{width:10px;height:10px}\\n  .panel::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.03);border-radius:8px}\\n  @media (max-width:900px){\\n    .app{flex-direction:column;padding:12px}\\n    .canvas-wrap{order:2}\\n    .panel{order:1;width:100%}\\n    canvas{height:50vh}\\n  }\",\"js_content\":\"/*\\n  交互式粒子系统\\n  - 支持：开始/暂停、单步、重置、爆发、清空\\n  - 参数实时控制：重力、风、阻尼、粒子大小、初速度、生成数量\\n  - 显示选项：尾迹、碰撞/包裹、颜色模式\\n  - 鼠标交互：点击生成；拖拽设置初速度\\n  - 导出/导入当前状态（JSON）\\n  - 无外部依赖，兼容现代浏览器\\n*/\\n\\n/* ---------- 全局与帮助函数 ---------- */\\nconst canvas = document.getElementById('canvas');\\nconst ctx = canvas.getContext('2d', { alpha: true });\\nlet DPR = Math.max(1, window.devicePixelRatio || 1);\\n\\n/* resize canvas to displayed size */\\nfunction resizeCanvas(){\\n  const rect = canvas.getBoundingClientRect();\\n  canvas.width = Math.round(rect.width * DPR);\\n  canvas.height = Math.round(rect.height * DPR);\\n  ctx.setTransform(DPR,0,0,DPR,0,0); // use CSS pixels in drawing\\n}\\nwindow.addEventListener('resize', resizeCanvas);\\nresizeCanvas();\\n\\n/* ---------- 控件引用 ---------- */\\nconst btnStart = document.getElementById('btnStart');\\nconst btnStep = document.getElementById('btnStep');\\nconst btnReset = document.getElementById('btnReset');\\nconst btnBurst = document.getElementById('btnBurst');\\nconst btnClear = document.getElementById('btnClear');\\nconst btnSave = document.getElementById('btnSave');\\nconst btnLoad = document.getElementById('btnLoad');\\n\\nconst sGravity = document.getElementById('sGravity');\\nconst sWind = document.getElementById('sWind');\\nconst sVisc = document.getElementById('sVisc');\\nconst sSize = document.getElementById('sSize');\\nconst sSpeed = document.getElementById('sSpeed');\\nconst sRate = document.getElementById('sRate');\\n\\nconst valGravity = document.getElementById('valGravity');\\nconst valWind = document.getElementById('valWind');\\nconst valVisc = document.getElementById('valVisc');\\nconst valSize = document.getElementById('valSize');\\nconst valSpeed = document.getElementById('valSpeed');\\nconst valRate = document.getElementById('valRate');\\n\\nconst chkTrails = document.getElementById('chkTrails');\\nconst chkCollide = document.getElementById('chkCollide');\\nconst chkWrap = document.getElementById('chkWrap');\\nconst selectColor = document.getElementById('selectColor');\\nconst solidColorWrap = document.getElementById('solidColorWrap');\\nconst solidColor = document.getElementById('solidColor');\\n\\nconst fpsEl = document.getElementById('fps');\\nconst countEl = document.getElementById('count');\\nconst modeEl = document.getElementById('mode');\\nconst speedMode = document.getElementById('speedMode');\\n\\n/* ---------- 仿真参数与状态 ---------- */\\nlet running = true;\\nlet lastTime = performance.now();\\nlet accumulator = 0;\\nlet fixedDt = 1/60; // for fixed step\\n\\nconst state = {\\n  gravity: parseFloat(sGravity.value),\\n  wind: parseFloat(sWind.value),\\n  visc: parseFloat(sVisc.value),\\n  radius: parseFloat(sSize.value),\\n  initialSpeed: parseFloat(sSpeed.value),\\n  spawnPerClick: parseInt(sRate.value,10),\\n  trails: chkTrails.checked,\\n  collide: chkCollide.checked,\\n  wrap: chkWrap.checked,\\n  colorMode: selectColor.value,\\n  solidColor: solidColor.value,\\n  particles: []\\n};\\n\\n/* ---------- 粒子类 ---------- */\\nclass Particle {\\n  constructor(x,y,vx,vy,r,color){\\n    this.x = x;\\n    this.y = y;\\n    this.vx = vx;\\n    this.vy = vy;\\n    this.r = r;\\n    this.color = color || randomColor();\\n    this.age = 0;\\n    this.maxAge = 10 + Math.random()*20;\\n  }\\n  step(dt){\\n    // forces: gravity downward, wind horizontal\\n    this.vy += state.gravity * dt * 60; // scale to feel right\\n    this.vx += state.wind * dt * 60;\\n    // viscosity (simple velocity damping)\\n    this.vx *= (1 - state.visc);\\n    this.vy *= (1 - state.visc);\\n    // integrate\\n    this.x += this.vx * dt * 60;\\n    this.y += this.vy * dt * 60;\\n    this.age += dt;\\n  }\\n}\\n\\n/* ---------- 辅助 ---------- */\\nfunction randomColor(){\\n  // return a pastel-like random color\\n  const h = Math.floor(Math.random()*360);\\n  const s = 70 + Math.random()*20;\\n  const l = 50 + Math.random()*10;\\n  return `hsl(${h}deg ${s}% ${l}%)`;\\n}\\n\\nfunction gradientColor(t){\\n  // t in [0,1]\\n  const h = (200 + 160 * t) % 360;\\n  const s = 70;\\n  const l = 60 - 20*t;\\n  return `hsl(${h}deg ${s}% ${l}%)`;\\n}\\n\\n/* ---------- 粒子管理 ---------- */\\nfunction spawnParticle(x,y,angle,speed){\\n  const r = state.radius;\\n  const speedVal = speed ?? (state.initialSpeed + (Math.random()-0.5)*0.5);\\n  const vx = Math.cos(angle) * speedVal;\\n  const vy = Math.sin(angle) * speedVal;\\n  let color;\\n  if(state.colorMode === 'random') color = randomColor();\\n  else if(state.colorMode === 'gradient') color = gradientColor(Math.random());\\n  else color = state.solidColor;\\n  const p = new Particle(x,y,vx,vy,r,color);\\n  state.particles.push(p);\\n  return p;\\n}\\n\\nfunction spawnBurst(x,y,n){\\n  for(let i=0;i<n;i++){\\n    const ang = Math.random()*Math.PI*2;\\n    const sp = state.initialSpeed + Math.random()*3;\\n    spawnParticle(x,y,ang,sp);\\n  }\\n}\\n\\nfunction resetSimulation(){\\n  state.particles.length = 0;\\n  // place a few sample particles\\n  const cx = canvas.clientWidth/2;\\n  const cy = canvas.clientHeight/2;\\n  for(let i=0;i<8;i++){\\n    spawnBurst(cx + (Math.random()-0.5)*200, cy + (Math.random()-0.5)*120, 1);\\n  }\\n}\\n\\n/* ---------- 物理与边界 ---------- */\\nfunction handleBounds(p){\\n  const w = canvas.clientWidth;\\n  const h = canvas.clientHeight;\\n  if(state.wrap){\\n    if(p.x < -p.r) p.x = w + p.r;\\n    if(p.x > w + p.r) p.x = -p.r;\\n    if(p.y < -p.r) p.y = h + p.r;\\n    if(p.y > h + p.r) p.y = -p.r;\\n  } else if(state.collide){\\n    // simple elastic collision with walls\\n    if(p.x - p.r < 0){\\n      p.x = p.r; p.vx = Math.abs(p.vx)*0.8;\\n    }\\n    if(p.x + p.r > w){\\n      p.x = w - p.r; p.vx = -Math.abs(p.vx)*0.8;\\n    }\\n    if(p.y - p.r < 0){\\n      p.y = p.r; p.vy = Math.abs(p.vy)*0.8;\\n    }\\n    if(p.y + p.r > h){\\n      p.y = h - p.r; p.vy = -Math.abs(p.vy)*0.8;\\n    }\\n  } else {\\n    // leave as-is (may go off-screen)\\n  }\\n}\\n\\n/* ---------- 渲染 ---------- */\\nfunction render(){\\n  // Clear or fade for trails\\n  if(state.trails){\\n    // draw semi-transparent rect to create trail fading\\n    ctx.fillStyle = 'rgba(5,8,14,0.15)';\\n    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);\\n  } else {\\n    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);\\n  }\\n\\n  // draw particles\\n  for(const p of state.particles){\\n    ctx.beginPath();\\n    ctx.fillStyle = p.color;\\n    ctx.globalAlpha = Math.max(0.1, 1 - p.age/p.maxAge);\\n    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);\\n    ctx.fill();\\n    // small highlight\\n    ctx.globalAlpha = 0.18;\\n    ctx.fillStyle = '#ffffff';\\n    ctx.beginPath();\\n    ctx.arc(p.x - p.r*0.25, p.y - p.r*0.25, Math.max(0.5,p.r*0.5), 0, Math.PI*2);\\n    ctx.fill();\\n    ctx.globalAlpha = 1;\\n  }\\n}\\n\\n/* ---------- 仿真步进 ---------- */\\nfunction step(dt){\\n  // dt in seconds\\n  const removals = [];\\n  for(let i=0;i<state.particles.length;i++){\\n    const p = state.particles[i];\\n    p.step(dt);\\n    handleBounds(p);\\n    // ageing removal\\n    if(p.age > p.maxAge){\\n      removals.push(i);\\n    }\\n  }\\n  // remove old particles (reverse order)\\n  for(let i=removals.length-1;i>=0;i--){\\n    state.particles.splice(removals[i],1);\\n  }\\n}\\n\\n/* ---------- 主循环 ---------- */\\nlet frames = 0;\\nlet fpsTimer = performance.now();\\n\\nfunction loop(now){\\n  const dtMs = now - lastTime;\\n  lastTime = now;\\n  const dt = Math.min(0.05, dtMs/1000); // clamp for big lags\\n\\n  if(running){\\n    if(speedMode.value === 'live'){\\n      step(dt);\\n    } else {\\n      // fixed step with accumulator\\n      accumulator += dt;\\n      const maxSteps = 5;\\n      let steps = 0;\\n      while(accumulator >= fixedDt && steps < maxSteps){\\n        step(fixedDt);\\n        accumulator -= fixedDt;\\n        steps++;\\n      }\\n    }\\n  }\\n  render();\\n\\n  // update stats every 250ms\\n  frames++;\\n  if(now - fpsTimer >= 250){\\n    const fps = Math.round(frames * 1000 / (now - fpsTimer));\\n    fpsEl.textContent = `FPS: ${fps}`;\\n    countEl.textContent = `粒子数: ${state.particles.length}`;\\n    modeEl.textContent = `模式: ${speedMode.value === 'live' ? '立即更新' : '固定步长'}`;\\n    fpsTimer = now;\\n    frames = 0;\\n  }\\n\\n  requestAnimationFrame(loop);\\n}\\n\\n/* ---------- 事件：控件和交互 ---------- */\\nbtnStart.addEventListener('click', ()=>{\\n  running = !running;\\n  btnStart.textContent = running ? '暂停' : '继续';\\n  btnStart.classList.toggle('btn-primary', !running);\\n  btnStart.setAttribute('aria-pressed', String(!running));\\n});\\n\\nbtnStep.addEventListener('click', ()=>{\\n  step(1/60);\\n  render();\\n});\\n\\nbtnReset.addEventListener('click', ()=>{\\n  state.particles.length = 0;\\n  resetSimulation();\\n});\\n\\nbtnClear.addEventListener('click', ()=>{\\n  state.particles.length = 0;\\n});\\n\\nbtnBurst.addEventListener('click', ()=>{\\n  const cx = canvas.clientWidth/2;\\n  const cy = canvas.clientHeight/2;\\n  spawnBurst(cx,cy,60);\\n});\\n\\nbtnSave.addEventListener('click', ()=>{\\n  const data = {\\n    params: {\\n      gravity: state.gravity,\\n      wind: state.wind,\\n      visc: state.visc,\\n      radius: state.radius,\\n      initialSpeed: state.initialSpeed,\\n      spawnPerClick: state.spawnPerClick,\\n      trails: state.trails,\\n      collide: state.collide,\\n      wrap: state.wrap,\\n      colorMode: state.colorMode,\\n      solidColor: state.solidColor\\n    },\\n    particles: state.particles.map(p=>({x:p.x,y:p.y,vx:p.vx,vy:p.vy,r:p.r,color:p.color,age:p.age,maxAge:p.maxAge}))\\n  };\\n  const text = JSON.stringify(data, null, 2);\\n  // show in a new window for copy\\n  const w = window.open('', '_blank');\\n  w.document.title = '导出 - 粒子状态';\\n  const pre = w.document.createElement('pre');\\n  pre.textContent = text;\\n  w.document.body.appendChild(pre);\\n});\\n\\nbtnLoad.addEventListener('click', ()=>{\\n  const text = prompt('粘贴之前导出的 JSON（覆盖当前）:');\\n  if(!text) return;\\n  try{\\n    const data = JSON.parse(text);\\n    if(data.params){\\n      Object.assign(state, {\\n        gravity: data.params.gravity,\\n        wind: data.params.wind,\\n        visc: data.params.visc,\\n        radius: data.params.radius,\\n        initialSpeed: data.params.initialSpeed,\\n        spawnPerClick: data.params.spawnPerClick,\\n        trails: data.params.trails,\\n        collide: data.params.collide,\\n        wrap: data.params.wrap,\\n        colorMode: data.params.colorMode,\\n        solidColor: data.params.solidColor\\n      });\\n      // update UI to reflect\\n      sGravity.value = state.gravity; sWind.value = state.wind; sVisc.value = state.visc;\\n      sSize.value = state.radius; sSpeed.value = state.initialSpeed; sRate.value = state.spawnPerClick;\\n      chkTrails.checked = state.trails; chkCollide.checked = state.collide; chkWrap.checked = state.wrap;\\n      selectColor.value = state.colorMode; solidColor.value = state.solidColor;\\n      updateValuesDisplay();\\n    }\\n    state.particles.length = 0;\\n    if(Array.isArray(data.particles)){\\n      for(const pp of data.particles){\\n        const p = new Particle(pp.x, pp.y, pp.vx, pp.vy, pp.r, pp.color);\\n        p.age = pp.age || 0; p.maxAge = pp.maxAge || 20;\\n        state.particles.push(p);\\n      }\\n    }\\n  } catch(e){\\n    alert('无效的 JSON：' + e.message);\\n  }\\n});\\n\\n/* sliders change handlers */\\nfunction updateValuesDisplay(){\\n  valGravity.textContent = parseFloat(sGravity.value).toFixed(2);\\n  valWind.textContent = parseFloat(sWind.value).toFixed(2);\\n  valVisc.textContent = parseFloat(sVisc.value).toFixed(3);\\n  valSize.textContent = parseFloat(sSize.value);\\n  valSpeed.textContent = parseFloat(sSpeed.value);\\n  valRate.textContent = parseInt(sRate.value,10);\\n\\n  // update state\\n  state.gravity = parseFloat(sGravity.value);\\n  state.wind = parseFloat(sWind.value);\\n  state.visc = parseFloat(sVisc.value);\\n  state.radius = parseFloat(sSize.value);\\n  state.initialSpeed = parseFloat(sSpeed.value);\\n  state.spawnPerClick = parseInt(sRate.value,10);\\n  state.solidColor = solidColor.value;\\n  state.colorMode = selectColor.value;\\n  state.trails = chkTrails.checked;\\n  state.collide = chkCollide.checked;\\n  state.wrap = chkWrap.checked;\\n}\\n[sGravity,sWind,sVisc,sSize,sSpeed,sRate,chkTrails,chkCollide,chkWrap,selectColor,solidColor].forEach(el=>{\\n  el.addEventListener('input', updateValuesDisplay);\\n});\\n\\n/* change color selection shows color input */\\nselectColor.addEventListener('change', ()=>{\\n  solidColorWrap.style.display = selectColor.value === 'solid' ? 'block':'none';\\n  updateValuesDisplay();\\n});\\n\\n/* ---------- 鼠标交互（点击/拖拽） ---------- */\\nlet dragging = false;\\nlet dragStart = null;\\nlet dragCurrent = null;\\ncanvas.addEventListener('pointerdown', (e)=>{\\n  const rect = canvas.getBoundingClientRect();\\n  dragging = true;\\n  dragStart = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\\n  dragCurrent = {...dragStart};\\n  canvas.setPointerCapture(e.pointerId);\\n  // if user clicks without drag, spawn after pointerup\\n});\\n\\ncanvas.addEventListener('pointermove', (e)=>{\\n  if(!dragging) return;\\n  const rect = canvas.getBoundingClientRect();\\n  dragCurrent = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\\n  // draw preview velocity vector (overlay)\\n  // we'll draw it in a lightweight way by rendering on top after main render\\n  render();\\n  // draw vector\\n  ctx.save();\\n  ctx.strokeStyle = 'rgba(255,255,255,0.7)';\\n  ctx.lineWidth = 2;\\n  ctx.beginPath();\\n  ctx.moveTo(dragStart.x, dragStart.y);\\n  ctx.lineTo(dragCurrent.x, dragCurrent.y);\\n  ctx.stroke();\\n  // small circle at start\\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\\n  ctx.beginPath();\\n  ctx.arc(dragStart.x, dragStart.y, 4, 0, Math.PI*2);\\n  ctx.fill();\\n  ctx.restore();\\n});\\n\\ncanvas.addEventListener('pointerup', (e)=>{\\n  const rect = canvas.getBoundingClientRect();\\n  dragging = false;\\n  const up = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\\n  // compute velocity from drag vector\\n  let vx = 0, vy = 0;\\n  const dx = up.x - dragStart.x, dy = up.y - dragStart.y;\\n  const dist = Math.hypot(dx,dy);\\n  if(dist > 6){\\n    const angle = Math.atan2(dy,dx);\\n    const speed = Math.min(10, dist/10 + state.initialSpeed*0.2);\\n    vx = Math.cos(angle) * speed;\\n    vy = Math.sin(angle) * speed;\\n  } else {\\n    // small random direction\\n    const angle = Math.random()*Math.PI*2;\\n    const speed = state.initialSpeed;\\n    vx = Math.cos(angle) * speed;\\n    vy = Math.sin(angle) * speed;\\n  }\\n  // spawn spawnPerClick particles at click position\\n  const n = state.spawnPerClick;\\n  for(let i=0;i<n;i++){\\n    const jitter = (i - n/2) * 2;\\n    spawnParticle(dragStart.x + jitter, dragStart.y + jitter, Math.atan2(vy, vx) + (Math.random()-0.5)*0.4, Math.hypot(vx,vy)*(0.9 + Math.random()*0.2));\\n  }\\n  render();\\n});\\n\\n/* keyboard shortcuts */\\nwindow.addEventListener('keydown', (e)=>{\\n  if(e.code === 'Space'){\\n    e.preventDefault();\\n    btnStart.click();\\n  } else if(e.key.toLowerCase() === 'c'){\\n    btnClear.click();\\n  } else if(e.key.toLowerCase() === 'b'){\\n    btnBurst.click();\\n  }\\n});\\n\\n/* prevent context menu on canvas for convenience */\\ncanvas.addEventListener('contextmenu', (e)=>e.preventDefault());\\n\\n/* ---------- 初始化 ---------- */\\nupdateValuesDisplay();\\nresetSimulation();\\nrequestAnimationFrame((t)=>{\\n  lastTime = t;\\n  fpsTimer = t;\\n  loop(t);\\n});\\n\\n/* handle Resize HiDPI on load and orientation change */\\nwindow.addEventListener('orientationchange', ()=>{\\n  setTimeout(()=>{ resizeCanvas(); }, 200);\\n});\\n/* keep canvas size correct when CSS changes */\\nconst ro = new ResizeObserver(()=>{ resizeCanvas(); });\\nro.observe(canvas);\\n\\n/* end of script */\",\"parameters\":[],\"status\":\"success\"},\"attempts\":2}"
          }
        },
        {
          "stage": "data_analysis",
          "timestamp": "2025-08-09T12:17:15.542Z",
          "dataType": "object",
          "keys": [
            "success",
            "data",
            "attempts"
          ],
          "data": {
            "success": true,
            "data": {
              "experiment_id": "92f59345-9bc7-4b25-88d9-9c53f9c9559c",
              "title": "交互式粒子系统演示（按钮、滑块、动画）",
              "description": "摘要\n- 未能找到与请求精确匹配的 Wikipedia 页面（没有可检索到的特定条目）。因此下面的演示基于常见的人机交互与动画实现原则：按钮用于触发离散动作，滑块用于调节连续参数，动画由 requestAnimationFrame 驱动，状态管理清晰、可读，便于交互与可访问性。\n- 本示例演示一个包含多个交互元素的复杂系统：粒子仿真（可视化动画），包含按钮、滑块、开关、颜色选择器和鼠标拖拽交互，支持实时参数调整、暂停/单步/重置与可视化选项（尾迹、碰撞、包裹等）。代码为自包含 HTML + JavaScript + CSS，无外部依赖，注释完整，便于学习和扩展。\n\n完整 HTML 代码：",
              "html_content": "<div class=\"app\" id=\"app\">\n  <div class=\"canvas-wrap\" aria-live=\"polite\">\n    <canvas id=\"canvas\" tabindex=\"0\" aria-label=\"粒子动画画布\"></canvas>\n    <div class=\"info-bar\" role=\"status\" aria-atomic=\"true\">\n      <div class=\"stat\" id=\"fps\">FPS: --</div>\n      <div class=\"stat\" id=\"count\">粒子数: --</div>\n      <div class=\"stat\" id=\"mode\">模式: 立即更新</div>\n      <div style=\"margin-left:auto;color:var(--muted);font-size:13px\">按空格暂停/继续 • C 清空 • B 爆发</div>\n    </div>\n    <div class=\"footer-note small\">在画布上点击生成粒子；拖拽可设置初速度向量；使用“爆发”生成大量粒子。</div>\n  </div>\n\n  <aside class=\"panel\" role=\"region\" aria-label=\"控制面板\">\n    <h2>控制面板</h2>\n\n    <div class=\"section\">\n      <div class=\"controls\">\n        <button id=\"btnStart\" class=\"btn-primary\" aria-pressed=\"true\">暂停</button>\n        <button id=\"btnStep\">单步</button>\n        <button id=\"btnReset\">重置</button>\n        <button id=\"btnBurst\">爆发（B）</button>\n        <button id=\"btnClear\">清空（C）</button>\n      </div>\n      <div class=\"hint\">交互提示：点画布生成一个粒子；拖动设置初速度；长按爆发连续生成。</div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">运动参数</h3>\n      <div class=\"control-item\">\n        <label for=\"sGravity\">重力 (Gravity): <span id=\"valGravity\">0.12</span></label>\n        <input id=\"sGravity\" type=\"range\" min=\"-1\" max=\"1\" step=\"0.01\" value=\"0.12\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sWind\">风 (Wind): <span id=\"valWind\">0.00</span></label>\n        <input id=\"sWind\" type=\"range\" min=\"-1\" max=\"1\" step=\"0.01\" value=\"0.00\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sVisc\">阻尼 (Viscosity): <span id=\"valVisc\">0.01</span></label>\n        <input id=\"sVisc\" type=\"range\" min=\"0\" max=\"0.1\" step=\"0.001\" value=\"0.01\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sSize\">粒子大小 (radius): <span id=\"valSize\">4</span></label>\n        <input id=\"sSize\" type=\"range\" min=\"1\" max=\"12\" step=\"1\" value=\"4\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sSpeed\">初始速度 (speed): <span id=\"valSpeed\">2.5</span></label>\n        <input id=\"sSpeed\" type=\"range\" min=\"0\" max=\"8\" step=\"0.1\" value=\"2.5\" />\n      </div>\n      <div class=\"control-item\">\n        <label for=\"sRate\">每次生成数量 (spawn per click): <span id=\"valRate\">1</span></label>\n        <input id=\"sRate\" type=\"range\" min=\"1\" max=\"30\" step=\"1\" value=\"1\" />\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">行为与显示</h3>\n      <div class=\"control-item toggle\">\n        <input id=\"chkTrails\" type=\"checkbox\" checked />\n        <label for=\"chkTrails\">尾迹 (Trails)</label>\n      </div>\n      <div class=\"control-item toggle\">\n        <input id=\"chkCollide\" type=\"checkbox\" />\n        <label for=\"chkCollide\">边界弹性碰撞 (Bounce)</label>\n      </div>\n      <div class=\"control-item toggle\">\n        <input id=\"chkWrap\" type=\"checkbox\" />\n        <label for=\"chkWrap\">穿越边界 (Wrap around)</label>\n      </div>\n      <div class=\"control-item\">\n        <label for=\"selectColor\">颜色模式</label>\n        <select id=\"selectColor\" class=\"full\" aria-label=\"颜色模式选择\">\n          <option value=\"random\">随机色</option>\n          <option value=\"gradient\" selected>渐变色</option>\n          <option value=\"solid\">单一颜色</option>\n        </select>\n      </div>\n      <div class=\"control-item\" id=\"solidColorWrap\" style=\"display:none\">\n        <label for=\"solidColor\">选择颜色</label>\n        <input id=\"solidColor\" class=\"color-input\" type=\"color\" value=\"#3ee5c1\" />\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">交互与导出</h3>\n      <div class=\"control-item\">\n        <button id=\"btnSave\">导出状态 (JSON)</button>\n        <button id=\"btnLoad\">导入状态 (粘贴 JSON)</button>\n      </div>\n      <div class=\"control-item\">\n        <label for=\"speedMode\">渲染模式</label>\n        <select id=\"speedMode\" class=\"full\">\n          <option value=\"live\">立即更新（默认）</option>\n          <option value=\"fixed\">固定步长（更稳定）</option>\n        </select>\n      </div>\n      <div class=\"hint\">可保存当前粒子位置与参数为 JSON，之后可粘贴恢复。</div>\n    </div>\n\n    <div class=\"section\">\n      <h3 style=\"margin:6px 0 8px 0\">快捷键</h3>\n      <div class=\"small\">\n        <div><span class=\"kbd\">Space</span> 暂停/继续</div>\n        <div><span class=\"kbd\">C</span> 清空</div>\n        <div><span class=\"kbd\">B</span> 爆发</div>\n      </div>\n    </div>\n\n    <div style=\"height:30px\"></div>\n  </aside>\n</div>\n\n<script>\n/*\n  交互式粒子系统\n  - 支持：开始/暂停、单步、重置、爆发、清空\n  - 参数实时控制：重力、风、阻尼、粒子大小、初速度、生成数量\n  - 显示选项：尾迹、碰撞/包裹、颜色模式\n  - 鼠标交互：点击生成；拖拽设置初速度\n  - 导出/导入当前状态（JSON）\n  - 无外部依赖，兼容现代浏览器\n*/\n\n/* ---------- 全局与帮助函数 ---------- */\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d', { alpha: true });\nlet DPR = Math.max(1, window.devicePixelRatio || 1);\n\n/* resize canvas to displayed size */\nfunction resizeCanvas(){\n  const rect = canvas.getBoundingClientRect();\n  canvas.width = Math.round(rect.width * DPR);\n  canvas.height = Math.round(rect.height * DPR);\n  ctx.setTransform(DPR,0,0,DPR,0,0); // use CSS pixels in drawing\n}\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\n\n/* ---------- 控件引用 ---------- */\nconst btnStart = document.getElementById('btnStart');\nconst btnStep = document.getElementById('btnStep');\nconst btnReset = document.getElementById('btnReset');\nconst btnBurst = document.getElementById('btnBurst');\nconst btnClear = document.getElementById('btnClear');\nconst btnSave = document.getElementById('btnSave');\nconst btnLoad = document.getElementById('btnLoad');\n\nconst sGravity = document.getElementById('sGravity');\nconst sWind = document.getElementById('sWind');\nconst sVisc = document.getElementById('sVisc');\nconst sSize = document.getElementById('sSize');\nconst sSpeed = document.getElementById('sSpeed');\nconst sRate = document.getElementById('sRate');\n\nconst valGravity = document.getElementById('valGravity');\nconst valWind = document.getElementById('valWind');\nconst valVisc = document.getElementById('valVisc');\nconst valSize = document.getElementById('valSize');\nconst valSpeed = document.getElementById('valSpeed');\nconst valRate = document.getElementById('valRate');\n\nconst chkTrails = document.getElementById('chkTrails');\nconst chkCollide = document.getElementById('chkCollide');\nconst chkWrap = document.getElementById('chkWrap');\nconst selectColor = document.getElementById('selectColor');\nconst solidColorWrap = document.getElementById('solidColorWrap');\nconst solidColor = document.getElementById('solidColor');\n\nconst fpsEl = document.getElementById('fps');\nconst countEl = document.getElementById('count');\nconst modeEl = document.getElementById('mode');\nconst speedMode = document.getElementById('speedMode');\n\n/* ---------- 仿真参数与状态 ---------- */\nlet running = true;\nlet lastTime = performance.now();\nlet accumulator = 0;\nlet fixedDt = 1/60; // for fixed step\n\nconst state = {\n  gravity: parseFloat(sGravity.value),\n  wind: parseFloat(sWind.value),\n  visc: parseFloat(sVisc.value),\n  radius: parseFloat(sSize.value),\n  initialSpeed: parseFloat(sSpeed.value),\n  spawnPerClick: parseInt(sRate.value,10),\n  trails: chkTrails.checked,\n  collide: chkCollide.checked,\n  wrap: chkWrap.checked,\n  colorMode: selectColor.value,\n  solidColor: solidColor.value,\n  particles: []\n};\n\n/* ---------- 粒子类 ---------- */\nclass Particle {\n  constructor(x,y,vx,vy,r,color){\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.r = r;\n    this.color = color || randomColor();\n    this.age = 0;\n    this.maxAge = 10 + Math.random()*20;\n  }\n  step(dt){\n    // forces: gravity downward, wind horizontal\n    this.vy += state.gravity * dt * 60; // scale to feel right\n    this.vx += state.wind * dt * 60;\n    // viscosity (simple velocity damping)\n    this.vx *= (1 - state.visc);\n    this.vy *= (1 - state.visc);\n    // integrate\n    this.x += this.vx * dt * 60;\n    this.y += this.vy * dt * 60;\n    this.age += dt;\n  }\n}\n\n/* ---------- 辅助 ---------- */\nfunction randomColor(){\n  // return a pastel-like random color\n  const h = Math.floor(Math.random()*360);\n  const s = 70 + Math.random()*20;\n  const l = 50 + Math.random()*10;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\nfunction gradientColor(t){\n  // t in [0,1]\n  const h = (200 + 160 * t) % 360;\n  const s = 70;\n  const l = 60 - 20*t;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\n/* ---------- 粒子管理 ---------- */\nfunction spawnParticle(x,y,angle,speed){\n  const r = state.radius;\n  const speedVal = speed ?? (state.initialSpeed + (Math.random()-0.5)*0.5);\n  const vx = Math.cos(angle) * speedVal;\n  const vy = Math.sin(angle) * speedVal;\n  let color;\n  if(state.colorMode === 'random') color = randomColor();\n  else if(state.colorMode === 'gradient') color = gradientColor(Math.random());\n  else color = state.solidColor;\n  const p = new Particle(x,y,vx,vy,r,color);\n  state.particles.push(p);\n  return p;\n}\n\nfunction spawnBurst(x,y,n){\n  for(let i=0;i<n;i++){\n    const ang = Math.random()*Math.PI*2;\n    const sp = state.initialSpeed + Math.random()*3;\n    spawnParticle(x,y,ang,sp);\n  }\n}\n\nfunction resetSimulation(){\n  state.particles.length = 0;\n  // place a few sample particles\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  for(let i=0;i<8;i++){\n    spawnBurst(cx + (Math.random()-0.5)*200, cy + (Math.random()-0.5)*120, 1);\n  }\n}\n\n/* ---------- 物理与边界 ---------- */\nfunction handleBounds(p){\n  const w = canvas.clientWidth;\n  const h = canvas.clientHeight;\n  if(state.wrap){\n    if(p.x < -p.r) p.x = w + p.r;\n    if(p.x > w + p.r) p.x = -p.r;\n    if(p.y < -p.r) p.y = h + p.r;\n    if(p.y > h + p.r) p.y = -p.r;\n  } else if(state.collide){\n    // simple elastic collision with walls\n    if(p.x - p.r < 0){\n      p.x = p.r; p.vx = Math.abs(p.vx)*0.8;\n    }\n    if(p.x + p.r > w){\n      p.x = w - p.r; p.vx = -Math.abs(p.vx)*0.8;\n    }\n    if(p.y - p.r < 0){\n      p.y = p.r; p.vy = Math.abs(p.vy)*0.8;\n    }\n    if(p.y + p.r > h){\n      p.y = h - p.r; p.vy = -Math.abs(p.vy)*0.8;\n    }\n  } else {\n    // leave as-is (may go off-screen)\n  }\n}\n\n/* ---------- 渲染 ---------- */\nfunction render(){\n  // Clear or fade for trails\n  if(state.trails){\n    // draw semi-transparent rect to create trail fading\n    ctx.fillStyle = 'rgba(5,8,14,0.15)';\n    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  } else {\n    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  }\n\n  // draw particles\n  for(const p of state.particles){\n    ctx.beginPath();\n    ctx.fillStyle = p.color;\n    ctx.globalAlpha = Math.max(0.1, 1 - p.age/p.maxAge);\n    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);\n    ctx.fill();\n    // small highlight\n    ctx.globalAlpha = 0.18;\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(p.x - p.r*0.25, p.y - p.r*0.25, Math.max(0.5,p.r*0.5), 0, Math.PI*2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n  }\n}\n\n/* ---------- 仿真步进 ---------- */\nfunction step(dt){\n  // dt in seconds\n  const removals = [];\n  for(let i=0;i<state.particles.length;i++){\n    const p = state.particles[i];\n    p.step(dt);\n    handleBounds(p);\n    // ageing removal\n    if(p.age > p.maxAge){\n      removals.push(i);\n    }\n  }\n  // remove old particles (reverse order)\n  for(let i=removals.length-1;i>=0;i--){\n    state.particles.splice(removals[i],1);\n  }\n}\n\n/* ---------- 主循环 ---------- */\nlet frames = 0;\nlet fpsTimer = performance.now();\n\nfunction loop(now){\n  const dtMs = now - lastTime;\n  lastTime = now;\n  const dt = Math.min(0.05, dtMs/1000); // clamp for big lags\n\n  if(running){\n    if(speedMode.value === 'live'){\n      step(dt);\n    } else {\n      // fixed step with accumulator\n      accumulator += dt;\n      const maxSteps = 5;\n      let steps = 0;\n      while(accumulator >= fixedDt && steps < maxSteps){\n        step(fixedDt);\n        accumulator -= fixedDt;\n        steps++;\n      }\n    }\n  }\n  render();\n\n  // update stats every 250ms\n  frames++;\n  if(now - fpsTimer >= 250){\n    const fps = Math.round(frames * 1000 / (now - fpsTimer));\n    fpsEl.textContent = `FPS: ${fps}`;\n    countEl.textContent = `粒子数: ${state.particles.length}`;\n    modeEl.textContent = `模式: ${speedMode.value === 'live' ? '立即更新' : '固定步长'}`;\n    fpsTimer = now;\n    frames = 0;\n  }\n\n  requestAnimationFrame(loop);\n}\n\n/* ---------- 事件：控件和交互 ---------- */\nbtnStart.addEventListener('click', ()=>{\n  running = !running;\n  btnStart.textContent = running ? '暂停' : '继续';\n  btnStart.classList.toggle('btn-primary', !running);\n  btnStart.setAttribute('aria-pressed', String(!running));\n});\n\nbtnStep.addEventListener('click', ()=>{\n  step(1/60);\n  render();\n});\n\nbtnReset.addEventListener('click', ()=>{\n  state.particles.length = 0;\n  resetSimulation();\n});\n\nbtnClear.addEventListener('click', ()=>{\n  state.particles.length = 0;\n});\n\nbtnBurst.addEventListener('click', ()=>{\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  spawnBurst(cx,cy,60);\n});\n\nbtnSave.addEventListener('click', ()=>{\n  const data = {\n    params: {\n      gravity: state.gravity,\n      wind: state.wind,\n      visc: state.visc,\n      radius: state.radius,\n      initialSpeed: state.initialSpeed,\n      spawnPerClick: state.spawnPerClick,\n      trails: state.trails,\n      collide: state.collide,\n      wrap: state.wrap,\n      colorMode: state.colorMode,\n      solidColor: state.solidColor\n    },\n    particles: state.particles.map(p=>({x:p.x,y:p.y,vx:p.vx,vy:p.vy,r:p.r,color:p.color,age:p.age,maxAge:p.maxAge}))\n  };\n  const text = JSON.stringify(data, null, 2);\n  // show in a new window for copy\n  const w = window.open('', '_blank');\n  w.document.title = '导出 - 粒子状态';\n  const pre = w.document.createElement('pre');\n  pre.textContent = text;\n  w.document.body.appendChild(pre);\n});\n\nbtnLoad.addEventListener('click', ()=>{\n  const text = prompt('粘贴之前导出的 JSON（覆盖当前）:');\n  if(!text) return;\n  try{\n    const data = JSON.parse(text);\n    if(data.params){\n      Object.assign(state, {\n        gravity: data.params.gravity,\n        wind: data.params.wind,\n        visc: data.params.visc,\n        radius: data.params.radius,\n        initialSpeed: data.params.initialSpeed,\n        spawnPerClick: data.params.spawnPerClick,\n        trails: data.params.trails,\n        collide: data.params.collide,\n        wrap: data.params.wrap,\n        colorMode: data.params.colorMode,\n        solidColor: data.params.solidColor\n      });\n      // update UI to reflect\n      sGravity.value = state.gravity; sWind.value = state.wind; sVisc.value = state.visc;\n      sSize.value = state.radius; sSpeed.value = state.initialSpeed; sRate.value = state.spawnPerClick;\n      chkTrails.checked = state.trails; chkCollide.checked = state.collide; chkWrap.checked = state.wrap;\n      selectColor.value = state.colorMode; solidColor.value = state.solidColor;\n      updateValuesDisplay();\n    }\n    state.particles.length = 0;\n    if(Array.isArray(data.particles)){\n      for(const pp of data.particles){\n        const p = new Particle(pp.x, pp.y, pp.vx, pp.vy, pp.r, pp.color);\n        p.age = pp.age || 0; p.maxAge = pp.maxAge || 20;\n        state.particles.push(p);\n      }\n    }\n  } catch(e){\n    alert('无效的 JSON：' + e.message);\n  }\n});\n\n/* sliders change handlers */\nfunction updateValuesDisplay(){\n  valGravity.textContent = parseFloat(sGravity.value).toFixed(2);\n  valWind.textContent = parseFloat(sWind.value).toFixed(2);\n  valVisc.textContent = parseFloat(sVisc.value).toFixed(3);\n  valSize.textContent = parseFloat(sSize.value);\n  valSpeed.textContent = parseFloat(sSpeed.value);\n  valRate.textContent = parseInt(sRate.value,10);\n\n  // update state\n  state.gravity = parseFloat(sGravity.value);\n  state.wind = parseFloat(sWind.value);\n  state.visc = parseFloat(sVisc.value);\n  state.radius = parseFloat(sSize.value);\n  state.initialSpeed = parseFloat(sSpeed.value);\n  state.spawnPerClick = parseInt(sRate.value,10);\n  state.solidColor = solidColor.value;\n  state.colorMode = selectColor.value;\n  state.trails = chkTrails.checked;\n  state.collide = chkCollide.checked;\n  state.wrap = chkWrap.checked;\n}\n[sGravity,sWind,sVisc,sSize,sSpeed,sRate,chkTrails,chkCollide,chkWrap,selectColor,solidColor].forEach(el=>{\n  el.addEventListener('input', updateValuesDisplay);\n});\n\n/* change color selection shows color input */\nselectColor.addEventListener('change', ()=>{\n  solidColorWrap.style.display = selectColor.value === 'solid' ? 'block':'none';\n  updateValuesDisplay();\n});\n\n/* ---------- 鼠标交互（点击/拖拽） ---------- */\nlet dragging = false;\nlet dragStart = null;\nlet dragCurrent = null;\ncanvas.addEventListener('pointerdown', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = true;\n  dragStart = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  dragCurrent = {...dragStart};\n  canvas.setPointerCapture(e.pointerId);\n  // if user clicks without drag, spawn after pointerup\n});\n\ncanvas.addEventListener('pointermove', (e)=>{\n  if(!dragging) return;\n  const rect = canvas.getBoundingClientRect();\n  dragCurrent = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // draw preview velocity vector (overlay)\n  // we'll draw it in a lightweight way by rendering on top after main render\n  render();\n  // draw vector\n  ctx.save();\n  ctx.strokeStyle = 'rgba(255,255,255,0.7)';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(dragStart.x, dragStart.y);\n  ctx.lineTo(dragCurrent.x, dragCurrent.y);\n  ctx.stroke();\n  // small circle at start\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\n  ctx.beginPath();\n  ctx.arc(dragStart.x, dragStart.y, 4, 0, Math.PI*2);\n  ctx.fill();\n  ctx.restore();\n});\n\ncanvas.addEventListener('pointerup', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = false;\n  const up = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // compute velocity from drag vector\n  let vx = 0, vy = 0;\n  const dx = up.x - dragStart.x, dy = up.y - dragStart.y;\n  const dist = Math.hypot(dx,dy);\n  if(dist > 6){\n    const angle = Math.atan2(dy,dx);\n    const speed = Math.min(10, dist/10 + state.initialSpeed*0.2);\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  } else {\n    // small random direction\n    const angle = Math.random()*Math.PI*2;\n    const speed = state.initialSpeed;\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  }\n  // spawn spawnPerClick particles at click position\n  const n = state.spawnPerClick;\n  for(let i=0;i<n;i++){\n    const jitter = (i - n/2) * 2;\n    spawnParticle(dragStart.x + jitter, dragStart.y + jitter, Math.atan2(vy, vx) + (Math.random()-0.5)*0.4, Math.hypot(vx,vy)*(0.9 + Math.random()*0.2));\n  }\n  render();\n});\n\n/* keyboard shortcuts */\nwindow.addEventListener('keydown', (e)=>{\n  if(e.code === 'Space'){\n    e.preventDefault();\n    btnStart.click();\n  } else if(e.key.toLowerCase() === 'c'){\n    btnClear.click();\n  } else if(e.key.toLowerCase() === 'b'){\n    btnBurst.click();\n  }\n});\n\n/* prevent context menu on canvas for convenience */\ncanvas.addEventListener('contextmenu', (e)=>e.preventDefault());\n\n/* ---------- 初始化 ---------- */\nupdateValuesDisplay();\nresetSimulation();\nrequestAnimationFrame((t)=>{\n  lastTime = t;\n  fpsTimer = t;\n  loop(t);\n});\n\n/* handle Resize HiDPI on load and orientation change */\nwindow.addEventListener('orientationchange', ()=>{\n  setTimeout(()=>{ resizeCanvas(); }, 200);\n});\n/* keep canvas size correct when CSS changes */\nconst ro = new ResizeObserver(()=>{ resizeCanvas(); });\nro.observe(canvas);\n\n/* end of script */\n</script>",
              "css_content": ":root{\n    --bg:#0f1724;\n    --panel:#0b1220cc;\n    --accent:#4fd1c5;\n    --muted:#9aa6b2;\n    --glass: rgba(255,255,255,0.03);\n  }\n  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;color:#e6eef6;background:linear-gradient(180deg,var(--bg),#071023);}\n  .app{\n    display:flex;\n    gap:16px;\n    padding:18px;\n    box-sizing:border-box;\n    align-items:flex-start;\n    min-height:100vh;\n  }\n  .canvas-wrap{\n    flex:1 1 70%;\n    min-width:360px;\n    border-radius:12px;\n    overflow:hidden;\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    box-shadow: 0 6px 30px rgba(2,6,23,0.7), inset 0 1px 0 rgba(255,255,255,0.02);\n    position:relative;\n    padding:12px;\n  }\n  canvas{\n    width:100%;\n    height:70vh;\n    display:block;\n    border-radius:8px;\n    background: radial-gradient(circle at 20% 10%, rgba(255,255,255,0.02), transparent 10%),\n                linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03));\n    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\n  }\n  .info-bar{\n    display:flex;\n    gap:12px;\n    align-items:center;\n    margin-top:10px;\n    color:var(--muted);\n    font-size:13px;\n  }\n  .panel{\n    width:360px;\n    background:var(--panel);\n    border-radius:12px;\n    padding:14px;\n    box-shadow: 0 8px 30px rgba(2,6,23,0.6);\n    color:#e6eef6;\n    flex-shrink:0;\n    max-height:calc(100vh - 36px);\n    overflow:auto;\n  }\n  h2{margin:0 0 10px 0;font-size:16px}\n  .section{margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid rgba(255,255,255,0.03)}\n  .controls{display:flex;flex-wrap:wrap;gap:8px}\n  button{\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    border:1px solid rgba(255,255,255,0.04);\n    color:var(--accent);\n    padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;\n    transition:transform .08s ease,box-shadow .08s;\n  }\n  button:active{transform:translateY(1px)}\n  .btn-primary{background:linear-gradient(90deg,#0ea5a8,#38bdf8); color:#012; border:none; box-shadow:0 6px 18px rgba(14,165,168,0.12);}\n  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px;}\n  .row{display:flex;align-items:center;gap:8px}\n  .full{width:100%}\n  input[type=\"range\"]{width:100%}\n  .control-item{margin-bottom:10px}\n  .small{font-size:12px;color:var(--muted)}\n  .stat{background:var(--glass);padding:8px 10px;border-radius:8px;color:var(--muted);font-size:13px}\n  .footer-note{font-size:12px;color:var(--muted);margin-top:10px}\n  .kbd{background:rgba(255,255,255,0.04);padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}\n  .color-input{height:34px;padding:0;border-radius:6px;border:none;cursor:pointer}\n  .toggle{display:flex;align-items:center;gap:8px}\n  .hint{font-size:12px;color:var(--muted);margin-top:6px}\n  a{color:var(--accent)}\n  /* Make scrollbars subtle */\n  .panel::-webkit-scrollbar{width:10px;height:10px}\n  .panel::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.03);border-radius:8px}\n  @media (max-width:900px){\n    .app{flex-direction:column;padding:12px}\n    .canvas-wrap{order:2}\n    .panel{order:1;width:100%}\n    canvas{height:50vh}\n  }",
              "js_content": "/*\n  交互式粒子系统\n  - 支持：开始/暂停、单步、重置、爆发、清空\n  - 参数实时控制：重力、风、阻尼、粒子大小、初速度、生成数量\n  - 显示选项：尾迹、碰撞/包裹、颜色模式\n  - 鼠标交互：点击生成；拖拽设置初速度\n  - 导出/导入当前状态（JSON）\n  - 无外部依赖，兼容现代浏览器\n*/\n\n/* ---------- 全局与帮助函数 ---------- */\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d', { alpha: true });\nlet DPR = Math.max(1, window.devicePixelRatio || 1);\n\n/* resize canvas to displayed size */\nfunction resizeCanvas(){\n  const rect = canvas.getBoundingClientRect();\n  canvas.width = Math.round(rect.width * DPR);\n  canvas.height = Math.round(rect.height * DPR);\n  ctx.setTransform(DPR,0,0,DPR,0,0); // use CSS pixels in drawing\n}\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\n\n/* ---------- 控件引用 ---------- */\nconst btnStart = document.getElementById('btnStart');\nconst btnStep = document.getElementById('btnStep');\nconst btnReset = document.getElementById('btnReset');\nconst btnBurst = document.getElementById('btnBurst');\nconst btnClear = document.getElementById('btnClear');\nconst btnSave = document.getElementById('btnSave');\nconst btnLoad = document.getElementById('btnLoad');\n\nconst sGravity = document.getElementById('sGravity');\nconst sWind = document.getElementById('sWind');\nconst sVisc = document.getElementById('sVisc');\nconst sSize = document.getElementById('sSize');\nconst sSpeed = document.getElementById('sSpeed');\nconst sRate = document.getElementById('sRate');\n\nconst valGravity = document.getElementById('valGravity');\nconst valWind = document.getElementById('valWind');\nconst valVisc = document.getElementById('valVisc');\nconst valSize = document.getElementById('valSize');\nconst valSpeed = document.getElementById('valSpeed');\nconst valRate = document.getElementById('valRate');\n\nconst chkTrails = document.getElementById('chkTrails');\nconst chkCollide = document.getElementById('chkCollide');\nconst chkWrap = document.getElementById('chkWrap');\nconst selectColor = document.getElementById('selectColor');\nconst solidColorWrap = document.getElementById('solidColorWrap');\nconst solidColor = document.getElementById('solidColor');\n\nconst fpsEl = document.getElementById('fps');\nconst countEl = document.getElementById('count');\nconst modeEl = document.getElementById('mode');\nconst speedMode = document.getElementById('speedMode');\n\n/* ---------- 仿真参数与状态 ---------- */\nlet running = true;\nlet lastTime = performance.now();\nlet accumulator = 0;\nlet fixedDt = 1/60; // for fixed step\n\nconst state = {\n  gravity: parseFloat(sGravity.value),\n  wind: parseFloat(sWind.value),\n  visc: parseFloat(sVisc.value),\n  radius: parseFloat(sSize.value),\n  initialSpeed: parseFloat(sSpeed.value),\n  spawnPerClick: parseInt(sRate.value,10),\n  trails: chkTrails.checked,\n  collide: chkCollide.checked,\n  wrap: chkWrap.checked,\n  colorMode: selectColor.value,\n  solidColor: solidColor.value,\n  particles: []\n};\n\n/* ---------- 粒子类 ---------- */\nclass Particle {\n  constructor(x,y,vx,vy,r,color){\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.r = r;\n    this.color = color || randomColor();\n    this.age = 0;\n    this.maxAge = 10 + Math.random()*20;\n  }\n  step(dt){\n    // forces: gravity downward, wind horizontal\n    this.vy += state.gravity * dt * 60; // scale to feel right\n    this.vx += state.wind * dt * 60;\n    // viscosity (simple velocity damping)\n    this.vx *= (1 - state.visc);\n    this.vy *= (1 - state.visc);\n    // integrate\n    this.x += this.vx * dt * 60;\n    this.y += this.vy * dt * 60;\n    this.age += dt;\n  }\n}\n\n/* ---------- 辅助 ---------- */\nfunction randomColor(){\n  // return a pastel-like random color\n  const h = Math.floor(Math.random()*360);\n  const s = 70 + Math.random()*20;\n  const l = 50 + Math.random()*10;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\nfunction gradientColor(t){\n  // t in [0,1]\n  const h = (200 + 160 * t) % 360;\n  const s = 70;\n  const l = 60 - 20*t;\n  return `hsl(${h}deg ${s}% ${l}%)`;\n}\n\n/* ---------- 粒子管理 ---------- */\nfunction spawnParticle(x,y,angle,speed){\n  const r = state.radius;\n  const speedVal = speed ?? (state.initialSpeed + (Math.random()-0.5)*0.5);\n  const vx = Math.cos(angle) * speedVal;\n  const vy = Math.sin(angle) * speedVal;\n  let color;\n  if(state.colorMode === 'random') color = randomColor();\n  else if(state.colorMode === 'gradient') color = gradientColor(Math.random());\n  else color = state.solidColor;\n  const p = new Particle(x,y,vx,vy,r,color);\n  state.particles.push(p);\n  return p;\n}\n\nfunction spawnBurst(x,y,n){\n  for(let i=0;i<n;i++){\n    const ang = Math.random()*Math.PI*2;\n    const sp = state.initialSpeed + Math.random()*3;\n    spawnParticle(x,y,ang,sp);\n  }\n}\n\nfunction resetSimulation(){\n  state.particles.length = 0;\n  // place a few sample particles\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  for(let i=0;i<8;i++){\n    spawnBurst(cx + (Math.random()-0.5)*200, cy + (Math.random()-0.5)*120, 1);\n  }\n}\n\n/* ---------- 物理与边界 ---------- */\nfunction handleBounds(p){\n  const w = canvas.clientWidth;\n  const h = canvas.clientHeight;\n  if(state.wrap){\n    if(p.x < -p.r) p.x = w + p.r;\n    if(p.x > w + p.r) p.x = -p.r;\n    if(p.y < -p.r) p.y = h + p.r;\n    if(p.y > h + p.r) p.y = -p.r;\n  } else if(state.collide){\n    // simple elastic collision with walls\n    if(p.x - p.r < 0){\n      p.x = p.r; p.vx = Math.abs(p.vx)*0.8;\n    }\n    if(p.x + p.r > w){\n      p.x = w - p.r; p.vx = -Math.abs(p.vx)*0.8;\n    }\n    if(p.y - p.r < 0){\n      p.y = p.r; p.vy = Math.abs(p.vy)*0.8;\n    }\n    if(p.y + p.r > h){\n      p.y = h - p.r; p.vy = -Math.abs(p.vy)*0.8;\n    }\n  } else {\n    // leave as-is (may go off-screen)\n  }\n}\n\n/* ---------- 渲染 ---------- */\nfunction render(){\n  // Clear or fade for trails\n  if(state.trails){\n    // draw semi-transparent rect to create trail fading\n    ctx.fillStyle = 'rgba(5,8,14,0.15)';\n    ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  } else {\n    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);\n  }\n\n  // draw particles\n  for(const p of state.particles){\n    ctx.beginPath();\n    ctx.fillStyle = p.color;\n    ctx.globalAlpha = Math.max(0.1, 1 - p.age/p.maxAge);\n    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);\n    ctx.fill();\n    // small highlight\n    ctx.globalAlpha = 0.18;\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(p.x - p.r*0.25, p.y - p.r*0.25, Math.max(0.5,p.r*0.5), 0, Math.PI*2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n  }\n}\n\n/* ---------- 仿真步进 ---------- */\nfunction step(dt){\n  // dt in seconds\n  const removals = [];\n  for(let i=0;i<state.particles.length;i++){\n    const p = state.particles[i];\n    p.step(dt);\n    handleBounds(p);\n    // ageing removal\n    if(p.age > p.maxAge){\n      removals.push(i);\n    }\n  }\n  // remove old particles (reverse order)\n  for(let i=removals.length-1;i>=0;i--){\n    state.particles.splice(removals[i],1);\n  }\n}\n\n/* ---------- 主循环 ---------- */\nlet frames = 0;\nlet fpsTimer = performance.now();\n\nfunction loop(now){\n  const dtMs = now - lastTime;\n  lastTime = now;\n  const dt = Math.min(0.05, dtMs/1000); // clamp for big lags\n\n  if(running){\n    if(speedMode.value === 'live'){\n      step(dt);\n    } else {\n      // fixed step with accumulator\n      accumulator += dt;\n      const maxSteps = 5;\n      let steps = 0;\n      while(accumulator >= fixedDt && steps < maxSteps){\n        step(fixedDt);\n        accumulator -= fixedDt;\n        steps++;\n      }\n    }\n  }\n  render();\n\n  // update stats every 250ms\n  frames++;\n  if(now - fpsTimer >= 250){\n    const fps = Math.round(frames * 1000 / (now - fpsTimer));\n    fpsEl.textContent = `FPS: ${fps}`;\n    countEl.textContent = `粒子数: ${state.particles.length}`;\n    modeEl.textContent = `模式: ${speedMode.value === 'live' ? '立即更新' : '固定步长'}`;\n    fpsTimer = now;\n    frames = 0;\n  }\n\n  requestAnimationFrame(loop);\n}\n\n/* ---------- 事件：控件和交互 ---------- */\nbtnStart.addEventListener('click', ()=>{\n  running = !running;\n  btnStart.textContent = running ? '暂停' : '继续';\n  btnStart.classList.toggle('btn-primary', !running);\n  btnStart.setAttribute('aria-pressed', String(!running));\n});\n\nbtnStep.addEventListener('click', ()=>{\n  step(1/60);\n  render();\n});\n\nbtnReset.addEventListener('click', ()=>{\n  state.particles.length = 0;\n  resetSimulation();\n});\n\nbtnClear.addEventListener('click', ()=>{\n  state.particles.length = 0;\n});\n\nbtnBurst.addEventListener('click', ()=>{\n  const cx = canvas.clientWidth/2;\n  const cy = canvas.clientHeight/2;\n  spawnBurst(cx,cy,60);\n});\n\nbtnSave.addEventListener('click', ()=>{\n  const data = {\n    params: {\n      gravity: state.gravity,\n      wind: state.wind,\n      visc: state.visc,\n      radius: state.radius,\n      initialSpeed: state.initialSpeed,\n      spawnPerClick: state.spawnPerClick,\n      trails: state.trails,\n      collide: state.collide,\n      wrap: state.wrap,\n      colorMode: state.colorMode,\n      solidColor: state.solidColor\n    },\n    particles: state.particles.map(p=>({x:p.x,y:p.y,vx:p.vx,vy:p.vy,r:p.r,color:p.color,age:p.age,maxAge:p.maxAge}))\n  };\n  const text = JSON.stringify(data, null, 2);\n  // show in a new window for copy\n  const w = window.open('', '_blank');\n  w.document.title = '导出 - 粒子状态';\n  const pre = w.document.createElement('pre');\n  pre.textContent = text;\n  w.document.body.appendChild(pre);\n});\n\nbtnLoad.addEventListener('click', ()=>{\n  const text = prompt('粘贴之前导出的 JSON（覆盖当前）:');\n  if(!text) return;\n  try{\n    const data = JSON.parse(text);\n    if(data.params){\n      Object.assign(state, {\n        gravity: data.params.gravity,\n        wind: data.params.wind,\n        visc: data.params.visc,\n        radius: data.params.radius,\n        initialSpeed: data.params.initialSpeed,\n        spawnPerClick: data.params.spawnPerClick,\n        trails: data.params.trails,\n        collide: data.params.collide,\n        wrap: data.params.wrap,\n        colorMode: data.params.colorMode,\n        solidColor: data.params.solidColor\n      });\n      // update UI to reflect\n      sGravity.value = state.gravity; sWind.value = state.wind; sVisc.value = state.visc;\n      sSize.value = state.radius; sSpeed.value = state.initialSpeed; sRate.value = state.spawnPerClick;\n      chkTrails.checked = state.trails; chkCollide.checked = state.collide; chkWrap.checked = state.wrap;\n      selectColor.value = state.colorMode; solidColor.value = state.solidColor;\n      updateValuesDisplay();\n    }\n    state.particles.length = 0;\n    if(Array.isArray(data.particles)){\n      for(const pp of data.particles){\n        const p = new Particle(pp.x, pp.y, pp.vx, pp.vy, pp.r, pp.color);\n        p.age = pp.age || 0; p.maxAge = pp.maxAge || 20;\n        state.particles.push(p);\n      }\n    }\n  } catch(e){\n    alert('无效的 JSON：' + e.message);\n  }\n});\n\n/* sliders change handlers */\nfunction updateValuesDisplay(){\n  valGravity.textContent = parseFloat(sGravity.value).toFixed(2);\n  valWind.textContent = parseFloat(sWind.value).toFixed(2);\n  valVisc.textContent = parseFloat(sVisc.value).toFixed(3);\n  valSize.textContent = parseFloat(sSize.value);\n  valSpeed.textContent = parseFloat(sSpeed.value);\n  valRate.textContent = parseInt(sRate.value,10);\n\n  // update state\n  state.gravity = parseFloat(sGravity.value);\n  state.wind = parseFloat(sWind.value);\n  state.visc = parseFloat(sVisc.value);\n  state.radius = parseFloat(sSize.value);\n  state.initialSpeed = parseFloat(sSpeed.value);\n  state.spawnPerClick = parseInt(sRate.value,10);\n  state.solidColor = solidColor.value;\n  state.colorMode = selectColor.value;\n  state.trails = chkTrails.checked;\n  state.collide = chkCollide.checked;\n  state.wrap = chkWrap.checked;\n}\n[sGravity,sWind,sVisc,sSize,sSpeed,sRate,chkTrails,chkCollide,chkWrap,selectColor,solidColor].forEach(el=>{\n  el.addEventListener('input', updateValuesDisplay);\n});\n\n/* change color selection shows color input */\nselectColor.addEventListener('change', ()=>{\n  solidColorWrap.style.display = selectColor.value === 'solid' ? 'block':'none';\n  updateValuesDisplay();\n});\n\n/* ---------- 鼠标交互（点击/拖拽） ---------- */\nlet dragging = false;\nlet dragStart = null;\nlet dragCurrent = null;\ncanvas.addEventListener('pointerdown', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = true;\n  dragStart = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  dragCurrent = {...dragStart};\n  canvas.setPointerCapture(e.pointerId);\n  // if user clicks without drag, spawn after pointerup\n});\n\ncanvas.addEventListener('pointermove', (e)=>{\n  if(!dragging) return;\n  const rect = canvas.getBoundingClientRect();\n  dragCurrent = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // draw preview velocity vector (overlay)\n  // we'll draw it in a lightweight way by rendering on top after main render\n  render();\n  // draw vector\n  ctx.save();\n  ctx.strokeStyle = 'rgba(255,255,255,0.7)';\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(dragStart.x, dragStart.y);\n  ctx.lineTo(dragCurrent.x, dragCurrent.y);\n  ctx.stroke();\n  // small circle at start\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\n  ctx.beginPath();\n  ctx.arc(dragStart.x, dragStart.y, 4, 0, Math.PI*2);\n  ctx.fill();\n  ctx.restore();\n});\n\ncanvas.addEventListener('pointerup', (e)=>{\n  const rect = canvas.getBoundingClientRect();\n  dragging = false;\n  const up = { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  // compute velocity from drag vector\n  let vx = 0, vy = 0;\n  const dx = up.x - dragStart.x, dy = up.y - dragStart.y;\n  const dist = Math.hypot(dx,dy);\n  if(dist > 6){\n    const angle = Math.atan2(dy,dx);\n    const speed = Math.min(10, dist/10 + state.initialSpeed*0.2);\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  } else {\n    // small random direction\n    const angle = Math.random()*Math.PI*2;\n    const speed = state.initialSpeed;\n    vx = Math.cos(angle) * speed;\n    vy = Math.sin(angle) * speed;\n  }\n  // spawn spawnPerClick particles at click position\n  const n = state.spawnPerClick;\n  for(let i=0;i<n;i++){\n    const jitter = (i - n/2) * 2;\n    spawnParticle(dragStart.x + jitter, dragStart.y + jitter, Math.atan2(vy, vx) + (Math.random()-0.5)*0.4, Math.hypot(vx,vy)*(0.9 + Math.random()*0.2));\n  }\n  render();\n});\n\n/* keyboard shortcuts */\nwindow.addEventListener('keydown', (e)=>{\n  if(e.code === 'Space'){\n    e.preventDefault();\n    btnStart.click();\n  } else if(e.key.toLowerCase() === 'c'){\n    btnClear.click();\n  } else if(e.key.toLowerCase() === 'b'){\n    btnBurst.click();\n  }\n});\n\n/* prevent context menu on canvas for convenience */\ncanvas.addEventListener('contextmenu', (e)=>e.preventDefault());\n\n/* ---------- 初始化 ---------- */\nupdateValuesDisplay();\nresetSimulation();\nrequestAnimationFrame((t)=>{\n  lastTime = t;\n  fpsTimer = t;\n  loop(t);\n});\n\n/* handle Resize HiDPI on load and orientation change */\nwindow.addEventListener('orientationchange', ()=>{\n  setTimeout(()=>{ resizeCanvas(); }, 200);\n});\n/* keep canvas size correct when CSS changes */\nconst ro = new ResizeObserver(()=>{ resizeCanvas(); });\nro.observe(canvas);\n\n/* end of script */",
              "parameters": [],
              "status": "success"
            },
            "attempts": 2
          }
        },
        {
          "stage": "quality_check",
          "timestamp": "2025-08-09T12:17:15.542Z",
          "checks": {
            "hasCode": false,
            "codeLength": 0,
            "htmlTagsFound": [],
            "syntaxErrors": [],
            "bracketMatching": true,
            "syntaxValid": true
          }
        }
      ],
      "finalResult": {
        "codeGenerated": false,
        "codeLength": 0,
        "hasQualityIssues": false,
        "issues": {
          "htmlTags": 0,
          "bracketErrors": false,
          "syntaxErrors": false
        }
      },
      "success": true,
      "errors": [],
      "endTime": "2025-08-09T12:17:15.543Z",
      "duration": 108432
    },
    {
      "name": "数学可视化",
      "prompt": "创建一个数学函数可视化工具，能够绘制sin和cos函数",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T12:17:20.545Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T12:18:47.640Z",
          "response": {
            "status": 200,
            "statusText": "OK",
            "headers": {
              "access-control-allow-origin": "*",
              "connection": "keep-alive",
              "content-length": "37899",
              "content-type": "application/json; charset=utf-8",
              "date": "Sat, 09 Aug 2025 12:18:47 GMT",
              "etag": "W/\"940b-6mkorCqrek93su2Pm7eXp1wGDRo\"",
              "keep-alive": "timeout=5",
              "x-powered-by": "Express"
            },
            "data": {
              "success": true,
              "data": {
                "experiment_id": "6fb2357d-dc47-41be-adec-cf62cf447aa7",
                "title": "sin / cos 可视化工具",
                "description": "总结（信息检索情况与核心概念）：\n- 我对“创建一个数学函数可视化工具，能够绘制sin和cos函数”的维基百科检索没有找到针对该中文查询的直接结果（检索返回：没有找到相关信息）。\n- 常见且可验证的数学事实（概念性说明）：\n  - 正弦（sin）和余弦（cos）是周期函数，标准形式的周期为 2π。\n  - 广义形式可写成 y = A * sin(ωx + φ) + C（或 cos），其中 A 是振幅，ω 是角频率（影响每单位 x 的振荡次数），φ 是相位（水平平移），C 是垂直平移。\n  - 改变采样点数量会影响绘图平滑度；绘图范围（x 的区间）决定可视化的周期数量。\n- 下面提供一个自包含的、可交互的 HTML 演示文件：可以绘制 sin 与 cos（单独或同时），可调参数：振幅、频率（角频率的倍数）、相位、纵向偏移、x 轴区间（以 π 的倍数设置）、采样点数、颜色等，并提供动画相位选项与导出图片按钮。\n\n完整可运行 HTML 代码（保存为 .html 并在浏览器中打开）：",
                "html_content": "<header>\n    <h1>sin / cos 可视化工具</h1>\n    <div style=\"color:var(--muted);font-size:13px;\">调整参数观察正弦和余弦函数行为（安全的浏览器内模拟）</div>\n  </header>\n\n  <main>\n    <aside class=\"controls\" aria-label=\"控制面板\">\n      <div>\n        <div class=\"flex-between\">\n          <div>\n            <label class=\"block\">绘制函数</label>\n            <div class=\"row\">\n              <label style=\"display:flex;align-items:center;gap:8px;\">\n                <input type=\"checkbox\" id=\"showSin\" checked /> sin(x)\n              </label>\n              <label style=\"display:flex;align-items:center;gap:8px;\">\n                <input type=\"checkbox\" id=\"showCos\" checked /> cos(x)\n              </label>\n            </div>\n          </div>\n          <div>\n            <button id=\"resetBtn\" title=\"恢复默认参数\">重置</button>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">振幅 A：<span id=\"ampVal\" class=\"val\">1.00</span></label>\n          <input type=\"range\" id=\"amplitude\" min=\"0\" max=\"5\" step=\"0.01\" value=\"1\">\n\n          <label class=\"block\">频率 ω（乘以 x）：<span id=\"freqVal\" class=\"val\">1.00</span></label>\n          <input type=\"range\" id=\"frequency\" min=\"0\" max=\"6\" step=\"0.01\" value=\"1\">\n\n          <label class=\"block\">相位 φ（弧度）：<span id=\"phaseVal\" class=\"val\">0.00</span></label>\n          <input type=\"range\" id=\"phase\" min=\"-6.283\" max=\"6.283\" step=\"0.001\" value=\"0\">\n\n          <label class=\"block\">垂直偏移 C：<span id=\"vshiftVal\" class=\"val\">0.00</span></label>\n          <input type=\"range\" id=\"vshift\" min=\"-5\" max=\"5\" step=\"0.01\" value=\"0\">\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">x 轴区间（以 π 的倍数）</label>\n          <div class=\"row\">\n            <div style=\"flex:1\">\n              <label class=\"small\">起点 (π * <span id=\"xStartMul\">-2</span>)</label>\n              <input type=\"range\" id=\"xStart\" min=\"-6\" max=\"0\" step=\"0.1\" value=\"-2\">\n            </div>\n            <div style=\"width:14px\"></div>\n            <div style=\"flex:1\">\n              <label class=\"small\">终点 (π * <span id=\"xEndMul\">2</span>)</label>\n              <input type=\"range\" id=\"xEnd\" min=\"0\" max=\"6\" step=\"0.1\" value=\"2\">\n            </div>\n          </div>\n\n          <label class=\"block\">采样点数：<span id=\"samplesVal\" class=\"val\">800</span></label>\n          <input type=\"range\" id=\"samples\" min=\"100\" max=\"3000\" step=\"10\" value=\"800\">\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">颜色与样式</label>\n          <div class=\"legend\">\n            <div class=\"item\">\n              <input type=\"color\" id=\"sinColor\" value=\"#e34a6f\">\n              <div>sin</div>\n            </div>\n            <div class=\"item\">\n              <input type=\"color\" id=\"cosColor\" value=\"#2b90ff\">\n              <div>cos</div>\n            </div>\n            <div style=\"margin-left:8px\" class=\"item\">\n              <label style=\"display:flex;align-items:center;gap:6px;\">\n                线宽：\n                <input id=\"lineWidth\" type=\"range\" min=\"1\" max=\"6\" step=\"1\" value=\"2\" />\n              </label>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">动画与导出</label>\n          <div class=\"row\" style=\"gap:8px;\">\n            <button id=\"toggleAnim\">开始相位动画</button>\n            <button class=\"secondary\" id=\"exportBtn\">导出 PNG</button>\n          </div>\n          <div style=\"margin-top:10px;font-size:13px;color:var(--muted);\">\n            相位动画会连续改变 φ 值以看到波形移动。导出会把当前画布保存为图片。\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">提示</label>\n          <div style=\"font-size:13px;color:var(--muted);line-height:1.5;\">\n            - 频率越大，同一区间内周期越多；相位改变会水平移动波形；振幅决定上下张开程度。<br>\n            - x 轴区间单位是 π：例如 -2 到 2 表示 [-2π, 2π]。<br>\n            - 采样点越多曲线越平滑，但计算开销增大。\n          </div>\n        </div>\n\n      </div>\n    </aside>\n\n    <section class=\"canvas-wrap\" aria-label=\"绘图区域\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;padding:6px 6px 10px 6px;\">\n        <div style=\"font-weight:600\">绘图预览</div>\n        <div style=\"color:var(--muted);font-size:13px;\" id=\"domainLabel\"></div>\n      </div>\n      <div style=\"flex:1;min-height:320px;display:flex;flex-direction:column;\">\n        <canvas id=\"plotCanvas\" width=\"1200\" height=\"600\" role=\"img\" aria-label=\"函数绘图画布\"></canvas>\n      </div>\n      <footer>\n        鼠标悬停画布上可以看到对应 x, y 值（右上角坐标）。输入框与滑块会即时更新图形。\n      </footer>\n    </section>\n  </main>\n\n  <script>\n    // 获取元素\n    const canvas = document.getElementById('plotCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    // canvas 内部像素尺寸与 css 宽高保持一致以保证清晰\n    function resizeCanvasToDisplaySize() {\n      const r = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.round(rect.width * r);\n      canvas.height = Math.round(rect.height * r);\n      ctx.setTransform(r,0,0,r,0,0);\n    }\n    // 控件\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xStart = document.getElementById('xStart');\n    const xEnd = document.getElementById('xEnd');\n    const samples = document.getElementById('samples');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const sinColor = document.getElementById('sinColor');\n    const cosColor = document.getElementById('cosColor');\n    const lineWidth = document.getElementById('lineWidth');\n    const toggleAnim = document.getElementById('toggleAnim');\n    const exportBtn = document.getElementById('exportBtn');\n    const resetBtn = document.getElementById('resetBtn');\n\n    // 显示值元素\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const xStartMul = document.getElementById('xStartMul');\n    const xEndMul = document.getElementById('xEndMul');\n    const samplesVal = document.getElementById('samplesVal');\n    const domainLabel = document.getElementById('domainLabel');\n\n    // 初始参数\n    let animState = false;\n    let animId = null;\n    let animSpeed = 1.2; // 每秒相位变化（弧度）\n    function getParams(){\n      return {\n        A: parseFloat(amplitude.value),\n        w: parseFloat(frequency.value),\n        phi: parseFloat(phase.value),\n        C: parseFloat(vshift.value),\n        x0: parseFloat(xStart.value) * Math.PI,\n        x1: parseFloat(xEnd.value) * Math.PI,\n        n: parseInt(samples.value,10),\n        showSin: showSin.checked,\n        showCos: showCos.checked,\n        sinColor: sinColor.value,\n        cosColor: cosColor.value,\n        lineWidth: parseInt(lineWidth.value,10)\n      };\n    }\n\n    // 更新显示值\n    function updateDisplays(){\n      const p = getParams();\n      ampVal.textContent = p.A.toFixed(2);\n      freqVal.textContent = p.w.toFixed(2);\n      phaseVal.textContent = p.phi.toFixed(3);\n      vshiftVal.textContent = p.C.toFixed(2);\n      xStartMul.textContent = (parseFloat(xStart.value)).toFixed(2);\n      xEndMul.textContent = (parseFloat(xEnd.value)).toFixed(2);\n      samplesVal.textContent = p.n;\n      domainLabel.textContent = `[${(p.x0/Math.PI).toFixed(2)}π, ${(p.x1/Math.PI).toFixed(2)}π]`;\n    }\n\n    // 坐标映射：将数学坐标映射到画布像素\n    function computeTransform(p, w, h, padding=40) {\n      // x from p.x0..p.x1 to px from padding..w-padding\n      const xmin = p.x0, xmax = p.x1;\n      // 为 y 轴自动缩放以包含振幅和 vshift，同时留一些边距\n      // 先估计 y 显示范围：基于 A 和 C\n      const A = p.A, C = p.C;\n      // 如果同时画 sin 和 cos，最大幅度仍是 A，所以：\n      const yMaxAbs = Math.max(Math.abs(C + A), Math.abs(C - A));\n      // 如果 yMaxAbs 太小，设置最小范围\n      const yRangeHalf = Math.max(yMaxAbs * 1.2, 1.0);\n      const ymin = C - yRangeHalf;\n      const ymax = C + yRangeHalf;\n      return {\n        xmin, xmax, ymin, ymax,\n        pxmin: padding, pxmax: w - padding, pymin: h - padding, pymax: padding\n      };\n    }\n\n    // 绘制坐标网格和坐标轴\n    function drawGrid(ctx, trans){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const w = ctx.canvas.width;\n      const h = ctx.canvas.height;\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,w,h);\n\n      // 内部绘图区尺寸\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      // 背景微格\n      ctx.fillStyle = '#fbfdff';\n      ctx.fillRect(left, top, right-left, bottom-top);\n\n      // 网格线：以 π 的刻度绘制竖线，如果区间较小，自动选择刻度\n      function xToPx(x){\n        return left + (x - xmin) / (xmax - xmin) * (right - left);\n      }\n      function yToPx(y){\n        return top + (ymax - y) / (ymax - ymin) * (bottom - top);\n      }\n\n      // 竖线：以 π/2 的倍数标记\n      const approxWidth = Math.abs(xmax - xmin);\n      // 选择刻度基准\n      let stepCandidate = Math.PI / 2; // default π/2\n      if (approxWidth > 12*Math.PI) stepCandidate = Math.PI * 2;\n      if (approxWidth < Math.PI/2) stepCandidate = Math.PI/8;\n      // round step to nearest power-of-two fractions of π\n      const step = stepCandidate;\n\n      ctx.strokeStyle = '#eef4ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = Math.round(xToPx(x)) + 0.5;\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // 横线\n      ctx.beginPath();\n      for (let y = Math.ceil(ymin)*(1); y <= ymax; y += Math.max( (ymax - ymin)/8, 0.5 )){\n        const py = Math.round(yToPx(y)) + 0.5;\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n\n      // 轴线 (x=0, y=0)\n      ctx.strokeStyle = '#b8c8e6';\n      ctx.lineWidth = 1.5;\n      ctx.beginPath();\n      if (xmin <= 0 && xmax >= 0){\n        const px0 = Math.round(xToPx(0)) + 0.5;\n        ctx.moveTo(px0, top);\n        ctx.lineTo(px0, bottom);\n      }\n      if (ymin <= 0 && ymax >= 0){\n        const py0 = Math.round(yToPx(0)) + 0.5;\n        ctx.moveTo(left, py0);\n        ctx.lineTo(right, py0);\n      }\n      ctx.stroke();\n\n      // 刻度标签 (x轴以 π 单位显示)\n      ctx.fillStyle = '#234';\n      ctx.font = \"12px system-ui,Segoe UI,Arial\";\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = xToPx(x);\n        // label as multiples of π when appropriate\n        let label;\n        const ratio = x / Math.PI;\n        if (Math.abs(ratio) < 1e-6) label = '0';\n        else if (Math.abs(ratio - Math.round(ratio)) < 1e-6) label = (Math.round(ratio)===1 ? 'π' : (Math.round(ratio)===-1 ? '-π' : (Math.round(ratio) + 'π')));\n        else {\n          label = ratio.toFixed(2) + 'π';\n        }\n        ctx.fillText(label, px, bottom + 6);\n      }\n\n      // y 轴标签\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      const yTicks = 5;\n      for (let i=0;i<=yTicks;i++){\n        const y = ymin + (ymax - ymin) * i / yTicks;\n        const py = yToPx(y);\n        ctx.fillText(y.toFixed(2), left - 8, py);\n      }\n    }\n\n    // 绘制函数曲线样条（简单线段连接）\n    function drawFunction(ctx, p, trans, funcType='sin', color='#f00'){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      const A = p.A, w = p.w, phi = p.phi, C = p.C;\n      const n = p.n;\n      const dx = (xmax - xmin) / (n - 1);\n      function xToPx(x){ return left + (x - xmin) / (xmax - xmin) * (right - left); }\n      function yToPx(y){ return top + (ymax - y) / (ymax - ymin) * (bottom - top); }\n\n      ctx.beginPath();\n      for (let i=0;i<n;i++){\n        const x = xmin + i * dx;\n        let y;\n        if (funcType === 'sin') y = A * Math.sin(w * x + phi) + C;\n        else y = A * Math.cos(w * x + phi) + C;\n        const px = xToPx(x);\n        const py = yToPx(y);\n        if (i===0) ctx.moveTo(px, py);\n        else ctx.lineTo(px, py);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = p.lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // 鼠标悬停显示坐标\n    let hover = {x:null,y:null,show:false};\n    canvas.addEventListener('mousemove', (ev)=>{\n      const rect = canvas.getBoundingClientRect();\n      const r = window.devicePixelRatio || 1;\n      const mouseX = (ev.clientX - rect.left) * r;\n      const mouseY = (ev.clientY - rect.top) * r;\n      const p = getParams();\n      const trans = computeTransform(p, canvas.width, canvas.height);\n      // convert pixel to math coords\n      const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n      if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {\n        hover.show = false;\n        return;\n      }\n      const x = trans.xmin + (mouseX - left) / (right - left) * (trans.xmax - trans.xmin);\n      const y = trans.ymax - (mouseY - top) / (bottom - top) * (trans.ymax - trans.ymin);\n      hover = {x,y,show:true};\n      draw(); // redraw to show overlay\n    });\n    canvas.addEventListener('mouseleave', ()=>{ hover.show=false; draw(); });\n\n    // 主绘制函数\n    function draw(){\n      resizeCanvasToDisplaySize();\n      const w = canvas.width, h = canvas.height;\n      const p = getParams();\n      const trans = computeTransform(p, w, h);\n      drawGrid(ctx, trans);\n\n      // 绘制函数\n      if (p.showSin) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'sin', p.sinColor);\n      if (p.showCos) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'cos', p.cosColor);\n\n      // 悬停坐标显示\n      if (hover.show){\n        // draw vertical guide\n        const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n        function xToPx(x){ return left + (x - trans.xmin) / (trans.xmax - trans.xmin) * (right - left); }\n        function yToPx(y){ return top + (trans.ymax - y) / (trans.ymax - trans.ymin) * (bottom - top); }\n        const px = xToPx(hover.x);\n        const py = yToPx(hover.y);\n        ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n        ctx.stroke();\n\n        // show tooltip in top-right of canvas\n        const txt = `x=${hover.x.toFixed(3)}  y=${hover.y.toFixed(3)}`;\n        ctx.fillStyle = 'rgba(30,40,60,0.9)';\n        ctx.font = '12px system-ui,Segoe UI,Arial';\n        const padding = 6;\n        const metrics = ctx.measureText(txt);\n        const boxW = metrics.width + padding*2;\n        const boxH = 20;\n        const bx = canvas.width - boxW - 10;\n        const by = 10;\n        ctx.fillRect(bx, by, boxW, boxH);\n        ctx.fillStyle = '#fff';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(txt, bx + padding, by + boxH/2);\n      }\n\n      updateDisplays();\n    }\n\n    // 事件绑定\n    const inputElements = [amplitude, frequency, phase, vshift, xStart, xEnd, samples, showSin, showCos, sinColor, cosColor, lineWidth];\n    inputElements.forEach(el => el.addEventListener('input', ()=>{ draw(); }));\n\n    // 动画控制\n    toggleAnim.addEventListener('click', ()=>{\n      animState = !animState;\n      if (animState){\n        toggleAnim.textContent = '停止相位动画';\n        startAnimation();\n      } else {\n        toggleAnim.textContent = '开始相位动画';\n        stopAnimation();\n      }\n    });\n\n    function startAnimation(){\n      let last = performance.now();\n      function step(ts){\n        const dt = (ts - last) / 1000;\n        last = ts;\n        // 增加相位（phi）\n        const phiEl = phase;\n        const newPhi = parseFloat(phiEl.value) + animSpeed * dt;\n        phase.value = newPhi;\n        draw();\n        animId = requestAnimationFrame(step);\n      }\n      animId = requestAnimationFrame(step);\n    }\n    function stopAnimation(){\n      if (animId) cancelAnimationFrame(animId);\n      animId = null;\n    }\n\n    // 导出 PNG\n    exportBtn.addEventListener('click', ()=>{\n      // 将当前 canvas 转为 data URL 并触发下载\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      try {\n        link.href = canvas.toDataURL('image/png');\n        link.click();\n      } catch(e){\n        alert('导出失败：' + e);\n      }\n    });\n\n    // 重置\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1;\n      frequency.value = 1;\n      phase.value = 0;\n      vshift.value = 0;\n      xStart.value = -2;\n      xEnd.value = 2;\n      samples.value = 800;\n      showSin.checked = true;\n      showCos.checked = true;\n      sinColor.value = '#e34a6f';\n      cosColor.value = '#2b90ff';\n      lineWidth.value = 2;\n      draw();\n    });\n\n    // 鼠标滚轮缩放 X 轴（按住 shift 缩放 Y）\n    canvas.addEventListener('wheel', (ev)=>{\n      ev.preventDefault();\n      const delta = ev.deltaY;\n      const scaleFactor = (ev.shiftKey ? 0.05 : 0.15);\n      const x0mul = parseFloat(xStart.value);\n      const x1mul = parseFloat(xEnd.value);\n      const span = x1mul - x0mul;\n      const mid = (x1mul + x0mul) / 2;\n      const zoom = 1 + (delta > 0 ? scaleFactor : -scaleFactor);\n      let newSpan = span * zoom;\n      // 限制 span\n      newSpan = Math.min(Math.max(newSpan, 0.2), 12);\n      const newStart = mid - newSpan/2;\n      const newEnd = mid + newSpan/2;\n      xStart.value = newStart;\n      xEnd.value = newEnd;\n      draw();\n    }, { passive:false });\n\n    // 初始化绘制\n    window.addEventListener('resize', draw);\n    draw();\n  </script>",
                "css_content": ":root{\n      --bg:#f6f8fb;\n      --panel:#ffffff;\n      --accent:#2b90ff;\n      --muted:#666;\n      --border:#e0e6ef;\n    }\n    body{\n      margin:0;\n      font-family: \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n      background:var(--bg);\n      color:#122;\n      display:flex;\n      flex-direction:column;\n      min-height:100vh;\n    }\n    header{\n      padding:14px 20px;\n      background:linear-gradient(90deg, #ffffff, #f0f6ff);\n      border-bottom:1px solid var(--border);\n      display:flex;\n      align-items:center;\n      gap:12px;\n    }\n    header h1{\n      font-size:18px;\n      margin:0;\n    }\n    main{\n      display:flex;\n      gap:16px;\n      padding:16px;\n      flex:1;\n    }\n    .controls{\n      width:360px;\n      max-width:40%;\n      background:var(--panel);\n      border:1px solid var(--border);\n      border-radius:8px;\n      padding:14px;\n      box-shadow: 0 3px 12px rgba(18,34,68,0.04);\n      overflow:auto;\n      height: calc(100vh - 120px);\n    }\n    .canvas-wrap{\n      flex:1;\n      min-width:300px;\n      background:var(--panel);\n      border:1px solid var(--border);\n      border-radius:8px;\n      padding:10px;\n      display:flex;\n      flex-direction:column;\n      box-shadow: 0 3px 12px rgba(18,34,68,0.04);\n    }\n    label.block{\n      display:block;\n      font-size:13px;\n      color:var(--muted);\n      margin-top:10px;\n      margin-bottom:6px;\n    }\n    .row{\n      display:flex;\n      gap:10px;\n      align-items:center;\n    }\n    input[type=\"range\"]{\n      width:100%;\n    }\n    .small{\n      font-size:13px;\n      color:#234;\n    }\n    .controls .group{\n      padding:8px 0;\n      border-top:1px dashed #eef3fb;\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      margin-top:8px;\n      flex-wrap:wrap;\n    }\n    .legend .item{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .color-box{\n      width:16px;height:12px;border-radius:3px;border:1px solid #cfdff7;\n    }\n    canvas{\n      width:100%;\n      height:100%;\n      background:linear-gradient(180deg, #ffffff, #fbfdff);\n      border-radius:6px;\n    }\n    .controls button, .controls input[type=\"button\"]{\n      background:var(--accent);\n      color:white;\n      border:none;\n      padding:8px 10px;\n      border-radius:6px;\n      cursor:pointer;\n      font-size:14px;\n    }\n    .controls button.secondary{\n      background:#f0f4fa;color:#123;border:1px solid var(--border);\n    }\n    footer{\n      padding:10px 16px;\n      font-size:13px;\n      color:var(--muted);\n      border-top:1px solid var(--border);\n      background:#fff;\n    }\n    .val{\n      min-width:64px;\n      text-align:right;\n      font-weight:600;\n      color:#0b2b4a;\n    }\n    .flex-between{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n    }\n    .control-row{\n      display:flex;\n      gap:10px;\n      align-items:center;\n    }\n    @media (max-width:900px){\n      main{flex-direction:column;}\n      .controls{width:100%;max-width:none;height:auto;}\n      .canvas-wrap{order:-1;}\n    }",
                "js_content": "// 获取元素\n    const canvas = document.getElementById('plotCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    // canvas 内部像素尺寸与 css 宽高保持一致以保证清晰\n    function resizeCanvasToDisplaySize() {\n      const r = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.round(rect.width * r);\n      canvas.height = Math.round(rect.height * r);\n      ctx.setTransform(r,0,0,r,0,0);\n    }\n    // 控件\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xStart = document.getElementById('xStart');\n    const xEnd = document.getElementById('xEnd');\n    const samples = document.getElementById('samples');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const sinColor = document.getElementById('sinColor');\n    const cosColor = document.getElementById('cosColor');\n    const lineWidth = document.getElementById('lineWidth');\n    const toggleAnim = document.getElementById('toggleAnim');\n    const exportBtn = document.getElementById('exportBtn');\n    const resetBtn = document.getElementById('resetBtn');\n\n    // 显示值元素\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const xStartMul = document.getElementById('xStartMul');\n    const xEndMul = document.getElementById('xEndMul');\n    const samplesVal = document.getElementById('samplesVal');\n    const domainLabel = document.getElementById('domainLabel');\n\n    // 初始参数\n    let animState = false;\n    let animId = null;\n    let animSpeed = 1.2; // 每秒相位变化（弧度）\n    function getParams(){\n      return {\n        A: parseFloat(amplitude.value),\n        w: parseFloat(frequency.value),\n        phi: parseFloat(phase.value),\n        C: parseFloat(vshift.value),\n        x0: parseFloat(xStart.value) * Math.PI,\n        x1: parseFloat(xEnd.value) * Math.PI,\n        n: parseInt(samples.value,10),\n        showSin: showSin.checked,\n        showCos: showCos.checked,\n        sinColor: sinColor.value,\n        cosColor: cosColor.value,\n        lineWidth: parseInt(lineWidth.value,10)\n      };\n    }\n\n    // 更新显示值\n    function updateDisplays(){\n      const p = getParams();\n      ampVal.textContent = p.A.toFixed(2);\n      freqVal.textContent = p.w.toFixed(2);\n      phaseVal.textContent = p.phi.toFixed(3);\n      vshiftVal.textContent = p.C.toFixed(2);\n      xStartMul.textContent = (parseFloat(xStart.value)).toFixed(2);\n      xEndMul.textContent = (parseFloat(xEnd.value)).toFixed(2);\n      samplesVal.textContent = p.n;\n      domainLabel.textContent = `[${(p.x0/Math.PI).toFixed(2)}π, ${(p.x1/Math.PI).toFixed(2)}π]`;\n    }\n\n    // 坐标映射：将数学坐标映射到画布像素\n    function computeTransform(p, w, h, padding=40) {\n      // x from p.x0..p.x1 to px from padding..w-padding\n      const xmin = p.x0, xmax = p.x1;\n      // 为 y 轴自动缩放以包含振幅和 vshift，同时留一些边距\n      // 先估计 y 显示范围：基于 A 和 C\n      const A = p.A, C = p.C;\n      // 如果同时画 sin 和 cos，最大幅度仍是 A，所以：\n      const yMaxAbs = Math.max(Math.abs(C + A), Math.abs(C - A));\n      // 如果 yMaxAbs 太小，设置最小范围\n      const yRangeHalf = Math.max(yMaxAbs * 1.2, 1.0);\n      const ymin = C - yRangeHalf;\n      const ymax = C + yRangeHalf;\n      return {\n        xmin, xmax, ymin, ymax,\n        pxmin: padding, pxmax: w - padding, pymin: h - padding, pymax: padding\n      };\n    }\n\n    // 绘制坐标网格和坐标轴\n    function drawGrid(ctx, trans){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const w = ctx.canvas.width;\n      const h = ctx.canvas.height;\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,w,h);\n\n      // 内部绘图区尺寸\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      // 背景微格\n      ctx.fillStyle = '#fbfdff';\n      ctx.fillRect(left, top, right-left, bottom-top);\n\n      // 网格线：以 π 的刻度绘制竖线，如果区间较小，自动选择刻度\n      function xToPx(x){\n        return left + (x - xmin) / (xmax - xmin) * (right - left);\n      }\n      function yToPx(y){\n        return top + (ymax - y) / (ymax - ymin) * (bottom - top);\n      }\n\n      // 竖线：以 π/2 的倍数标记\n      const approxWidth = Math.abs(xmax - xmin);\n      // 选择刻度基准\n      let stepCandidate = Math.PI / 2; // default π/2\n      if (approxWidth > 12*Math.PI) stepCandidate = Math.PI * 2;\n      if (approxWidth < Math.PI/2) stepCandidate = Math.PI/8;\n      // round step to nearest power-of-two fractions of π\n      const step = stepCandidate;\n\n      ctx.strokeStyle = '#eef4ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = Math.round(xToPx(x)) + 0.5;\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // 横线\n      ctx.beginPath();\n      for (let y = Math.ceil(ymin)*(1); y <= ymax; y += Math.max( (ymax - ymin)/8, 0.5 )){\n        const py = Math.round(yToPx(y)) + 0.5;\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n\n      // 轴线 (x=0, y=0)\n      ctx.strokeStyle = '#b8c8e6';\n      ctx.lineWidth = 1.5;\n      ctx.beginPath();\n      if (xmin <= 0 && xmax >= 0){\n        const px0 = Math.round(xToPx(0)) + 0.5;\n        ctx.moveTo(px0, top);\n        ctx.lineTo(px0, bottom);\n      }\n      if (ymin <= 0 && ymax >= 0){\n        const py0 = Math.round(yToPx(0)) + 0.5;\n        ctx.moveTo(left, py0);\n        ctx.lineTo(right, py0);\n      }\n      ctx.stroke();\n\n      // 刻度标签 (x轴以 π 单位显示)\n      ctx.fillStyle = '#234';\n      ctx.font = \"12px system-ui,Segoe UI,Arial\";\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = xToPx(x);\n        // label as multiples of π when appropriate\n        let label;\n        const ratio = x / Math.PI;\n        if (Math.abs(ratio) < 1e-6) label = '0';\n        else if (Math.abs(ratio - Math.round(ratio)) < 1e-6) label = (Math.round(ratio)===1 ? 'π' : (Math.round(ratio)===-1 ? '-π' : (Math.round(ratio) + 'π')));\n        else {\n          label = ratio.toFixed(2) + 'π';\n        }\n        ctx.fillText(label, px, bottom + 6);\n      }\n\n      // y 轴标签\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      const yTicks = 5;\n      for (let i=0;i<=yTicks;i++){\n        const y = ymin + (ymax - ymin) * i / yTicks;\n        const py = yToPx(y);\n        ctx.fillText(y.toFixed(2), left - 8, py);\n      }\n    }\n\n    // 绘制函数曲线样条（简单线段连接）\n    function drawFunction(ctx, p, trans, funcType='sin', color='#f00'){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      const A = p.A, w = p.w, phi = p.phi, C = p.C;\n      const n = p.n;\n      const dx = (xmax - xmin) / (n - 1);\n      function xToPx(x){ return left + (x - xmin) / (xmax - xmin) * (right - left); }\n      function yToPx(y){ return top + (ymax - y) / (ymax - ymin) * (bottom - top); }\n\n      ctx.beginPath();\n      for (let i=0;i<n;i++){\n        const x = xmin + i * dx;\n        let y;\n        if (funcType === 'sin') y = A * Math.sin(w * x + phi) + C;\n        else y = A * Math.cos(w * x + phi) + C;\n        const px = xToPx(x);\n        const py = yToPx(y);\n        if (i===0) ctx.moveTo(px, py);\n        else ctx.lineTo(px, py);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = p.lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // 鼠标悬停显示坐标\n    let hover = {x:null,y:null,show:false};\n    canvas.addEventListener('mousemove', (ev)=>{\n      const rect = canvas.getBoundingClientRect();\n      const r = window.devicePixelRatio || 1;\n      const mouseX = (ev.clientX - rect.left) * r;\n      const mouseY = (ev.clientY - rect.top) * r;\n      const p = getParams();\n      const trans = computeTransform(p, canvas.width, canvas.height);\n      // convert pixel to math coords\n      const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n      if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {\n        hover.show = false;\n        return;\n      }\n      const x = trans.xmin + (mouseX - left) / (right - left) * (trans.xmax - trans.xmin);\n      const y = trans.ymax - (mouseY - top) / (bottom - top) * (trans.ymax - trans.ymin);\n      hover = {x,y,show:true};\n      draw(); // redraw to show overlay\n    });\n    canvas.addEventListener('mouseleave', ()=>{ hover.show=false; draw(); });\n\n    // 主绘制函数\n    function draw(){\n      resizeCanvasToDisplaySize();\n      const w = canvas.width, h = canvas.height;\n      const p = getParams();\n      const trans = computeTransform(p, w, h);\n      drawGrid(ctx, trans);\n\n      // 绘制函数\n      if (p.showSin) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'sin', p.sinColor);\n      if (p.showCos) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'cos', p.cosColor);\n\n      // 悬停坐标显示\n      if (hover.show){\n        // draw vertical guide\n        const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n        function xToPx(x){ return left + (x - trans.xmin) / (trans.xmax - trans.xmin) * (right - left); }\n        function yToPx(y){ return top + (trans.ymax - y) / (trans.ymax - trans.ymin) * (bottom - top); }\n        const px = xToPx(hover.x);\n        const py = yToPx(hover.y);\n        ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n        ctx.stroke();\n\n        // show tooltip in top-right of canvas\n        const txt = `x=${hover.x.toFixed(3)}  y=${hover.y.toFixed(3)}`;\n        ctx.fillStyle = 'rgba(30,40,60,0.9)';\n        ctx.font = '12px system-ui,Segoe UI,Arial';\n        const padding = 6;\n        const metrics = ctx.measureText(txt);\n        const boxW = metrics.width + padding*2;\n        const boxH = 20;\n        const bx = canvas.width - boxW - 10;\n        const by = 10;\n        ctx.fillRect(bx, by, boxW, boxH);\n        ctx.fillStyle = '#fff';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(txt, bx + padding, by + boxH/2);\n      }\n\n      updateDisplays();\n    }\n\n    // 事件绑定\n    const inputElements = [amplitude, frequency, phase, vshift, xStart, xEnd, samples, showSin, showCos, sinColor, cosColor, lineWidth];\n    inputElements.forEach(el => el.addEventListener('input', ()=>{ draw(); }));\n\n    // 动画控制\n    toggleAnim.addEventListener('click', ()=>{\n      animState = !animState;\n      if (animState){\n        toggleAnim.textContent = '停止相位动画';\n        startAnimation();\n      } else {\n        toggleAnim.textContent = '开始相位动画';\n        stopAnimation();\n      }\n    });\n\n    function startAnimation(){\n      let last = performance.now();\n      function step(ts){\n        const dt = (ts - last) / 1000;\n        last = ts;\n        // 增加相位（phi）\n        const phiEl = phase;\n        const newPhi = parseFloat(phiEl.value) + animSpeed * dt;\n        phase.value = newPhi;\n        draw();\n        animId = requestAnimationFrame(step);\n      }\n      animId = requestAnimationFrame(step);\n    }\n    function stopAnimation(){\n      if (animId) cancelAnimationFrame(animId);\n      animId = null;\n    }\n\n    // 导出 PNG\n    exportBtn.addEventListener('click', ()=>{\n      // 将当前 canvas 转为 data URL 并触发下载\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      try {\n        link.href = canvas.toDataURL('image/png');\n        link.click();\n      } catch(e){\n        alert('导出失败：' + e);\n      }\n    });\n\n    // 重置\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1;\n      frequency.value = 1;\n      phase.value = 0;\n      vshift.value = 0;\n      xStart.value = -2;\n      xEnd.value = 2;\n      samples.value = 800;\n      showSin.checked = true;\n      showCos.checked = true;\n      sinColor.value = '#e34a6f';\n      cosColor.value = '#2b90ff';\n      lineWidth.value = 2;\n      draw();\n    });\n\n    // 鼠标滚轮缩放 X 轴（按住 shift 缩放 Y）\n    canvas.addEventListener('wheel', (ev)=>{\n      ev.preventDefault();\n      const delta = ev.deltaY;\n      const scaleFactor = (ev.shiftKey ? 0.05 : 0.15);\n      const x0mul = parseFloat(xStart.value);\n      const x1mul = parseFloat(xEnd.value);\n      const span = x1mul - x0mul;\n      const mid = (x1mul + x0mul) / 2;\n      const zoom = 1 + (delta > 0 ? scaleFactor : -scaleFactor);\n      let newSpan = span * zoom;\n      // 限制 span\n      newSpan = Math.min(Math.max(newSpan, 0.2), 12);\n      const newStart = mid - newSpan/2;\n      const newEnd = mid + newSpan/2;\n      xStart.value = newStart;\n      xEnd.value = newEnd;\n      draw();\n    }, { passive:false });\n\n    // 初始化绘制\n    window.addEventListener('resize', draw);\n    draw();",
                "parameters": [],
                "status": "success"
              },
              "attempts": 1
            },
            "rawData": "{\"success\":true,\"data\":{\"experiment_id\":\"6fb2357d-dc47-41be-adec-cf62cf447aa7\",\"title\":\"sin / cos 可视化工具\",\"description\":\"总结（信息检索情况与核心概念）：\\n- 我对“创建一个数学函数可视化工具，能够绘制sin和cos函数”的维基百科检索没有找到针对该中文查询的直接结果（检索返回：没有找到相关信息）。\\n- 常见且可验证的数学事实（概念性说明）：\\n  - 正弦（sin）和余弦（cos）是周期函数，标准形式的周期为 2π。\\n  - 广义形式可写成 y = A * sin(ωx + φ) + C（或 cos），其中 A 是振幅，ω 是角频率（影响每单位 x 的振荡次数），φ 是相位（水平平移），C 是垂直平移。\\n  - 改变采样点数量会影响绘图平滑度；绘图范围（x 的区间）决定可视化的周期数量。\\n- 下面提供一个自包含的、可交互的 HTML 演示文件：可以绘制 sin 与 cos（单独或同时），可调参数：振幅、频率（角频率的倍数）、相位、纵向偏移、x 轴区间（以 π 的倍数设置）、采样点数、颜色等，并提供动画相位选项与导出图片按钮。\\n\\n完整可运行 HTML 代码（保存为 .html 并在浏览器中打开）：\",\"html_content\":\"<header>\\n    <h1>sin / cos 可视化工具</h1>\\n    <div style=\\\"color:var(--muted);font-size:13px;\\\">调整参数观察正弦和余弦函数行为（安全的浏览器内模拟）</div>\\n  </header>\\n\\n  <main>\\n    <aside class=\\\"controls\\\" aria-label=\\\"控制面板\\\">\\n      <div>\\n        <div class=\\\"flex-between\\\">\\n          <div>\\n            <label class=\\\"block\\\">绘制函数</label>\\n            <div class=\\\"row\\\">\\n              <label style=\\\"display:flex;align-items:center;gap:8px;\\\">\\n                <input type=\\\"checkbox\\\" id=\\\"showSin\\\" checked /> sin(x)\\n              </label>\\n              <label style=\\\"display:flex;align-items:center;gap:8px;\\\">\\n                <input type=\\\"checkbox\\\" id=\\\"showCos\\\" checked /> cos(x)\\n              </label>\\n            </div>\\n          </div>\\n          <div>\\n            <button id=\\\"resetBtn\\\" title=\\\"恢复默认参数\\\">重置</button>\\n          </div>\\n        </div>\\n\\n        <div class=\\\"group\\\">\\n          <label class=\\\"block\\\">振幅 A：<span id=\\\"ampVal\\\" class=\\\"val\\\">1.00</span></label>\\n          <input type=\\\"range\\\" id=\\\"amplitude\\\" min=\\\"0\\\" max=\\\"5\\\" step=\\\"0.01\\\" value=\\\"1\\\">\\n\\n          <label class=\\\"block\\\">频率 ω（乘以 x）：<span id=\\\"freqVal\\\" class=\\\"val\\\">1.00</span></label>\\n          <input type=\\\"range\\\" id=\\\"frequency\\\" min=\\\"0\\\" max=\\\"6\\\" step=\\\"0.01\\\" value=\\\"1\\\">\\n\\n          <label class=\\\"block\\\">相位 φ（弧度）：<span id=\\\"phaseVal\\\" class=\\\"val\\\">0.00</span></label>\\n          <input type=\\\"range\\\" id=\\\"phase\\\" min=\\\"-6.283\\\" max=\\\"6.283\\\" step=\\\"0.001\\\" value=\\\"0\\\">\\n\\n          <label class=\\\"block\\\">垂直偏移 C：<span id=\\\"vshiftVal\\\" class=\\\"val\\\">0.00</span></label>\\n          <input type=\\\"range\\\" id=\\\"vshift\\\" min=\\\"-5\\\" max=\\\"5\\\" step=\\\"0.01\\\" value=\\\"0\\\">\\n        </div>\\n\\n        <div class=\\\"group\\\">\\n          <label class=\\\"block\\\">x 轴区间（以 π 的倍数）</label>\\n          <div class=\\\"row\\\">\\n            <div style=\\\"flex:1\\\">\\n              <label class=\\\"small\\\">起点 (π * <span id=\\\"xStartMul\\\">-2</span>)</label>\\n              <input type=\\\"range\\\" id=\\\"xStart\\\" min=\\\"-6\\\" max=\\\"0\\\" step=\\\"0.1\\\" value=\\\"-2\\\">\\n            </div>\\n            <div style=\\\"width:14px\\\"></div>\\n            <div style=\\\"flex:1\\\">\\n              <label class=\\\"small\\\">终点 (π * <span id=\\\"xEndMul\\\">2</span>)</label>\\n              <input type=\\\"range\\\" id=\\\"xEnd\\\" min=\\\"0\\\" max=\\\"6\\\" step=\\\"0.1\\\" value=\\\"2\\\">\\n            </div>\\n          </div>\\n\\n          <label class=\\\"block\\\">采样点数：<span id=\\\"samplesVal\\\" class=\\\"val\\\">800</span></label>\\n          <input type=\\\"range\\\" id=\\\"samples\\\" min=\\\"100\\\" max=\\\"3000\\\" step=\\\"10\\\" value=\\\"800\\\">\\n        </div>\\n\\n        <div class=\\\"group\\\">\\n          <label class=\\\"block\\\">颜色与样式</label>\\n          <div class=\\\"legend\\\">\\n            <div class=\\\"item\\\">\\n              <input type=\\\"color\\\" id=\\\"sinColor\\\" value=\\\"#e34a6f\\\">\\n              <div>sin</div>\\n            </div>\\n            <div class=\\\"item\\\">\\n              <input type=\\\"color\\\" id=\\\"cosColor\\\" value=\\\"#2b90ff\\\">\\n              <div>cos</div>\\n            </div>\\n            <div style=\\\"margin-left:8px\\\" class=\\\"item\\\">\\n              <label style=\\\"display:flex;align-items:center;gap:6px;\\\">\\n                线宽：\\n                <input id=\\\"lineWidth\\\" type=\\\"range\\\" min=\\\"1\\\" max=\\\"6\\\" step=\\\"1\\\" value=\\\"2\\\" />\\n              </label>\\n            </div>\\n          </div>\\n        </div>\\n\\n        <div class=\\\"group\\\">\\n          <label class=\\\"block\\\">动画与导出</label>\\n          <div class=\\\"row\\\" style=\\\"gap:8px;\\\">\\n            <button id=\\\"toggleAnim\\\">开始相位动画</button>\\n            <button class=\\\"secondary\\\" id=\\\"exportBtn\\\">导出 PNG</button>\\n          </div>\\n          <div style=\\\"margin-top:10px;font-size:13px;color:var(--muted);\\\">\\n            相位动画会连续改变 φ 值以看到波形移动。导出会把当前画布保存为图片。\\n          </div>\\n        </div>\\n\\n        <div class=\\\"group\\\">\\n          <label class=\\\"block\\\">提示</label>\\n          <div style=\\\"font-size:13px;color:var(--muted);line-height:1.5;\\\">\\n            - 频率越大，同一区间内周期越多；相位改变会水平移动波形；振幅决定上下张开程度。<br>\\n            - x 轴区间单位是 π：例如 -2 到 2 表示 [-2π, 2π]。<br>\\n            - 采样点越多曲线越平滑，但计算开销增大。\\n          </div>\\n        </div>\\n\\n      </div>\\n    </aside>\\n\\n    <section class=\\\"canvas-wrap\\\" aria-label=\\\"绘图区域\\\">\\n      <div style=\\\"display:flex;align-items:center;justify-content:space-between;padding:6px 6px 10px 6px;\\\">\\n        <div style=\\\"font-weight:600\\\">绘图预览</div>\\n        <div style=\\\"color:var(--muted);font-size:13px;\\\" id=\\\"domainLabel\\\"></div>\\n      </div>\\n      <div style=\\\"flex:1;min-height:320px;display:flex;flex-direction:column;\\\">\\n        <canvas id=\\\"plotCanvas\\\" width=\\\"1200\\\" height=\\\"600\\\" role=\\\"img\\\" aria-label=\\\"函数绘图画布\\\"></canvas>\\n      </div>\\n      <footer>\\n        鼠标悬停画布上可以看到对应 x, y 值（右上角坐标）。输入框与滑块会即时更新图形。\\n      </footer>\\n    </section>\\n  </main>\\n\\n  <script>\\n    // 获取元素\\n    const canvas = document.getElementById('plotCanvas');\\n    const ctx = canvas.getContext('2d', { alpha: false });\\n    // canvas 内部像素尺寸与 css 宽高保持一致以保证清晰\\n    function resizeCanvasToDisplaySize() {\\n      const r = window.devicePixelRatio || 1;\\n      const rect = canvas.getBoundingClientRect();\\n      canvas.width = Math.round(rect.width * r);\\n      canvas.height = Math.round(rect.height * r);\\n      ctx.setTransform(r,0,0,r,0,0);\\n    }\\n    // 控件\\n    const amplitude = document.getElementById('amplitude');\\n    const frequency = document.getElementById('frequency');\\n    const phase = document.getElementById('phase');\\n    const vshift = document.getElementById('vshift');\\n    const xStart = document.getElementById('xStart');\\n    const xEnd = document.getElementById('xEnd');\\n    const samples = document.getElementById('samples');\\n    const showSin = document.getElementById('showSin');\\n    const showCos = document.getElementById('showCos');\\n    const sinColor = document.getElementById('sinColor');\\n    const cosColor = document.getElementById('cosColor');\\n    const lineWidth = document.getElementById('lineWidth');\\n    const toggleAnim = document.getElementById('toggleAnim');\\n    const exportBtn = document.getElementById('exportBtn');\\n    const resetBtn = document.getElementById('resetBtn');\\n\\n    // 显示值元素\\n    const ampVal = document.getElementById('ampVal');\\n    const freqVal = document.getElementById('freqVal');\\n    const phaseVal = document.getElementById('phaseVal');\\n    const vshiftVal = document.getElementById('vshiftVal');\\n    const xStartMul = document.getElementById('xStartMul');\\n    const xEndMul = document.getElementById('xEndMul');\\n    const samplesVal = document.getElementById('samplesVal');\\n    const domainLabel = document.getElementById('domainLabel');\\n\\n    // 初始参数\\n    let animState = false;\\n    let animId = null;\\n    let animSpeed = 1.2; // 每秒相位变化（弧度）\\n    function getParams(){\\n      return {\\n        A: parseFloat(amplitude.value),\\n        w: parseFloat(frequency.value),\\n        phi: parseFloat(phase.value),\\n        C: parseFloat(vshift.value),\\n        x0: parseFloat(xStart.value) * Math.PI,\\n        x1: parseFloat(xEnd.value) * Math.PI,\\n        n: parseInt(samples.value,10),\\n        showSin: showSin.checked,\\n        showCos: showCos.checked,\\n        sinColor: sinColor.value,\\n        cosColor: cosColor.value,\\n        lineWidth: parseInt(lineWidth.value,10)\\n      };\\n    }\\n\\n    // 更新显示值\\n    function updateDisplays(){\\n      const p = getParams();\\n      ampVal.textContent = p.A.toFixed(2);\\n      freqVal.textContent = p.w.toFixed(2);\\n      phaseVal.textContent = p.phi.toFixed(3);\\n      vshiftVal.textContent = p.C.toFixed(2);\\n      xStartMul.textContent = (parseFloat(xStart.value)).toFixed(2);\\n      xEndMul.textContent = (parseFloat(xEnd.value)).toFixed(2);\\n      samplesVal.textContent = p.n;\\n      domainLabel.textContent = `[${(p.x0/Math.PI).toFixed(2)}π, ${(p.x1/Math.PI).toFixed(2)}π]`;\\n    }\\n\\n    // 坐标映射：将数学坐标映射到画布像素\\n    function computeTransform(p, w, h, padding=40) {\\n      // x from p.x0..p.x1 to px from padding..w-padding\\n      const xmin = p.x0, xmax = p.x1;\\n      // 为 y 轴自动缩放以包含振幅和 vshift，同时留一些边距\\n      // 先估计 y 显示范围：基于 A 和 C\\n      const A = p.A, C = p.C;\\n      // 如果同时画 sin 和 cos，最大幅度仍是 A，所以：\\n      const yMaxAbs = Math.max(Math.abs(C + A), Math.abs(C - A));\\n      // 如果 yMaxAbs 太小，设置最小范围\\n      const yRangeHalf = Math.max(yMaxAbs * 1.2, 1.0);\\n      const ymin = C - yRangeHalf;\\n      const ymax = C + yRangeHalf;\\n      return {\\n        xmin, xmax, ymin, ymax,\\n        pxmin: padding, pxmax: w - padding, pymin: h - padding, pymax: padding\\n      };\\n    }\\n\\n    // 绘制坐标网格和坐标轴\\n    function drawGrid(ctx, trans){\\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\\n      const w = ctx.canvas.width;\\n      const h = ctx.canvas.height;\\n      ctx.fillStyle = '#ffffff';\\n      ctx.fillRect(0,0,w,h);\\n\\n      // 内部绘图区尺寸\\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\\n      // 背景微格\\n      ctx.fillStyle = '#fbfdff';\\n      ctx.fillRect(left, top, right-left, bottom-top);\\n\\n      // 网格线：以 π 的刻度绘制竖线，如果区间较小，自动选择刻度\\n      function xToPx(x){\\n        return left + (x - xmin) / (xmax - xmin) * (right - left);\\n      }\\n      function yToPx(y){\\n        return top + (ymax - y) / (ymax - ymin) * (bottom - top);\\n      }\\n\\n      // 竖线：以 π/2 的倍数标记\\n      const approxWidth = Math.abs(xmax - xmin);\\n      // 选择刻度基准\\n      let stepCandidate = Math.PI / 2; // default π/2\\n      if (approxWidth > 12*Math.PI) stepCandidate = Math.PI * 2;\\n      if (approxWidth < Math.PI/2) stepCandidate = Math.PI/8;\\n      // round step to nearest power-of-two fractions of π\\n      const step = stepCandidate;\\n\\n      ctx.strokeStyle = '#eef4ff';\\n      ctx.lineWidth = 1;\\n      ctx.beginPath();\\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\\n        const px = Math.round(xToPx(x)) + 0.5;\\n        ctx.moveTo(px, top);\\n        ctx.lineTo(px, bottom);\\n      }\\n      ctx.stroke();\\n\\n      // 横线\\n      ctx.beginPath();\\n      for (let y = Math.ceil(ymin)*(1); y <= ymax; y += Math.max( (ymax - ymin)/8, 0.5 )){\\n        const py = Math.round(yToPx(y)) + 0.5;\\n        ctx.moveTo(left, py);\\n        ctx.lineTo(right, py);\\n      }\\n      ctx.stroke();\\n\\n      // 轴线 (x=0, y=0)\\n      ctx.strokeStyle = '#b8c8e6';\\n      ctx.lineWidth = 1.5;\\n      ctx.beginPath();\\n      if (xmin <= 0 && xmax >= 0){\\n        const px0 = Math.round(xToPx(0)) + 0.5;\\n        ctx.moveTo(px0, top);\\n        ctx.lineTo(px0, bottom);\\n      }\\n      if (ymin <= 0 && ymax >= 0){\\n        const py0 = Math.round(yToPx(0)) + 0.5;\\n        ctx.moveTo(left, py0);\\n        ctx.lineTo(right, py0);\\n      }\\n      ctx.stroke();\\n\\n      // 刻度标签 (x轴以 π 单位显示)\\n      ctx.fillStyle = '#234';\\n      ctx.font = \\\"12px system-ui,Segoe UI,Arial\\\";\\n      ctx.textAlign = 'center';\\n      ctx.textBaseline = 'top';\\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\\n        const px = xToPx(x);\\n        // label as multiples of π when appropriate\\n        let label;\\n        const ratio = x / Math.PI;\\n        if (Math.abs(ratio) < 1e-6) label = '0';\\n        else if (Math.abs(ratio - Math.round(ratio)) < 1e-6) label = (Math.round(ratio)===1 ? 'π' : (Math.round(ratio)===-1 ? '-π' : (Math.round(ratio) + 'π')));\\n        else {\\n          label = ratio.toFixed(2) + 'π';\\n        }\\n        ctx.fillText(label, px, bottom + 6);\\n      }\\n\\n      // y 轴标签\\n      ctx.textAlign = 'right';\\n      ctx.textBaseline = 'middle';\\n      const yTicks = 5;\\n      for (let i=0;i<=yTicks;i++){\\n        const y = ymin + (ymax - ymin) * i / yTicks;\\n        const py = yToPx(y);\\n        ctx.fillText(y.toFixed(2), left - 8, py);\\n      }\\n    }\\n\\n    // 绘制函数曲线样条（简单线段连接）\\n    function drawFunction(ctx, p, trans, funcType='sin', color='#f00'){\\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\\n      const A = p.A, w = p.w, phi = p.phi, C = p.C;\\n      const n = p.n;\\n      const dx = (xmax - xmin) / (n - 1);\\n      function xToPx(x){ return left + (x - xmin) / (xmax - xmin) * (right - left); }\\n      function yToPx(y){ return top + (ymax - y) / (ymax - ymin) * (bottom - top); }\\n\\n      ctx.beginPath();\\n      for (let i=0;i<n;i++){\\n        const x = xmin + i * dx;\\n        let y;\\n        if (funcType === 'sin') y = A * Math.sin(w * x + phi) + C;\\n        else y = A * Math.cos(w * x + phi) + C;\\n        const px = xToPx(x);\\n        const py = yToPx(y);\\n        if (i===0) ctx.moveTo(px, py);\\n        else ctx.lineTo(px, py);\\n      }\\n      ctx.strokeStyle = color;\\n      ctx.lineWidth = p.lineWidth;\\n      ctx.lineJoin = 'round';\\n      ctx.lineCap = 'round';\\n      ctx.stroke();\\n    }\\n\\n    // 鼠标悬停显示坐标\\n    let hover = {x:null,y:null,show:false};\\n    canvas.addEventListener('mousemove', (ev)=>{\\n      const rect = canvas.getBoundingClientRect();\\n      const r = window.devicePixelRatio || 1;\\n      const mouseX = (ev.clientX - rect.left) * r;\\n      const mouseY = (ev.clientY - rect.top) * r;\\n      const p = getParams();\\n      const trans = computeTransform(p, canvas.width, canvas.height);\\n      // convert pixel to math coords\\n      const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\\n      if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {\\n        hover.show = false;\\n        return;\\n      }\\n      const x = trans.xmin + (mouseX - left) / (right - left) * (trans.xmax - trans.xmin);\\n      const y = trans.ymax - (mouseY - top) / (bottom - top) * (trans.ymax - trans.ymin);\\n      hover = {x,y,show:true};\\n      draw(); // redraw to show overlay\\n    });\\n    canvas.addEventListener('mouseleave', ()=>{ hover.show=false; draw(); });\\n\\n    // 主绘制函数\\n    function draw(){\\n      resizeCanvasToDisplaySize();\\n      const w = canvas.width, h = canvas.height;\\n      const p = getParams();\\n      const trans = computeTransform(p, w, h);\\n      drawGrid(ctx, trans);\\n\\n      // 绘制函数\\n      if (p.showSin) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'sin', p.sinColor);\\n      if (p.showCos) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'cos', p.cosColor);\\n\\n      // 悬停坐标显示\\n      if (hover.show){\\n        // draw vertical guide\\n        const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\\n        function xToPx(x){ return left + (x - trans.xmin) / (trans.xmax - trans.xmin) * (right - left); }\\n        function yToPx(y){ return top + (trans.ymax - y) / (trans.ymax - trans.ymin) * (bottom - top); }\\n        const px = xToPx(hover.x);\\n        const py = yToPx(hover.y);\\n        ctx.strokeStyle = 'rgba(0,0,0,0.12)';\\n        ctx.lineWidth = 1;\\n        ctx.beginPath();\\n        ctx.moveTo(px, top);\\n        ctx.lineTo(px, bottom);\\n        ctx.stroke();\\n\\n        // show tooltip in top-right of canvas\\n        const txt = `x=${hover.x.toFixed(3)}  y=${hover.y.toFixed(3)}`;\\n        ctx.fillStyle = 'rgba(30,40,60,0.9)';\\n        ctx.font = '12px system-ui,Segoe UI,Arial';\\n        const padding = 6;\\n        const metrics = ctx.measureText(txt);\\n        const boxW = metrics.width + padding*2;\\n        const boxH = 20;\\n        const bx = canvas.width - boxW - 10;\\n        const by = 10;\\n        ctx.fillRect(bx, by, boxW, boxH);\\n        ctx.fillStyle = '#fff';\\n        ctx.textAlign = 'left';\\n        ctx.textBaseline = 'middle';\\n        ctx.fillText(txt, bx + padding, by + boxH/2);\\n      }\\n\\n      updateDisplays();\\n    }\\n\\n    // 事件绑定\\n    const inputElements = [amplitude, frequency, phase, vshift, xStart, xEnd, samples, showSin, showCos, sinColor, cosColor, lineWidth];\\n    inputElements.forEach(el => el.addEventListener('input', ()=>{ draw(); }));\\n\\n    // 动画控制\\n    toggleAnim.addEventListener('click', ()=>{\\n      animState = !animState;\\n      if (animState){\\n        toggleAnim.textContent = '停止相位动画';\\n        startAnimation();\\n      } else {\\n        toggleAnim.textContent = '开始相位动画';\\n        stopAnimation();\\n      }\\n    });\\n\\n    function startAnimation(){\\n      let last = performance.now();\\n      function step(ts){\\n        const dt = (ts - last) / 1000;\\n        last = ts;\\n        // 增加相位（phi）\\n        const phiEl = phase;\\n        const newPhi = parseFloat(phiEl.value) + animSpeed * dt;\\n        phase.value = newPhi;\\n        draw();\\n        animId = requestAnimationFrame(step);\\n      }\\n      animId = requestAnimationFrame(step);\\n    }\\n    function stopAnimation(){\\n      if (animId) cancelAnimationFrame(animId);\\n      animId = null;\\n    }\\n\\n    // 导出 PNG\\n    exportBtn.addEventListener('click', ()=>{\\n      // 将当前 canvas 转为 data URL 并触发下载\\n      const link = document.createElement('a');\\n      link.download = 'sin_cos_plot.png';\\n      try {\\n        link.href = canvas.toDataURL('image/png');\\n        link.click();\\n      } catch(e){\\n        alert('导出失败：' + e);\\n      }\\n    });\\n\\n    // 重置\\n    resetBtn.addEventListener('click', ()=>{\\n      amplitude.value = 1;\\n      frequency.value = 1;\\n      phase.value = 0;\\n      vshift.value = 0;\\n      xStart.value = -2;\\n      xEnd.value = 2;\\n      samples.value = 800;\\n      showSin.checked = true;\\n      showCos.checked = true;\\n      sinColor.value = '#e34a6f';\\n      cosColor.value = '#2b90ff';\\n      lineWidth.value = 2;\\n      draw();\\n    });\\n\\n    // 鼠标滚轮缩放 X 轴（按住 shift 缩放 Y）\\n    canvas.addEventListener('wheel', (ev)=>{\\n      ev.preventDefault();\\n      const delta = ev.deltaY;\\n      const scaleFactor = (ev.shiftKey ? 0.05 : 0.15);\\n      const x0mul = parseFloat(xStart.value);\\n      const x1mul = parseFloat(xEnd.value);\\n      const span = x1mul - x0mul;\\n      const mid = (x1mul + x0mul) / 2;\\n      const zoom = 1 + (delta > 0 ? scaleFactor : -scaleFactor);\\n      let newSpan = span * zoom;\\n      // 限制 span\\n      newSpan = Math.min(Math.max(newSpan, 0.2), 12);\\n      const newStart = mid - newSpan/2;\\n      const newEnd = mid + newSpan/2;\\n      xStart.value = newStart;\\n      xEnd.value = newEnd;\\n      draw();\\n    }, { passive:false });\\n\\n    // 初始化绘制\\n    window.addEventListener('resize', draw);\\n    draw();\\n  </script>\",\"css_content\":\":root{\\n      --bg:#f6f8fb;\\n      --panel:#ffffff;\\n      --accent:#2b90ff;\\n      --muted:#666;\\n      --border:#e0e6ef;\\n    }\\n    body{\\n      margin:0;\\n      font-family: \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, sans-serif;\\n      background:var(--bg);\\n      color:#122;\\n      display:flex;\\n      flex-direction:column;\\n      min-height:100vh;\\n    }\\n    header{\\n      padding:14px 20px;\\n      background:linear-gradient(90deg, #ffffff, #f0f6ff);\\n      border-bottom:1px solid var(--border);\\n      display:flex;\\n      align-items:center;\\n      gap:12px;\\n    }\\n    header h1{\\n      font-size:18px;\\n      margin:0;\\n    }\\n    main{\\n      display:flex;\\n      gap:16px;\\n      padding:16px;\\n      flex:1;\\n    }\\n    .controls{\\n      width:360px;\\n      max-width:40%;\\n      background:var(--panel);\\n      border:1px solid var(--border);\\n      border-radius:8px;\\n      padding:14px;\\n      box-shadow: 0 3px 12px rgba(18,34,68,0.04);\\n      overflow:auto;\\n      height: calc(100vh - 120px);\\n    }\\n    .canvas-wrap{\\n      flex:1;\\n      min-width:300px;\\n      background:var(--panel);\\n      border:1px solid var(--border);\\n      border-radius:8px;\\n      padding:10px;\\n      display:flex;\\n      flex-direction:column;\\n      box-shadow: 0 3px 12px rgba(18,34,68,0.04);\\n    }\\n    label.block{\\n      display:block;\\n      font-size:13px;\\n      color:var(--muted);\\n      margin-top:10px;\\n      margin-bottom:6px;\\n    }\\n    .row{\\n      display:flex;\\n      gap:10px;\\n      align-items:center;\\n    }\\n    input[type=\\\"range\\\"]{\\n      width:100%;\\n    }\\n    .small{\\n      font-size:13px;\\n      color:#234;\\n    }\\n    .controls .group{\\n      padding:8px 0;\\n      border-top:1px dashed #eef3fb;\\n    }\\n    .legend{\\n      display:flex;\\n      gap:12px;\\n      align-items:center;\\n      margin-top:8px;\\n      flex-wrap:wrap;\\n    }\\n    .legend .item{\\n      display:flex;\\n      gap:8px;\\n      align-items:center;\\n      font-size:13px;\\n      color:var(--muted);\\n    }\\n    .color-box{\\n      width:16px;height:12px;border-radius:3px;border:1px solid #cfdff7;\\n    }\\n    canvas{\\n      width:100%;\\n      height:100%;\\n      background:linear-gradient(180deg, #ffffff, #fbfdff);\\n      border-radius:6px;\\n    }\\n    .controls button, .controls input[type=\\\"button\\\"]{\\n      background:var(--accent);\\n      color:white;\\n      border:none;\\n      padding:8px 10px;\\n      border-radius:6px;\\n      cursor:pointer;\\n      font-size:14px;\\n    }\\n    .controls button.secondary{\\n      background:#f0f4fa;color:#123;border:1px solid var(--border);\\n    }\\n    footer{\\n      padding:10px 16px;\\n      font-size:13px;\\n      color:var(--muted);\\n      border-top:1px solid var(--border);\\n      background:#fff;\\n    }\\n    .val{\\n      min-width:64px;\\n      text-align:right;\\n      font-weight:600;\\n      color:#0b2b4a;\\n    }\\n    .flex-between{\\n      display:flex;\\n      justify-content:space-between;\\n      align-items:center;\\n    }\\n    .control-row{\\n      display:flex;\\n      gap:10px;\\n      align-items:center;\\n    }\\n    @media (max-width:900px){\\n      main{flex-direction:column;}\\n      .controls{width:100%;max-width:none;height:auto;}\\n      .canvas-wrap{order:-1;}\\n    }\",\"js_content\":\"// 获取元素\\n    const canvas = document.getElementById('plotCanvas');\\n    const ctx = canvas.getContext('2d', { alpha: false });\\n    // canvas 内部像素尺寸与 css 宽高保持一致以保证清晰\\n    function resizeCanvasToDisplaySize() {\\n      const r = window.devicePixelRatio || 1;\\n      const rect = canvas.getBoundingClientRect();\\n      canvas.width = Math.round(rect.width * r);\\n      canvas.height = Math.round(rect.height * r);\\n      ctx.setTransform(r,0,0,r,0,0);\\n    }\\n    // 控件\\n    const amplitude = document.getElementById('amplitude');\\n    const frequency = document.getElementById('frequency');\\n    const phase = document.getElementById('phase');\\n    const vshift = document.getElementById('vshift');\\n    const xStart = document.getElementById('xStart');\\n    const xEnd = document.getElementById('xEnd');\\n    const samples = document.getElementById('samples');\\n    const showSin = document.getElementById('showSin');\\n    const showCos = document.getElementById('showCos');\\n    const sinColor = document.getElementById('sinColor');\\n    const cosColor = document.getElementById('cosColor');\\n    const lineWidth = document.getElementById('lineWidth');\\n    const toggleAnim = document.getElementById('toggleAnim');\\n    const exportBtn = document.getElementById('exportBtn');\\n    const resetBtn = document.getElementById('resetBtn');\\n\\n    // 显示值元素\\n    const ampVal = document.getElementById('ampVal');\\n    const freqVal = document.getElementById('freqVal');\\n    const phaseVal = document.getElementById('phaseVal');\\n    const vshiftVal = document.getElementById('vshiftVal');\\n    const xStartMul = document.getElementById('xStartMul');\\n    const xEndMul = document.getElementById('xEndMul');\\n    const samplesVal = document.getElementById('samplesVal');\\n    const domainLabel = document.getElementById('domainLabel');\\n\\n    // 初始参数\\n    let animState = false;\\n    let animId = null;\\n    let animSpeed = 1.2; // 每秒相位变化（弧度）\\n    function getParams(){\\n      return {\\n        A: parseFloat(amplitude.value),\\n        w: parseFloat(frequency.value),\\n        phi: parseFloat(phase.value),\\n        C: parseFloat(vshift.value),\\n        x0: parseFloat(xStart.value) * Math.PI,\\n        x1: parseFloat(xEnd.value) * Math.PI,\\n        n: parseInt(samples.value,10),\\n        showSin: showSin.checked,\\n        showCos: showCos.checked,\\n        sinColor: sinColor.value,\\n        cosColor: cosColor.value,\\n        lineWidth: parseInt(lineWidth.value,10)\\n      };\\n    }\\n\\n    // 更新显示值\\n    function updateDisplays(){\\n      const p = getParams();\\n      ampVal.textContent = p.A.toFixed(2);\\n      freqVal.textContent = p.w.toFixed(2);\\n      phaseVal.textContent = p.phi.toFixed(3);\\n      vshiftVal.textContent = p.C.toFixed(2);\\n      xStartMul.textContent = (parseFloat(xStart.value)).toFixed(2);\\n      xEndMul.textContent = (parseFloat(xEnd.value)).toFixed(2);\\n      samplesVal.textContent = p.n;\\n      domainLabel.textContent = `[${(p.x0/Math.PI).toFixed(2)}π, ${(p.x1/Math.PI).toFixed(2)}π]`;\\n    }\\n\\n    // 坐标映射：将数学坐标映射到画布像素\\n    function computeTransform(p, w, h, padding=40) {\\n      // x from p.x0..p.x1 to px from padding..w-padding\\n      const xmin = p.x0, xmax = p.x1;\\n      // 为 y 轴自动缩放以包含振幅和 vshift，同时留一些边距\\n      // 先估计 y 显示范围：基于 A 和 C\\n      const A = p.A, C = p.C;\\n      // 如果同时画 sin 和 cos，最大幅度仍是 A，所以：\\n      const yMaxAbs = Math.max(Math.abs(C + A), Math.abs(C - A));\\n      // 如果 yMaxAbs 太小，设置最小范围\\n      const yRangeHalf = Math.max(yMaxAbs * 1.2, 1.0);\\n      const ymin = C - yRangeHalf;\\n      const ymax = C + yRangeHalf;\\n      return {\\n        xmin, xmax, ymin, ymax,\\n        pxmin: padding, pxmax: w - padding, pymin: h - padding, pymax: padding\\n      };\\n    }\\n\\n    // 绘制坐标网格和坐标轴\\n    function drawGrid(ctx, trans){\\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\\n      const w = ctx.canvas.width;\\n      const h = ctx.canvas.height;\\n      ctx.fillStyle = '#ffffff';\\n      ctx.fillRect(0,0,w,h);\\n\\n      // 内部绘图区尺寸\\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\\n      // 背景微格\\n      ctx.fillStyle = '#fbfdff';\\n      ctx.fillRect(left, top, right-left, bottom-top);\\n\\n      // 网格线：以 π 的刻度绘制竖线，如果区间较小，自动选择刻度\\n      function xToPx(x){\\n        return left + (x - xmin) / (xmax - xmin) * (right - left);\\n      }\\n      function yToPx(y){\\n        return top + (ymax - y) / (ymax - ymin) * (bottom - top);\\n      }\\n\\n      // 竖线：以 π/2 的倍数标记\\n      const approxWidth = Math.abs(xmax - xmin);\\n      // 选择刻度基准\\n      let stepCandidate = Math.PI / 2; // default π/2\\n      if (approxWidth > 12*Math.PI) stepCandidate = Math.PI * 2;\\n      if (approxWidth < Math.PI/2) stepCandidate = Math.PI/8;\\n      // round step to nearest power-of-two fractions of π\\n      const step = stepCandidate;\\n\\n      ctx.strokeStyle = '#eef4ff';\\n      ctx.lineWidth = 1;\\n      ctx.beginPath();\\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\\n        const px = Math.round(xToPx(x)) + 0.5;\\n        ctx.moveTo(px, top);\\n        ctx.lineTo(px, bottom);\\n      }\\n      ctx.stroke();\\n\\n      // 横线\\n      ctx.beginPath();\\n      for (let y = Math.ceil(ymin)*(1); y <= ymax; y += Math.max( (ymax - ymin)/8, 0.5 )){\\n        const py = Math.round(yToPx(y)) + 0.5;\\n        ctx.moveTo(left, py);\\n        ctx.lineTo(right, py);\\n      }\\n      ctx.stroke();\\n\\n      // 轴线 (x=0, y=0)\\n      ctx.strokeStyle = '#b8c8e6';\\n      ctx.lineWidth = 1.5;\\n      ctx.beginPath();\\n      if (xmin <= 0 && xmax >= 0){\\n        const px0 = Math.round(xToPx(0)) + 0.5;\\n        ctx.moveTo(px0, top);\\n        ctx.lineTo(px0, bottom);\\n      }\\n      if (ymin <= 0 && ymax >= 0){\\n        const py0 = Math.round(yToPx(0)) + 0.5;\\n        ctx.moveTo(left, py0);\\n        ctx.lineTo(right, py0);\\n      }\\n      ctx.stroke();\\n\\n      // 刻度标签 (x轴以 π 单位显示)\\n      ctx.fillStyle = '#234';\\n      ctx.font = \\\"12px system-ui,Segoe UI,Arial\\\";\\n      ctx.textAlign = 'center';\\n      ctx.textBaseline = 'top';\\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\\n        const px = xToPx(x);\\n        // label as multiples of π when appropriate\\n        let label;\\n        const ratio = x / Math.PI;\\n        if (Math.abs(ratio) < 1e-6) label = '0';\\n        else if (Math.abs(ratio - Math.round(ratio)) < 1e-6) label = (Math.round(ratio)===1 ? 'π' : (Math.round(ratio)===-1 ? '-π' : (Math.round(ratio) + 'π')));\\n        else {\\n          label = ratio.toFixed(2) + 'π';\\n        }\\n        ctx.fillText(label, px, bottom + 6);\\n      }\\n\\n      // y 轴标签\\n      ctx.textAlign = 'right';\\n      ctx.textBaseline = 'middle';\\n      const yTicks = 5;\\n      for (let i=0;i<=yTicks;i++){\\n        const y = ymin + (ymax - ymin) * i / yTicks;\\n        const py = yToPx(y);\\n        ctx.fillText(y.toFixed(2), left - 8, py);\\n      }\\n    }\\n\\n    // 绘制函数曲线样条（简单线段连接）\\n    function drawFunction(ctx, p, trans, funcType='sin', color='#f00'){\\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\\n      const A = p.A, w = p.w, phi = p.phi, C = p.C;\\n      const n = p.n;\\n      const dx = (xmax - xmin) / (n - 1);\\n      function xToPx(x){ return left + (x - xmin) / (xmax - xmin) * (right - left); }\\n      function yToPx(y){ return top + (ymax - y) / (ymax - ymin) * (bottom - top); }\\n\\n      ctx.beginPath();\\n      for (let i=0;i<n;i++){\\n        const x = xmin + i * dx;\\n        let y;\\n        if (funcType === 'sin') y = A * Math.sin(w * x + phi) + C;\\n        else y = A * Math.cos(w * x + phi) + C;\\n        const px = xToPx(x);\\n        const py = yToPx(y);\\n        if (i===0) ctx.moveTo(px, py);\\n        else ctx.lineTo(px, py);\\n      }\\n      ctx.strokeStyle = color;\\n      ctx.lineWidth = p.lineWidth;\\n      ctx.lineJoin = 'round';\\n      ctx.lineCap = 'round';\\n      ctx.stroke();\\n    }\\n\\n    // 鼠标悬停显示坐标\\n    let hover = {x:null,y:null,show:false};\\n    canvas.addEventListener('mousemove', (ev)=>{\\n      const rect = canvas.getBoundingClientRect();\\n      const r = window.devicePixelRatio || 1;\\n      const mouseX = (ev.clientX - rect.left) * r;\\n      const mouseY = (ev.clientY - rect.top) * r;\\n      const p = getParams();\\n      const trans = computeTransform(p, canvas.width, canvas.height);\\n      // convert pixel to math coords\\n      const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\\n      if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {\\n        hover.show = false;\\n        return;\\n      }\\n      const x = trans.xmin + (mouseX - left) / (right - left) * (trans.xmax - trans.xmin);\\n      const y = trans.ymax - (mouseY - top) / (bottom - top) * (trans.ymax - trans.ymin);\\n      hover = {x,y,show:true};\\n      draw(); // redraw to show overlay\\n    });\\n    canvas.addEventListener('mouseleave', ()=>{ hover.show=false; draw(); });\\n\\n    // 主绘制函数\\n    function draw(){\\n      resizeCanvasToDisplaySize();\\n      const w = canvas.width, h = canvas.height;\\n      const p = getParams();\\n      const trans = computeTransform(p, w, h);\\n      drawGrid(ctx, trans);\\n\\n      // 绘制函数\\n      if (p.showSin) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'sin', p.sinColor);\\n      if (p.showCos) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'cos', p.cosColor);\\n\\n      // 悬停坐标显示\\n      if (hover.show){\\n        // draw vertical guide\\n        const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\\n        function xToPx(x){ return left + (x - trans.xmin) / (trans.xmax - trans.xmin) * (right - left); }\\n        function yToPx(y){ return top + (trans.ymax - y) / (trans.ymax - trans.ymin) * (bottom - top); }\\n        const px = xToPx(hover.x);\\n        const py = yToPx(hover.y);\\n        ctx.strokeStyle = 'rgba(0,0,0,0.12)';\\n        ctx.lineWidth = 1;\\n        ctx.beginPath();\\n        ctx.moveTo(px, top);\\n        ctx.lineTo(px, bottom);\\n        ctx.stroke();\\n\\n        // show tooltip in top-right of canvas\\n        const txt = `x=${hover.x.toFixed(3)}  y=${hover.y.toFixed(3)}`;\\n        ctx.fillStyle = 'rgba(30,40,60,0.9)';\\n        ctx.font = '12px system-ui,Segoe UI,Arial';\\n        const padding = 6;\\n        const metrics = ctx.measureText(txt);\\n        const boxW = metrics.width + padding*2;\\n        const boxH = 20;\\n        const bx = canvas.width - boxW - 10;\\n        const by = 10;\\n        ctx.fillRect(bx, by, boxW, boxH);\\n        ctx.fillStyle = '#fff';\\n        ctx.textAlign = 'left';\\n        ctx.textBaseline = 'middle';\\n        ctx.fillText(txt, bx + padding, by + boxH/2);\\n      }\\n\\n      updateDisplays();\\n    }\\n\\n    // 事件绑定\\n    const inputElements = [amplitude, frequency, phase, vshift, xStart, xEnd, samples, showSin, showCos, sinColor, cosColor, lineWidth];\\n    inputElements.forEach(el => el.addEventListener('input', ()=>{ draw(); }));\\n\\n    // 动画控制\\n    toggleAnim.addEventListener('click', ()=>{\\n      animState = !animState;\\n      if (animState){\\n        toggleAnim.textContent = '停止相位动画';\\n        startAnimation();\\n      } else {\\n        toggleAnim.textContent = '开始相位动画';\\n        stopAnimation();\\n      }\\n    });\\n\\n    function startAnimation(){\\n      let last = performance.now();\\n      function step(ts){\\n        const dt = (ts - last) / 1000;\\n        last = ts;\\n        // 增加相位（phi）\\n        const phiEl = phase;\\n        const newPhi = parseFloat(phiEl.value) + animSpeed * dt;\\n        phase.value = newPhi;\\n        draw();\\n        animId = requestAnimationFrame(step);\\n      }\\n      animId = requestAnimationFrame(step);\\n    }\\n    function stopAnimation(){\\n      if (animId) cancelAnimationFrame(animId);\\n      animId = null;\\n    }\\n\\n    // 导出 PNG\\n    exportBtn.addEventListener('click', ()=>{\\n      // 将当前 canvas 转为 data URL 并触发下载\\n      const link = document.createElement('a');\\n      link.download = 'sin_cos_plot.png';\\n      try {\\n        link.href = canvas.toDataURL('image/png');\\n        link.click();\\n      } catch(e){\\n        alert('导出失败：' + e);\\n      }\\n    });\\n\\n    // 重置\\n    resetBtn.addEventListener('click', ()=>{\\n      amplitude.value = 1;\\n      frequency.value = 1;\\n      phase.value = 0;\\n      vshift.value = 0;\\n      xStart.value = -2;\\n      xEnd.value = 2;\\n      samples.value = 800;\\n      showSin.checked = true;\\n      showCos.checked = true;\\n      sinColor.value = '#e34a6f';\\n      cosColor.value = '#2b90ff';\\n      lineWidth.value = 2;\\n      draw();\\n    });\\n\\n    // 鼠标滚轮缩放 X 轴（按住 shift 缩放 Y）\\n    canvas.addEventListener('wheel', (ev)=>{\\n      ev.preventDefault();\\n      const delta = ev.deltaY;\\n      const scaleFactor = (ev.shiftKey ? 0.05 : 0.15);\\n      const x0mul = parseFloat(xStart.value);\\n      const x1mul = parseFloat(xEnd.value);\\n      const span = x1mul - x0mul;\\n      const mid = (x1mul + x0mul) / 2;\\n      const zoom = 1 + (delta > 0 ? scaleFactor : -scaleFactor);\\n      let newSpan = span * zoom;\\n      // 限制 span\\n      newSpan = Math.min(Math.max(newSpan, 0.2), 12);\\n      const newStart = mid - newSpan/2;\\n      const newEnd = mid + newSpan/2;\\n      xStart.value = newStart;\\n      xEnd.value = newEnd;\\n      draw();\\n    }, { passive:false });\\n\\n    // 初始化绘制\\n    window.addEventListener('resize', draw);\\n    draw();\",\"parameters\":[],\"status\":\"success\"},\"attempts\":1}"
          }
        },
        {
          "stage": "data_analysis",
          "timestamp": "2025-08-09T12:18:47.641Z",
          "dataType": "object",
          "keys": [
            "success",
            "data",
            "attempts"
          ],
          "data": {
            "success": true,
            "data": {
              "experiment_id": "6fb2357d-dc47-41be-adec-cf62cf447aa7",
              "title": "sin / cos 可视化工具",
              "description": "总结（信息检索情况与核心概念）：\n- 我对“创建一个数学函数可视化工具，能够绘制sin和cos函数”的维基百科检索没有找到针对该中文查询的直接结果（检索返回：没有找到相关信息）。\n- 常见且可验证的数学事实（概念性说明）：\n  - 正弦（sin）和余弦（cos）是周期函数，标准形式的周期为 2π。\n  - 广义形式可写成 y = A * sin(ωx + φ) + C（或 cos），其中 A 是振幅，ω 是角频率（影响每单位 x 的振荡次数），φ 是相位（水平平移），C 是垂直平移。\n  - 改变采样点数量会影响绘图平滑度；绘图范围（x 的区间）决定可视化的周期数量。\n- 下面提供一个自包含的、可交互的 HTML 演示文件：可以绘制 sin 与 cos（单独或同时），可调参数：振幅、频率（角频率的倍数）、相位、纵向偏移、x 轴区间（以 π 的倍数设置）、采样点数、颜色等，并提供动画相位选项与导出图片按钮。\n\n完整可运行 HTML 代码（保存为 .html 并在浏览器中打开）：",
              "html_content": "<header>\n    <h1>sin / cos 可视化工具</h1>\n    <div style=\"color:var(--muted);font-size:13px;\">调整参数观察正弦和余弦函数行为（安全的浏览器内模拟）</div>\n  </header>\n\n  <main>\n    <aside class=\"controls\" aria-label=\"控制面板\">\n      <div>\n        <div class=\"flex-between\">\n          <div>\n            <label class=\"block\">绘制函数</label>\n            <div class=\"row\">\n              <label style=\"display:flex;align-items:center;gap:8px;\">\n                <input type=\"checkbox\" id=\"showSin\" checked /> sin(x)\n              </label>\n              <label style=\"display:flex;align-items:center;gap:8px;\">\n                <input type=\"checkbox\" id=\"showCos\" checked /> cos(x)\n              </label>\n            </div>\n          </div>\n          <div>\n            <button id=\"resetBtn\" title=\"恢复默认参数\">重置</button>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">振幅 A：<span id=\"ampVal\" class=\"val\">1.00</span></label>\n          <input type=\"range\" id=\"amplitude\" min=\"0\" max=\"5\" step=\"0.01\" value=\"1\">\n\n          <label class=\"block\">频率 ω（乘以 x）：<span id=\"freqVal\" class=\"val\">1.00</span></label>\n          <input type=\"range\" id=\"frequency\" min=\"0\" max=\"6\" step=\"0.01\" value=\"1\">\n\n          <label class=\"block\">相位 φ（弧度）：<span id=\"phaseVal\" class=\"val\">0.00</span></label>\n          <input type=\"range\" id=\"phase\" min=\"-6.283\" max=\"6.283\" step=\"0.001\" value=\"0\">\n\n          <label class=\"block\">垂直偏移 C：<span id=\"vshiftVal\" class=\"val\">0.00</span></label>\n          <input type=\"range\" id=\"vshift\" min=\"-5\" max=\"5\" step=\"0.01\" value=\"0\">\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">x 轴区间（以 π 的倍数）</label>\n          <div class=\"row\">\n            <div style=\"flex:1\">\n              <label class=\"small\">起点 (π * <span id=\"xStartMul\">-2</span>)</label>\n              <input type=\"range\" id=\"xStart\" min=\"-6\" max=\"0\" step=\"0.1\" value=\"-2\">\n            </div>\n            <div style=\"width:14px\"></div>\n            <div style=\"flex:1\">\n              <label class=\"small\">终点 (π * <span id=\"xEndMul\">2</span>)</label>\n              <input type=\"range\" id=\"xEnd\" min=\"0\" max=\"6\" step=\"0.1\" value=\"2\">\n            </div>\n          </div>\n\n          <label class=\"block\">采样点数：<span id=\"samplesVal\" class=\"val\">800</span></label>\n          <input type=\"range\" id=\"samples\" min=\"100\" max=\"3000\" step=\"10\" value=\"800\">\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">颜色与样式</label>\n          <div class=\"legend\">\n            <div class=\"item\">\n              <input type=\"color\" id=\"sinColor\" value=\"#e34a6f\">\n              <div>sin</div>\n            </div>\n            <div class=\"item\">\n              <input type=\"color\" id=\"cosColor\" value=\"#2b90ff\">\n              <div>cos</div>\n            </div>\n            <div style=\"margin-left:8px\" class=\"item\">\n              <label style=\"display:flex;align-items:center;gap:6px;\">\n                线宽：\n                <input id=\"lineWidth\" type=\"range\" min=\"1\" max=\"6\" step=\"1\" value=\"2\" />\n              </label>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">动画与导出</label>\n          <div class=\"row\" style=\"gap:8px;\">\n            <button id=\"toggleAnim\">开始相位动画</button>\n            <button class=\"secondary\" id=\"exportBtn\">导出 PNG</button>\n          </div>\n          <div style=\"margin-top:10px;font-size:13px;color:var(--muted);\">\n            相位动画会连续改变 φ 值以看到波形移动。导出会把当前画布保存为图片。\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"block\">提示</label>\n          <div style=\"font-size:13px;color:var(--muted);line-height:1.5;\">\n            - 频率越大，同一区间内周期越多；相位改变会水平移动波形；振幅决定上下张开程度。<br>\n            - x 轴区间单位是 π：例如 -2 到 2 表示 [-2π, 2π]。<br>\n            - 采样点越多曲线越平滑，但计算开销增大。\n          </div>\n        </div>\n\n      </div>\n    </aside>\n\n    <section class=\"canvas-wrap\" aria-label=\"绘图区域\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;padding:6px 6px 10px 6px;\">\n        <div style=\"font-weight:600\">绘图预览</div>\n        <div style=\"color:var(--muted);font-size:13px;\" id=\"domainLabel\"></div>\n      </div>\n      <div style=\"flex:1;min-height:320px;display:flex;flex-direction:column;\">\n        <canvas id=\"plotCanvas\" width=\"1200\" height=\"600\" role=\"img\" aria-label=\"函数绘图画布\"></canvas>\n      </div>\n      <footer>\n        鼠标悬停画布上可以看到对应 x, y 值（右上角坐标）。输入框与滑块会即时更新图形。\n      </footer>\n    </section>\n  </main>\n\n  <script>\n    // 获取元素\n    const canvas = document.getElementById('plotCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    // canvas 内部像素尺寸与 css 宽高保持一致以保证清晰\n    function resizeCanvasToDisplaySize() {\n      const r = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.round(rect.width * r);\n      canvas.height = Math.round(rect.height * r);\n      ctx.setTransform(r,0,0,r,0,0);\n    }\n    // 控件\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xStart = document.getElementById('xStart');\n    const xEnd = document.getElementById('xEnd');\n    const samples = document.getElementById('samples');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const sinColor = document.getElementById('sinColor');\n    const cosColor = document.getElementById('cosColor');\n    const lineWidth = document.getElementById('lineWidth');\n    const toggleAnim = document.getElementById('toggleAnim');\n    const exportBtn = document.getElementById('exportBtn');\n    const resetBtn = document.getElementById('resetBtn');\n\n    // 显示值元素\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const xStartMul = document.getElementById('xStartMul');\n    const xEndMul = document.getElementById('xEndMul');\n    const samplesVal = document.getElementById('samplesVal');\n    const domainLabel = document.getElementById('domainLabel');\n\n    // 初始参数\n    let animState = false;\n    let animId = null;\n    let animSpeed = 1.2; // 每秒相位变化（弧度）\n    function getParams(){\n      return {\n        A: parseFloat(amplitude.value),\n        w: parseFloat(frequency.value),\n        phi: parseFloat(phase.value),\n        C: parseFloat(vshift.value),\n        x0: parseFloat(xStart.value) * Math.PI,\n        x1: parseFloat(xEnd.value) * Math.PI,\n        n: parseInt(samples.value,10),\n        showSin: showSin.checked,\n        showCos: showCos.checked,\n        sinColor: sinColor.value,\n        cosColor: cosColor.value,\n        lineWidth: parseInt(lineWidth.value,10)\n      };\n    }\n\n    // 更新显示值\n    function updateDisplays(){\n      const p = getParams();\n      ampVal.textContent = p.A.toFixed(2);\n      freqVal.textContent = p.w.toFixed(2);\n      phaseVal.textContent = p.phi.toFixed(3);\n      vshiftVal.textContent = p.C.toFixed(2);\n      xStartMul.textContent = (parseFloat(xStart.value)).toFixed(2);\n      xEndMul.textContent = (parseFloat(xEnd.value)).toFixed(2);\n      samplesVal.textContent = p.n;\n      domainLabel.textContent = `[${(p.x0/Math.PI).toFixed(2)}π, ${(p.x1/Math.PI).toFixed(2)}π]`;\n    }\n\n    // 坐标映射：将数学坐标映射到画布像素\n    function computeTransform(p, w, h, padding=40) {\n      // x from p.x0..p.x1 to px from padding..w-padding\n      const xmin = p.x0, xmax = p.x1;\n      // 为 y 轴自动缩放以包含振幅和 vshift，同时留一些边距\n      // 先估计 y 显示范围：基于 A 和 C\n      const A = p.A, C = p.C;\n      // 如果同时画 sin 和 cos，最大幅度仍是 A，所以：\n      const yMaxAbs = Math.max(Math.abs(C + A), Math.abs(C - A));\n      // 如果 yMaxAbs 太小，设置最小范围\n      const yRangeHalf = Math.max(yMaxAbs * 1.2, 1.0);\n      const ymin = C - yRangeHalf;\n      const ymax = C + yRangeHalf;\n      return {\n        xmin, xmax, ymin, ymax,\n        pxmin: padding, pxmax: w - padding, pymin: h - padding, pymax: padding\n      };\n    }\n\n    // 绘制坐标网格和坐标轴\n    function drawGrid(ctx, trans){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const w = ctx.canvas.width;\n      const h = ctx.canvas.height;\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,w,h);\n\n      // 内部绘图区尺寸\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      // 背景微格\n      ctx.fillStyle = '#fbfdff';\n      ctx.fillRect(left, top, right-left, bottom-top);\n\n      // 网格线：以 π 的刻度绘制竖线，如果区间较小，自动选择刻度\n      function xToPx(x){\n        return left + (x - xmin) / (xmax - xmin) * (right - left);\n      }\n      function yToPx(y){\n        return top + (ymax - y) / (ymax - ymin) * (bottom - top);\n      }\n\n      // 竖线：以 π/2 的倍数标记\n      const approxWidth = Math.abs(xmax - xmin);\n      // 选择刻度基准\n      let stepCandidate = Math.PI / 2; // default π/2\n      if (approxWidth > 12*Math.PI) stepCandidate = Math.PI * 2;\n      if (approxWidth < Math.PI/2) stepCandidate = Math.PI/8;\n      // round step to nearest power-of-two fractions of π\n      const step = stepCandidate;\n\n      ctx.strokeStyle = '#eef4ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = Math.round(xToPx(x)) + 0.5;\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // 横线\n      ctx.beginPath();\n      for (let y = Math.ceil(ymin)*(1); y <= ymax; y += Math.max( (ymax - ymin)/8, 0.5 )){\n        const py = Math.round(yToPx(y)) + 0.5;\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n\n      // 轴线 (x=0, y=0)\n      ctx.strokeStyle = '#b8c8e6';\n      ctx.lineWidth = 1.5;\n      ctx.beginPath();\n      if (xmin <= 0 && xmax >= 0){\n        const px0 = Math.round(xToPx(0)) + 0.5;\n        ctx.moveTo(px0, top);\n        ctx.lineTo(px0, bottom);\n      }\n      if (ymin <= 0 && ymax >= 0){\n        const py0 = Math.round(yToPx(0)) + 0.5;\n        ctx.moveTo(left, py0);\n        ctx.lineTo(right, py0);\n      }\n      ctx.stroke();\n\n      // 刻度标签 (x轴以 π 单位显示)\n      ctx.fillStyle = '#234';\n      ctx.font = \"12px system-ui,Segoe UI,Arial\";\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = xToPx(x);\n        // label as multiples of π when appropriate\n        let label;\n        const ratio = x / Math.PI;\n        if (Math.abs(ratio) < 1e-6) label = '0';\n        else if (Math.abs(ratio - Math.round(ratio)) < 1e-6) label = (Math.round(ratio)===1 ? 'π' : (Math.round(ratio)===-1 ? '-π' : (Math.round(ratio) + 'π')));\n        else {\n          label = ratio.toFixed(2) + 'π';\n        }\n        ctx.fillText(label, px, bottom + 6);\n      }\n\n      // y 轴标签\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      const yTicks = 5;\n      for (let i=0;i<=yTicks;i++){\n        const y = ymin + (ymax - ymin) * i / yTicks;\n        const py = yToPx(y);\n        ctx.fillText(y.toFixed(2), left - 8, py);\n      }\n    }\n\n    // 绘制函数曲线样条（简单线段连接）\n    function drawFunction(ctx, p, trans, funcType='sin', color='#f00'){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      const A = p.A, w = p.w, phi = p.phi, C = p.C;\n      const n = p.n;\n      const dx = (xmax - xmin) / (n - 1);\n      function xToPx(x){ return left + (x - xmin) / (xmax - xmin) * (right - left); }\n      function yToPx(y){ return top + (ymax - y) / (ymax - ymin) * (bottom - top); }\n\n      ctx.beginPath();\n      for (let i=0;i<n;i++){\n        const x = xmin + i * dx;\n        let y;\n        if (funcType === 'sin') y = A * Math.sin(w * x + phi) + C;\n        else y = A * Math.cos(w * x + phi) + C;\n        const px = xToPx(x);\n        const py = yToPx(y);\n        if (i===0) ctx.moveTo(px, py);\n        else ctx.lineTo(px, py);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = p.lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // 鼠标悬停显示坐标\n    let hover = {x:null,y:null,show:false};\n    canvas.addEventListener('mousemove', (ev)=>{\n      const rect = canvas.getBoundingClientRect();\n      const r = window.devicePixelRatio || 1;\n      const mouseX = (ev.clientX - rect.left) * r;\n      const mouseY = (ev.clientY - rect.top) * r;\n      const p = getParams();\n      const trans = computeTransform(p, canvas.width, canvas.height);\n      // convert pixel to math coords\n      const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n      if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {\n        hover.show = false;\n        return;\n      }\n      const x = trans.xmin + (mouseX - left) / (right - left) * (trans.xmax - trans.xmin);\n      const y = trans.ymax - (mouseY - top) / (bottom - top) * (trans.ymax - trans.ymin);\n      hover = {x,y,show:true};\n      draw(); // redraw to show overlay\n    });\n    canvas.addEventListener('mouseleave', ()=>{ hover.show=false; draw(); });\n\n    // 主绘制函数\n    function draw(){\n      resizeCanvasToDisplaySize();\n      const w = canvas.width, h = canvas.height;\n      const p = getParams();\n      const trans = computeTransform(p, w, h);\n      drawGrid(ctx, trans);\n\n      // 绘制函数\n      if (p.showSin) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'sin', p.sinColor);\n      if (p.showCos) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'cos', p.cosColor);\n\n      // 悬停坐标显示\n      if (hover.show){\n        // draw vertical guide\n        const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n        function xToPx(x){ return left + (x - trans.xmin) / (trans.xmax - trans.xmin) * (right - left); }\n        function yToPx(y){ return top + (trans.ymax - y) / (trans.ymax - trans.ymin) * (bottom - top); }\n        const px = xToPx(hover.x);\n        const py = yToPx(hover.y);\n        ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n        ctx.stroke();\n\n        // show tooltip in top-right of canvas\n        const txt = `x=${hover.x.toFixed(3)}  y=${hover.y.toFixed(3)}`;\n        ctx.fillStyle = 'rgba(30,40,60,0.9)';\n        ctx.font = '12px system-ui,Segoe UI,Arial';\n        const padding = 6;\n        const metrics = ctx.measureText(txt);\n        const boxW = metrics.width + padding*2;\n        const boxH = 20;\n        const bx = canvas.width - boxW - 10;\n        const by = 10;\n        ctx.fillRect(bx, by, boxW, boxH);\n        ctx.fillStyle = '#fff';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(txt, bx + padding, by + boxH/2);\n      }\n\n      updateDisplays();\n    }\n\n    // 事件绑定\n    const inputElements = [amplitude, frequency, phase, vshift, xStart, xEnd, samples, showSin, showCos, sinColor, cosColor, lineWidth];\n    inputElements.forEach(el => el.addEventListener('input', ()=>{ draw(); }));\n\n    // 动画控制\n    toggleAnim.addEventListener('click', ()=>{\n      animState = !animState;\n      if (animState){\n        toggleAnim.textContent = '停止相位动画';\n        startAnimation();\n      } else {\n        toggleAnim.textContent = '开始相位动画';\n        stopAnimation();\n      }\n    });\n\n    function startAnimation(){\n      let last = performance.now();\n      function step(ts){\n        const dt = (ts - last) / 1000;\n        last = ts;\n        // 增加相位（phi）\n        const phiEl = phase;\n        const newPhi = parseFloat(phiEl.value) + animSpeed * dt;\n        phase.value = newPhi;\n        draw();\n        animId = requestAnimationFrame(step);\n      }\n      animId = requestAnimationFrame(step);\n    }\n    function stopAnimation(){\n      if (animId) cancelAnimationFrame(animId);\n      animId = null;\n    }\n\n    // 导出 PNG\n    exportBtn.addEventListener('click', ()=>{\n      // 将当前 canvas 转为 data URL 并触发下载\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      try {\n        link.href = canvas.toDataURL('image/png');\n        link.click();\n      } catch(e){\n        alert('导出失败：' + e);\n      }\n    });\n\n    // 重置\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1;\n      frequency.value = 1;\n      phase.value = 0;\n      vshift.value = 0;\n      xStart.value = -2;\n      xEnd.value = 2;\n      samples.value = 800;\n      showSin.checked = true;\n      showCos.checked = true;\n      sinColor.value = '#e34a6f';\n      cosColor.value = '#2b90ff';\n      lineWidth.value = 2;\n      draw();\n    });\n\n    // 鼠标滚轮缩放 X 轴（按住 shift 缩放 Y）\n    canvas.addEventListener('wheel', (ev)=>{\n      ev.preventDefault();\n      const delta = ev.deltaY;\n      const scaleFactor = (ev.shiftKey ? 0.05 : 0.15);\n      const x0mul = parseFloat(xStart.value);\n      const x1mul = parseFloat(xEnd.value);\n      const span = x1mul - x0mul;\n      const mid = (x1mul + x0mul) / 2;\n      const zoom = 1 + (delta > 0 ? scaleFactor : -scaleFactor);\n      let newSpan = span * zoom;\n      // 限制 span\n      newSpan = Math.min(Math.max(newSpan, 0.2), 12);\n      const newStart = mid - newSpan/2;\n      const newEnd = mid + newSpan/2;\n      xStart.value = newStart;\n      xEnd.value = newEnd;\n      draw();\n    }, { passive:false });\n\n    // 初始化绘制\n    window.addEventListener('resize', draw);\n    draw();\n  </script>",
              "css_content": ":root{\n      --bg:#f6f8fb;\n      --panel:#ffffff;\n      --accent:#2b90ff;\n      --muted:#666;\n      --border:#e0e6ef;\n    }\n    body{\n      margin:0;\n      font-family: \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n      background:var(--bg);\n      color:#122;\n      display:flex;\n      flex-direction:column;\n      min-height:100vh;\n    }\n    header{\n      padding:14px 20px;\n      background:linear-gradient(90deg, #ffffff, #f0f6ff);\n      border-bottom:1px solid var(--border);\n      display:flex;\n      align-items:center;\n      gap:12px;\n    }\n    header h1{\n      font-size:18px;\n      margin:0;\n    }\n    main{\n      display:flex;\n      gap:16px;\n      padding:16px;\n      flex:1;\n    }\n    .controls{\n      width:360px;\n      max-width:40%;\n      background:var(--panel);\n      border:1px solid var(--border);\n      border-radius:8px;\n      padding:14px;\n      box-shadow: 0 3px 12px rgba(18,34,68,0.04);\n      overflow:auto;\n      height: calc(100vh - 120px);\n    }\n    .canvas-wrap{\n      flex:1;\n      min-width:300px;\n      background:var(--panel);\n      border:1px solid var(--border);\n      border-radius:8px;\n      padding:10px;\n      display:flex;\n      flex-direction:column;\n      box-shadow: 0 3px 12px rgba(18,34,68,0.04);\n    }\n    label.block{\n      display:block;\n      font-size:13px;\n      color:var(--muted);\n      margin-top:10px;\n      margin-bottom:6px;\n    }\n    .row{\n      display:flex;\n      gap:10px;\n      align-items:center;\n    }\n    input[type=\"range\"]{\n      width:100%;\n    }\n    .small{\n      font-size:13px;\n      color:#234;\n    }\n    .controls .group{\n      padding:8px 0;\n      border-top:1px dashed #eef3fb;\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      margin-top:8px;\n      flex-wrap:wrap;\n    }\n    .legend .item{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .color-box{\n      width:16px;height:12px;border-radius:3px;border:1px solid #cfdff7;\n    }\n    canvas{\n      width:100%;\n      height:100%;\n      background:linear-gradient(180deg, #ffffff, #fbfdff);\n      border-radius:6px;\n    }\n    .controls button, .controls input[type=\"button\"]{\n      background:var(--accent);\n      color:white;\n      border:none;\n      padding:8px 10px;\n      border-radius:6px;\n      cursor:pointer;\n      font-size:14px;\n    }\n    .controls button.secondary{\n      background:#f0f4fa;color:#123;border:1px solid var(--border);\n    }\n    footer{\n      padding:10px 16px;\n      font-size:13px;\n      color:var(--muted);\n      border-top:1px solid var(--border);\n      background:#fff;\n    }\n    .val{\n      min-width:64px;\n      text-align:right;\n      font-weight:600;\n      color:#0b2b4a;\n    }\n    .flex-between{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n    }\n    .control-row{\n      display:flex;\n      gap:10px;\n      align-items:center;\n    }\n    @media (max-width:900px){\n      main{flex-direction:column;}\n      .controls{width:100%;max-width:none;height:auto;}\n      .canvas-wrap{order:-1;}\n    }",
              "js_content": "// 获取元素\n    const canvas = document.getElementById('plotCanvas');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    // canvas 内部像素尺寸与 css 宽高保持一致以保证清晰\n    function resizeCanvasToDisplaySize() {\n      const r = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.round(rect.width * r);\n      canvas.height = Math.round(rect.height * r);\n      ctx.setTransform(r,0,0,r,0,0);\n    }\n    // 控件\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xStart = document.getElementById('xStart');\n    const xEnd = document.getElementById('xEnd');\n    const samples = document.getElementById('samples');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const sinColor = document.getElementById('sinColor');\n    const cosColor = document.getElementById('cosColor');\n    const lineWidth = document.getElementById('lineWidth');\n    const toggleAnim = document.getElementById('toggleAnim');\n    const exportBtn = document.getElementById('exportBtn');\n    const resetBtn = document.getElementById('resetBtn');\n\n    // 显示值元素\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const xStartMul = document.getElementById('xStartMul');\n    const xEndMul = document.getElementById('xEndMul');\n    const samplesVal = document.getElementById('samplesVal');\n    const domainLabel = document.getElementById('domainLabel');\n\n    // 初始参数\n    let animState = false;\n    let animId = null;\n    let animSpeed = 1.2; // 每秒相位变化（弧度）\n    function getParams(){\n      return {\n        A: parseFloat(amplitude.value),\n        w: parseFloat(frequency.value),\n        phi: parseFloat(phase.value),\n        C: parseFloat(vshift.value),\n        x0: parseFloat(xStart.value) * Math.PI,\n        x1: parseFloat(xEnd.value) * Math.PI,\n        n: parseInt(samples.value,10),\n        showSin: showSin.checked,\n        showCos: showCos.checked,\n        sinColor: sinColor.value,\n        cosColor: cosColor.value,\n        lineWidth: parseInt(lineWidth.value,10)\n      };\n    }\n\n    // 更新显示值\n    function updateDisplays(){\n      const p = getParams();\n      ampVal.textContent = p.A.toFixed(2);\n      freqVal.textContent = p.w.toFixed(2);\n      phaseVal.textContent = p.phi.toFixed(3);\n      vshiftVal.textContent = p.C.toFixed(2);\n      xStartMul.textContent = (parseFloat(xStart.value)).toFixed(2);\n      xEndMul.textContent = (parseFloat(xEnd.value)).toFixed(2);\n      samplesVal.textContent = p.n;\n      domainLabel.textContent = `[${(p.x0/Math.PI).toFixed(2)}π, ${(p.x1/Math.PI).toFixed(2)}π]`;\n    }\n\n    // 坐标映射：将数学坐标映射到画布像素\n    function computeTransform(p, w, h, padding=40) {\n      // x from p.x0..p.x1 to px from padding..w-padding\n      const xmin = p.x0, xmax = p.x1;\n      // 为 y 轴自动缩放以包含振幅和 vshift，同时留一些边距\n      // 先估计 y 显示范围：基于 A 和 C\n      const A = p.A, C = p.C;\n      // 如果同时画 sin 和 cos，最大幅度仍是 A，所以：\n      const yMaxAbs = Math.max(Math.abs(C + A), Math.abs(C - A));\n      // 如果 yMaxAbs 太小，设置最小范围\n      const yRangeHalf = Math.max(yMaxAbs * 1.2, 1.0);\n      const ymin = C - yRangeHalf;\n      const ymax = C + yRangeHalf;\n      return {\n        xmin, xmax, ymin, ymax,\n        pxmin: padding, pxmax: w - padding, pymin: h - padding, pymax: padding\n      };\n    }\n\n    // 绘制坐标网格和坐标轴\n    function drawGrid(ctx, trans){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const w = ctx.canvas.width;\n      const h = ctx.canvas.height;\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,w,h);\n\n      // 内部绘图区尺寸\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      // 背景微格\n      ctx.fillStyle = '#fbfdff';\n      ctx.fillRect(left, top, right-left, bottom-top);\n\n      // 网格线：以 π 的刻度绘制竖线，如果区间较小，自动选择刻度\n      function xToPx(x){\n        return left + (x - xmin) / (xmax - xmin) * (right - left);\n      }\n      function yToPx(y){\n        return top + (ymax - y) / (ymax - ymin) * (bottom - top);\n      }\n\n      // 竖线：以 π/2 的倍数标记\n      const approxWidth = Math.abs(xmax - xmin);\n      // 选择刻度基准\n      let stepCandidate = Math.PI / 2; // default π/2\n      if (approxWidth > 12*Math.PI) stepCandidate = Math.PI * 2;\n      if (approxWidth < Math.PI/2) stepCandidate = Math.PI/8;\n      // round step to nearest power-of-two fractions of π\n      const step = stepCandidate;\n\n      ctx.strokeStyle = '#eef4ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = Math.round(xToPx(x)) + 0.5;\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // 横线\n      ctx.beginPath();\n      for (let y = Math.ceil(ymin)*(1); y <= ymax; y += Math.max( (ymax - ymin)/8, 0.5 )){\n        const py = Math.round(yToPx(y)) + 0.5;\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n\n      // 轴线 (x=0, y=0)\n      ctx.strokeStyle = '#b8c8e6';\n      ctx.lineWidth = 1.5;\n      ctx.beginPath();\n      if (xmin <= 0 && xmax >= 0){\n        const px0 = Math.round(xToPx(0)) + 0.5;\n        ctx.moveTo(px0, top);\n        ctx.lineTo(px0, bottom);\n      }\n      if (ymin <= 0 && ymax >= 0){\n        const py0 = Math.round(yToPx(0)) + 0.5;\n        ctx.moveTo(left, py0);\n        ctx.lineTo(right, py0);\n      }\n      ctx.stroke();\n\n      // 刻度标签 (x轴以 π 单位显示)\n      ctx.fillStyle = '#234';\n      ctx.font = \"12px system-ui,Segoe UI,Arial\";\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      for (let x = Math.ceil(xmin/step)*step; x <= xmax; x += step){\n        const px = xToPx(x);\n        // label as multiples of π when appropriate\n        let label;\n        const ratio = x / Math.PI;\n        if (Math.abs(ratio) < 1e-6) label = '0';\n        else if (Math.abs(ratio - Math.round(ratio)) < 1e-6) label = (Math.round(ratio)===1 ? 'π' : (Math.round(ratio)===-1 ? '-π' : (Math.round(ratio) + 'π')));\n        else {\n          label = ratio.toFixed(2) + 'π';\n        }\n        ctx.fillText(label, px, bottom + 6);\n      }\n\n      // y 轴标签\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      const yTicks = 5;\n      for (let i=0;i<=yTicks;i++){\n        const y = ymin + (ymax - ymin) * i / yTicks;\n        const py = yToPx(y);\n        ctx.fillText(y.toFixed(2), left - 8, py);\n      }\n    }\n\n    // 绘制函数曲线样条（简单线段连接）\n    function drawFunction(ctx, p, trans, funcType='sin', color='#f00'){\n      const { xmin, xmax, ymin, ymax, pxmin, pxmax, pymin, pymax } = trans;\n      const left = pxmin, right = pxmax, top = pymax, bottom = pymin;\n      const A = p.A, w = p.w, phi = p.phi, C = p.C;\n      const n = p.n;\n      const dx = (xmax - xmin) / (n - 1);\n      function xToPx(x){ return left + (x - xmin) / (xmax - xmin) * (right - left); }\n      function yToPx(y){ return top + (ymax - y) / (ymax - ymin) * (bottom - top); }\n\n      ctx.beginPath();\n      for (let i=0;i<n;i++){\n        const x = xmin + i * dx;\n        let y;\n        if (funcType === 'sin') y = A * Math.sin(w * x + phi) + C;\n        else y = A * Math.cos(w * x + phi) + C;\n        const px = xToPx(x);\n        const py = yToPx(y);\n        if (i===0) ctx.moveTo(px, py);\n        else ctx.lineTo(px, py);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = p.lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // 鼠标悬停显示坐标\n    let hover = {x:null,y:null,show:false};\n    canvas.addEventListener('mousemove', (ev)=>{\n      const rect = canvas.getBoundingClientRect();\n      const r = window.devicePixelRatio || 1;\n      const mouseX = (ev.clientX - rect.left) * r;\n      const mouseY = (ev.clientY - rect.top) * r;\n      const p = getParams();\n      const trans = computeTransform(p, canvas.width, canvas.height);\n      // convert pixel to math coords\n      const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n      if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {\n        hover.show = false;\n        return;\n      }\n      const x = trans.xmin + (mouseX - left) / (right - left) * (trans.xmax - trans.xmin);\n      const y = trans.ymax - (mouseY - top) / (bottom - top) * (trans.ymax - trans.ymin);\n      hover = {x,y,show:true};\n      draw(); // redraw to show overlay\n    });\n    canvas.addEventListener('mouseleave', ()=>{ hover.show=false; draw(); });\n\n    // 主绘制函数\n    function draw(){\n      resizeCanvasToDisplaySize();\n      const w = canvas.width, h = canvas.height;\n      const p = getParams();\n      const trans = computeTransform(p, w, h);\n      drawGrid(ctx, trans);\n\n      // 绘制函数\n      if (p.showSin) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'sin', p.sinColor);\n      if (p.showCos) drawFunction(ctx, {...p, lineWidth:p.lineWidth}, trans, 'cos', p.cosColor);\n\n      // 悬停坐标显示\n      if (hover.show){\n        // draw vertical guide\n        const left = trans.pxmin, right = trans.pxmax, top = trans.pymax, bottom = trans.pymin;\n        function xToPx(x){ return left + (x - trans.xmin) / (trans.xmax - trans.xmin) * (right - left); }\n        function yToPx(y){ return top + (trans.ymax - y) / (trans.ymax - trans.ymin) * (bottom - top); }\n        const px = xToPx(hover.x);\n        const py = yToPx(hover.y);\n        ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n        ctx.stroke();\n\n        // show tooltip in top-right of canvas\n        const txt = `x=${hover.x.toFixed(3)}  y=${hover.y.toFixed(3)}`;\n        ctx.fillStyle = 'rgba(30,40,60,0.9)';\n        ctx.font = '12px system-ui,Segoe UI,Arial';\n        const padding = 6;\n        const metrics = ctx.measureText(txt);\n        const boxW = metrics.width + padding*2;\n        const boxH = 20;\n        const bx = canvas.width - boxW - 10;\n        const by = 10;\n        ctx.fillRect(bx, by, boxW, boxH);\n        ctx.fillStyle = '#fff';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(txt, bx + padding, by + boxH/2);\n      }\n\n      updateDisplays();\n    }\n\n    // 事件绑定\n    const inputElements = [amplitude, frequency, phase, vshift, xStart, xEnd, samples, showSin, showCos, sinColor, cosColor, lineWidth];\n    inputElements.forEach(el => el.addEventListener('input', ()=>{ draw(); }));\n\n    // 动画控制\n    toggleAnim.addEventListener('click', ()=>{\n      animState = !animState;\n      if (animState){\n        toggleAnim.textContent = '停止相位动画';\n        startAnimation();\n      } else {\n        toggleAnim.textContent = '开始相位动画';\n        stopAnimation();\n      }\n    });\n\n    function startAnimation(){\n      let last = performance.now();\n      function step(ts){\n        const dt = (ts - last) / 1000;\n        last = ts;\n        // 增加相位（phi）\n        const phiEl = phase;\n        const newPhi = parseFloat(phiEl.value) + animSpeed * dt;\n        phase.value = newPhi;\n        draw();\n        animId = requestAnimationFrame(step);\n      }\n      animId = requestAnimationFrame(step);\n    }\n    function stopAnimation(){\n      if (animId) cancelAnimationFrame(animId);\n      animId = null;\n    }\n\n    // 导出 PNG\n    exportBtn.addEventListener('click', ()=>{\n      // 将当前 canvas 转为 data URL 并触发下载\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      try {\n        link.href = canvas.toDataURL('image/png');\n        link.click();\n      } catch(e){\n        alert('导出失败：' + e);\n      }\n    });\n\n    // 重置\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1;\n      frequency.value = 1;\n      phase.value = 0;\n      vshift.value = 0;\n      xStart.value = -2;\n      xEnd.value = 2;\n      samples.value = 800;\n      showSin.checked = true;\n      showCos.checked = true;\n      sinColor.value = '#e34a6f';\n      cosColor.value = '#2b90ff';\n      lineWidth.value = 2;\n      draw();\n    });\n\n    // 鼠标滚轮缩放 X 轴（按住 shift 缩放 Y）\n    canvas.addEventListener('wheel', (ev)=>{\n      ev.preventDefault();\n      const delta = ev.deltaY;\n      const scaleFactor = (ev.shiftKey ? 0.05 : 0.15);\n      const x0mul = parseFloat(xStart.value);\n      const x1mul = parseFloat(xEnd.value);\n      const span = x1mul - x0mul;\n      const mid = (x1mul + x0mul) / 2;\n      const zoom = 1 + (delta > 0 ? scaleFactor : -scaleFactor);\n      let newSpan = span * zoom;\n      // 限制 span\n      newSpan = Math.min(Math.max(newSpan, 0.2), 12);\n      const newStart = mid - newSpan/2;\n      const newEnd = mid + newSpan/2;\n      xStart.value = newStart;\n      xEnd.value = newEnd;\n      draw();\n    }, { passive:false });\n\n    // 初始化绘制\n    window.addEventListener('resize', draw);\n    draw();",
              "parameters": [],
              "status": "success"
            },
            "attempts": 1
          }
        },
        {
          "stage": "quality_check",
          "timestamp": "2025-08-09T12:18:47.641Z",
          "checks": {
            "hasCode": false,
            "codeLength": 0,
            "htmlTagsFound": [],
            "syntaxErrors": [],
            "bracketMatching": true,
            "syntaxValid": true
          }
        }
      ],
      "finalResult": {
        "codeGenerated": false,
        "codeLength": 0,
        "hasQualityIssues": false,
        "issues": {
          "htmlTags": 0,
          "bracketErrors": false,
          "syntaxErrors": false
        }
      },
      "success": true,
      "errors": [],
      "endTime": "2025-08-09T12:18:47.641Z",
      "duration": 87096
    }
  ],
  "summary": {
    "total": 3,
    "passed": 3,
    "failed": 0,
    "errors": []
  }
}