{
  "timestamp": "2025-08-09T13:07:35.794Z",
  "testCases": [
    {
      "name": "简单物理模拟",
      "prompt": "创建一个简单的重力球下落模拟",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T13:07:35.798Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T13:09:00.907Z",
          "response": {
            "status": 200,
            "statusText": "OK",
            "headers": {
              "access-control-allow-origin": "*",
              "connection": "keep-alive",
              "content-length": "39245",
              "content-type": "application/json; charset=utf-8",
              "date": "Sat, 09 Aug 2025 13:09:00 GMT",
              "etag": "W/\"994d-MzPZO7ERgnjqj8lSLNJtPlqn2QU\"",
              "keep-alive": "timeout=5",
              "x-powered-by": "Express"
            },
            "data": {
              "success": true,
              "data": {
                "experiment_id": "e94455b3-2280-461f-ba61-7dd55031ecf0",
                "title": "重力球下落模拟",
                "description": "简短摘要（依据 Perplexity 研究资料）：\n- 本模拟演示的是重力下的垂直自由落体运动。恒定重力加速度 g（标准约为 9.81 m/s²）使物体做匀加速直线运动，解析解为：位置 y(t)=y0+v0*t+0.5*g*t²，速度 v(t)=v0+g*t（向下为正方向）。（来源：Perplexity AI）\n- 为了更接近真实情况，演示中还提供了线性空气阻力（阻力与速度成正比）的选项，阻力会改变加速度：a = g - (b/m) * v。开启阻力时采用数值积分（欧拉/半隐式欧拉）求解。\n- 本 demo 提供交互控件（高度、初速度、重力、质量、阻力系数、时间缩放、播放/重置等），并显示数值读数与位置/速度随时间的曲线，且在无阻力时对比解析解曲线。\n\n下面是完整可运行的自包含 HTML 代码（保存为 .html 文件后直接在浏览器打开即可）：",
                "html_content": "<div class=\"wrap\">\n    <h1>重力球下落模拟</h1>\n    <p class=\"lead\">演示自由落体（恒定重力）与线性空气阻力的影响。可调初始高度、初速度、重力、质量和阻力系数。解析解仅在无阻力时与数值解一致。（资料来源：Perplexity AI）</p>\n\n    <div class=\"grid\">\n      <!-- 左侧：模拟画布与图表 -->\n      <div class=\"card\">\n        <div class=\"sim-area\">\n          <canvas id=\"scene\" aria-label=\"重力球下落模拟画布\"></canvas>\n\n          <div class=\"plot-row\">\n            <canvas id=\"posPlot\" class=\"plot\" aria-label=\"位置-时间图\"></canvas>\n            <canvas id=\"velPlot\" class=\"plot\" aria-label=\"速度-时间图\"></canvas>\n          </div>\n\n          <div class=\"readouts\">\n            <div class=\"readout\">时间 (s): <span id=\"tVal\">0.00</span></div>\n            <div class=\"readout\">高度 (m): <span id=\"yVal\">0.00</span></div>\n            <div class=\"readout\">速度 (m/s): <span id=\"vVal\">0.00</span></div>\n            <div class=\"readout\">加速度 (m/s²): <span id=\"aVal\">0.00</span></div>\n          </div>\n        </div>\n      </div>\n\n      <!-- 右侧：控制与参数 -->\n      <div class=\"card\">\n        <div style=\"display:flex;gap:10px;align-items:center;justify-content:space-between;\">\n          <div style=\"display:flex;flex-direction:column;\">\n            <strong>控制</strong>\n            <span class=\"small\">播放 / 暂停 / 重置 仿真</span>\n          </div>\n          <div style=\"display:flex;gap:8px;\">\n            <button id=\"playBtn\" class=\"btn\">播放</button>\n            <button id=\"pauseBtn\" class=\"btn\">暂停</button>\n            <button id=\"resetBtn\" class=\"btn\">重置</button>\n          </div>\n        </div>\n\n        <hr style=\"border:0;border-top:1px solid rgba(255,255,255,0.03);margin:10px 0;\">\n\n        <div>\n          <div style=\"display:flex;flex-direction:column;gap:8px;\">\n            <div class=\"control\">\n              <label for=\"hRange\">初始高度 h (m)</label>\n              <input id=\"hRange\" type=\"range\" min=\"0\" max=\"200\" step=\"1\" value=\"50\">\n              <div class=\"value\" id=\"hVal\">50</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"v0Range\">初速度 v0 (m/s)</label>\n              <input id=\"v0Range\" type=\"range\" min=\"-50\" max=\"50\" step=\"1\" value=\"0\">\n              <div class=\"value\" id=\"v0Val\">0</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"gRange\">重力 g (m/s²)</label>\n              <input id=\"gRange\" type=\"range\" min=\"0\" max=\"20\" step=\"0.01\" value=\"9.81\">\n              <div class=\"value\" id=\"gVal\">9.81</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"massRange\">质量 m (kg)</label>\n              <input id=\"massRange\" type=\"range\" min=\"0.1\" max=\"10\" step=\"0.1\" value=\"1\">\n              <div class=\"value\" id=\"massVal\">1.0</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"dragRange\">阻力系数 b (kg/s)</label>\n              <input id=\"dragRange\" type=\"range\" min=\"0\" max=\"5\" step=\"0.01\" value=\"0.00\">\n              <div class=\"value\" id=\"dragVal\">0.00</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"timeScale\">时间缩放</label>\n              <input id=\"timeScale\" type=\"range\" min=\"0.1\" max=\"4\" step=\"0.1\" value=\"1\">\n              <div class=\"value\" id=\"timeScaleVal\">1.0x</div>\n            </div>\n\n            <div class=\"control toggle\">\n              <input id=\"dragToggle\" type=\"checkbox\" />\n              <label for=\"dragToggle\" style=\"min-width:0;\">启用空气阻力（线性）</label>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"small\" style=\"margin-top:12px;\">\n          使用说明：调整参数后可点击“重置”使球回到初始状态，点击播放开始仿真；当阻力关闭时，右侧图表会显示解析解（虚线）作为对比。\n        </div>\n      </div>\n    </div>\n\n    <footer>\n      注：解析公式（无阻力） y(t)=y0 + v0*t + 0.5*g*t²，v(t)=v0 + g*t。阻力模型：线性阻力 F_d = -b*v（向上若 v 向下为正）。\n    </footer>\n  </div>\n\n  <script>\n    // --- 常量与 DOM 元素 ---\n    const scene = document.getElementById('scene');\n    const posPlot = document.getElementById('posPlot');\n    const velPlot = document.getElementById('velPlot');\n    const ctx = scene.getContext('2d');\n    const ctxPos = posPlot.getContext('2d');\n    const ctxVel = velPlot.getContext('2d');\n\n    // Controls\n    const hRange = document.getElementById('hRange'), hVal = document.getElementById('hVal');\n    const v0Range = document.getElementById('v0Range'), v0Val = document.getElementById('v0Val');\n    const gRange = document.getElementById('gRange'), gVal = document.getElementById('gVal');\n    const massRange = document.getElementById('massRange'), massVal = document.getElementById('massVal');\n    const dragRange = document.getElementById('dragRange'), dragVal = document.getElementById('dragVal');\n    const timeScale = document.getElementById('timeScale'), timeScaleVal = document.getElementById('timeScaleVal');\n    const dragToggle = document.getElementById('dragToggle');\n    const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');\n\n    const tDisplay = document.getElementById('tVal'), yDisplay = document.getElementById('yVal'), vDisplay = document.getElementById('vVal'), aDisplay = document.getElementById('aVal');\n\n    // Canvas sizing helper\n    function resizeCanvases() {\n      const dpr = window.devicePixelRatio || 1;\n      // scene\n      const rect = scene.getBoundingClientRect();\n      scene.width = Math.round(rect.width * dpr);\n      scene.height = Math.round(rect.height * dpr);\n      ctx.setTransform(dpr,0,0,dpr,0,0);\n      // plots\n      const r1 = posPlot.getBoundingClientRect();\n      posPlot.width = Math.round(r1.width * dpr);\n      posPlot.height = Math.round(r1.height * dpr);\n      ctxPos.setTransform(dpr,0,0,dpr,0,0);\n\n      const r2 = velPlot.getBoundingClientRect();\n      velPlot.width = Math.round(r2.width * dpr);\n      velPlot.height = Math.round(r2.height * dpr);\n      ctxVel.setTransform(dpr,0,0,dpr,0,0);\n    }\n    window.addEventListener('resize', resizeCanvases);\n\n    // --- 物理与仿真状态 ---\n    let sim = {\n      running: false,\n      t: 0,\n      y: 0,   // 高度（m），向下为正； ground at y=0\n      v: 0,\n      a: 0,\n      params: {\n        h: parseFloat(hRange.value),\n        v0: parseFloat(v0Range.value),\n        g: parseFloat(gRange.value),\n        m: parseFloat(massRange.value),\n        b: parseFloat(dragRange.value),\n        dragOn: dragToggle.checked,\n        timeScale: parseFloat(timeScale.value)\n      },\n      history: { t:[], y:[], v:[] }\n    };\n\n    // initialize values display\n    function syncUI() {\n      hVal.textContent = Number(hRange.value).toFixed(0);\n      v0Val.textContent = Number(v0Range.value).toFixed(0);\n      gVal.textContent = Number(gRange.value).toFixed(2);\n      massVal.textContent = Number(massRange.value).toFixed(1);\n      dragVal.textContent = Number(dragRange.value).toFixed(2);\n      timeScaleVal.textContent = Number(timeScale.value).toFixed(1) + 'x';\n    }\n    syncUI();\n\n    // Update params from controls\n    function updateParams() {\n      sim.params.h = parseFloat(hRange.value);\n      sim.params.v0 = parseFloat(v0Range.value);\n      sim.params.g = parseFloat(gRange.value);\n      sim.params.m = parseFloat(massRange.value);\n      sim.params.b = parseFloat(dragRange.value);\n      sim.params.dragOn = dragToggle.checked;\n      sim.params.timeScale = parseFloat(timeScale.value);\n      syncUI();\n    }\n\n    // Reset simulation to initial state\n    function resetSim() {\n      updateParams();\n      sim.t = 0;\n      sim.y = sim.params.h; // height above ground in meters (we treat ground at y=0)\n      sim.v = sim.params.v0;\n      sim.a = sim.params.g; // initial a (approx)\n      sim.history.t = [0];\n      sim.history.y = [sim.y];\n      sim.history.v = [sim.v];\n      // clear plots\n      clearPlots();\n      drawScene();\n    }\n\n    // Numerical integration: semi-implicit Euler (velocity updated from acceleration, then position)\n    function stepSim(dtRealSeconds) {\n      const dt = dtRealSeconds * sim.params.timeScale;\n      const g = sim.params.g;\n      const m = sim.params.m;\n      const b = sim.params.b;\n      let a;\n      if (sim.params.dragOn && b > 0) {\n        // model: a = g - (b/m) * v, with v positive downward\n        a = g - (b/m) * sim.v;\n      } else {\n        a = g;\n      }\n      // semi-implicit Euler\n      sim.v += a * dt;\n      sim.y += sim.v * dt;\n      sim.t += dt;\n      sim.a = a;\n      sim.history.t.push(sim.t);\n      sim.history.y.push(sim.y);\n      sim.history.v.push(sim.v);\n    }\n\n    // Drawing utilities\n    function clearPlots() {\n      ctxPos.clearRect(0,0,posPlot.width,posPlot.height);\n      ctxVel.clearRect(0,0,velPlot.width,velPlot.height);\n      // draw axes lightly\n      drawAxes(ctxPos, posPlot, \"高度 (m)\");\n      drawAxes(ctxVel, velPlot, \"速度 (m/s)\");\n    }\n\n    function drawAxes(ctxP, canvasElem, label) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      ctxP.save();\n      ctxP.fillStyle = '#072033';\n      ctxP.fillRect(0,0,w,h);\n      ctxP.strokeStyle = 'rgba(255,255,255,0.03)';\n      ctxP.beginPath();\n      ctxP.moveTo(36,6);\n      ctxP.lineTo(36,h-18);\n      ctxP.lineTo(w-6,h-18);\n      ctxP.stroke();\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '12px sans-serif';\n      ctxP.fillText(label, 6, 12);\n      ctxP.restore();\n    }\n\n    function drawPlot(ctxP, canvasElem, dataX, dataY, color='#7dd3fc', dashed=false) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      const margin = { left:40, right:6, top:6, bottom:18 };\n      // compute ranges\n      const tMin = 0;\n      const tMax = Math.max(1, dataX[dataX.length-1]);\n      const yMin = Math.min(...dataY, 0);\n      const yMax = Math.max(...dataY, 1);\n      const pad = (yMax - yMin) * 0.12;\n      const Ymin = yMin - pad;\n      const Ymax = yMax + pad;\n\n      ctxP.save();\n      // background\n      ctxP.fillStyle = '#021028';\n      ctxP.fillRect(0,0,w,h);\n\n      // axes\n      ctxP.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctxP.beginPath();\n      ctxP.moveTo(margin.left, margin.top);\n      ctxP.lineTo(margin.left, h - margin.bottom);\n      ctxP.lineTo(w - margin.right, h - margin.bottom);\n      ctxP.stroke();\n\n      // plot data\n      ctxP.lineWidth = 2;\n      ctxP.strokeStyle = color;\n      if (dashed) ctxP.setLineDash([6,4]); else ctxP.setLineDash([]);\n      ctxP.beginPath();\n      for (let i=0;i<dataX.length;i++) {\n        const tx = dataX[i];\n        const val = dataY[i];\n        const x = margin.left + ((tx - tMin) / (tMax - tMin)) * (w - margin.left - margin.right);\n        const y = (h - margin.bottom) - ((val - Ymin) / (Ymax - Ymin)) * (h - margin.top - margin.bottom);\n        if (i===0) ctxP.moveTo(x,y); else ctxP.lineTo(x,y);\n      }\n      ctxP.stroke();\n\n      // labels\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText('t (s)', w - 40, h - 2);\n\n      // value ticks (min/max)\n      ctxP.fillStyle = '#94a3b8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText(Ymax.toFixed(2), 6, 14);\n      ctxP.fillText(Ymin.toFixed(2), 6, h - 22);\n\n      ctxP.restore();\n    }\n\n    function drawScene() {\n      // scene canvas: draw ground, scale and ball\n      ctx.clearRect(0,0,scene.width, scene.height);\n      const cw = scene.width / (window.devicePixelRatio || 1);\n      const ch = scene.height / (window.devicePixelRatio || 1);\n\n      // background gradient\n      const grad = ctx.createLinearGradient(0,0,0,ch);\n      grad.addColorStop(0, '#07112a');\n      grad.addColorStop(1, '#021027');\n      ctx.fillStyle = grad;\n      ctx.fillRect(0,0,cw,ch);\n\n      // Compute mapping: physical height in meters maps to pixel y\n      const maxH = Math.max(sim.params.h, 200); // at least 200m domain for good scale\n      const topMargin = 30;\n      const bottomMargin = 30;\n      const usable = ch - topMargin - bottomMargin;\n      // clamp max domain by some function to keep visible when very large\n      const domainH = Math.max(maxH, 1);\n      const pixelsPerMeter = usable / domainH;\n\n      // draw ground line\n      const groundY = topMargin + domainH * pixelsPerMeter;\n      ctx.fillStyle = '#17384f';\n      ctx.fillRect(0, groundY, cw, ch - groundY);\n\n      ctx.strokeStyle = '#2aa6ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(0, groundY + 0.5);\n      ctx.lineTo(cw, groundY + 0.5);\n      ctx.stroke();\n\n      // draw height ticks\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\n      ctx.font = '11px sans-serif';\n      for (let m=0; m <= domainH; m += Math.max(1, Math.floor(domainH/6))) {\n        const ypix = topMargin + m * pixelsPerMeter;\n        ctx.beginPath();\n        ctx.moveTo(6, ypix + 0.5);\n        ctx.lineTo(18, ypix + 0.5);\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        ctx.stroke();\n        ctx.fillStyle = '#9fbbe8';\n        ctx.fillText((domainH - m).toFixed(0) + ' m', 22, ypix + 4);\n      }\n\n      // draw analytical trajectory (if no drag)\n      if (!sim.params.dragOn) {\n        // sample times over a small horizon\n        const tMax = Math.max(1, sim.history.t[sim.history.t.length-1] + 1);\n        ctx.beginPath();\n        ctx.setLineDash([6,6]);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = 'rgba(255,200,80,0.6)';\n        for (let i=0;i<=60;i++) {\n          const tt = (i/60) * tMax;\n          const yAnal = sim.params.h + sim.params.v0 * tt + 0.5 * sim.params.g * tt * tt;\n          const yClamped = Math.min(yAnal, domainH);\n          const ypix = topMargin + yClamped * pixelsPerMeter;\n          const x = cw * 0.15 + (i/60) * (cw * 0.7);\n          if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n        }\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n\n      // draw trail from history\n      ctx.beginPath();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = 'rgba(96,165,250,0.9)';\n      for (let i=0;i<sim.history.y.length;i+=Math.max(1, Math.floor(sim.history.y.length/300))) {\n        const yv = Math.min(sim.history.y[i], domainH);\n        const x = cw * 0.15 + (i / Math.max(1, sim.history.y.length-1)) * (cw * 0.7);\n        const ypix = topMargin + yv * pixelsPerMeter;\n        if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n      }\n      ctx.stroke();\n\n      // draw ball current position\n      const ballX = cw * 0.15 + (sim.history.length ? (sim.history.y.length-1) / Math.max(1, sim.history.y.length-1) : 0) * (cw * 0.7);\n      const yPixBall = topMargin + Math.min(sim.y, domainH) * pixelsPerMeter;\n      const rpx = 12;\n      // shadow\n      ctx.beginPath();\n      ctx.ellipse(ballX + 6, groundY + 6, 18, 6, 0, 0, Math.PI*2);\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\n      ctx.fill();\n\n      // ball\n      const gradBall = ctx.createRadialGradient(ballX - 4, yPixBall - 6, 4, ballX, yPixBall, 18);\n      gradBall.addColorStop(0, '#9be7ff');\n      gradBall.addColorStop(1, '#1560a9');\n      ctx.fillStyle = gradBall;\n      ctx.beginPath();\n      ctx.arc(ballX, yPixBall, rpx, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n      ctx.stroke();\n\n      // textual info\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = '13px sans-serif';\n      ctx.fillText('高度 (m): ' + sim.y.toFixed(2), 12, 20);\n      ctx.fillText('速度 (m/s): ' + sim.v.toFixed(2), 12, 36);\n\n      // update numeric displays\n      tDisplay.textContent = sim.t.toFixed(2);\n      yDisplay.textContent = Math.max(0, (sim.params.h - (sim.params.h - sim.y))).toFixed(2); // just show sim.y\n      vDisplay.textContent = sim.v.toFixed(2);\n      aDisplay.textContent = sim.a.toFixed(2);\n    }\n\n    // --- Main loop ---\n    let lastFrameTime = null;\n    function frame(ts) {\n      if (!lastFrameTime) lastFrameTime = ts;\n      const dtMillis = ts - lastFrameTime;\n      lastFrameTime = ts;\n      const dtSec = dtMillis / 1000;\n\n      if (sim.running) {\n        // integrate in fixed small steps for stability\n        let remaining = dtSec;\n        const step = 0.016; // 16ms ~ 60Hz physics step\n        while (remaining > 1e-6) {\n          const d = Math.min(step, remaining);\n          stepSim(d);\n          remaining -= d;\n          // stop when hits ground\n          if (sim.y >= Math.max(sim.params.h, sim.y) && false) { /* placeholder */ }\n          // If ball hits ground (simulate bounce off ground? For now stop at ground)\n          if (sim.y >= 10000) {\n            // safety clamp for insane values\n            sim.y = 10000;\n            sim.v = 0;\n            sim.running = false;\n            break;\n          }\n          // Stop if y is below ground (we treat ground at y = large domain; instead we stop when actual y passes some threshold)\n          if (sim.y >= 1e9) {\n            sim.running = false;\n            break;\n          }\n        }\n      }\n\n      // stop running when ball goes beyond a \"ground\" defined as y very large compared to initial (we interpret ground at y = sim.params.h + some)\n      // For clearer behavior: if position exceeds domain we keep plotting but do not auto-stop.\n      drawScene();\n\n      // update plots\n      drawPlot(ctxPos, posPlot, sim.history.t, sim.history.y, '#7dd3fc', false);\n      drawPlot(ctxVel, velPlot, sim.history.t, sim.history.v, '#fda4af', false);\n\n      requestAnimationFrame(frame);\n    }\n\n    // --- Event listeners ---\n    playBtn.addEventListener('click', () => { sim.running = true; });\n    pauseBtn.addEventListener('click', () => { sim.running = false; });\n    resetBtn.addEventListener('click', () => { sim.running = false; resetSim(); });\n\n    [hRange, v0Range, gRange, massRange, dragRange, timeScale, dragToggle].forEach(el => {\n      el.addEventListener('input', () => {\n        updateParams();\n        // If simulation not running, reflect changes immediately in scene and reset initial position\n        if (!sim.running) {\n          resetSim();\n        } else {\n          // update params in flight\n          updateParams();\n        }\n      });\n    });\n\n    // initialize sizes and simulation\n    resizeCanvases();\n    resetSim();\n    requestAnimationFrame(frame);\n\n    // Accessibility: keyboard shortcuts\n    window.addEventListener('keydown', (e) => {\n      if (e.key === ' ') { sim.running = !sim.running; e.preventDefault(); }\n      if (e.key === 'r') { resetSim(); }\n      if (e.key === 'p') { sim.running = false; }\n    });\n\n    // Note: For stability and simplicity, we treat y as the \"distance fallen\" from initial height.\n    // If you want ground collision stop: you can check when sim.y >= sim.params.h (distance >= initial height) and then set running=false and v=0.\n    // Implement simple ground stop:\n    setInterval(() => {\n      // Stop when ball reaches or passes \"ground\" (distance fallen >= initial height)\n      if (sim.y >= sim.params.h) {\n        sim.y = sim.params.h;\n        if (sim.running) {\n          sim.running = false;\n        }\n        sim.v = 0;\n      }\n    }, 50);\n  </script>",
                "css_content": ":root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #60a5fa;\n      --muted: #94a3b8;\n      --glass: rgba(255,255,255,0.04);\n      --card-radius: 10px;\n    }\n    html,body { height:100%; margin:0; font-family: Inter, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: linear-gradient(180deg,#071029 0%, #0b1220 100%); color:#e6eef8; }\n    .wrap { max-width:1100px; margin:20px auto; padding:18px; }\n    h1 { margin:0 0 6px 0; font-size:20px; color:var(--accent); }\n    p.lead { margin:0 0 12px 0; color:var(--muted); font-size:13px; }\n    .grid { display:grid; grid-template-columns: 1fr 380px; gap:16px; align-items:start; }\n    .card {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: var(--card-radius);\n      padding:12px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n    .sim-area { height:520px; display:flex; flex-direction:column; gap:8px; }\n    canvas#scene { background: linear-gradient(180deg,#07112a,#081023); border-radius:8px; width:100%; height:330px; display:block; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n    .control { display:flex; gap:8px; align-items:center; }\n    label { font-size:13px; color:var(--muted); min-width:110px; }\n    input[type=\"range\"] { accent-color: var(--accent); }\n    .value { font-weight:600; color:#e6eef8; min-width:60px; text-align:right; font-size:13px; }\n    .btn { background:linear-gradient(180deg,#1e293b,#111827); color:#e6eef8; border-radius:8px; padding:8px 12px; border:1px solid rgba(255,255,255,0.04); cursor:pointer; }\n    .small { font-size:12px; color:var(--muted); margin-top:6px; }\n    .readouts { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; }\n    .readout { background:var(--glass); padding:8px 10px; border-radius:8px; min-width:120px; text-align:left; }\n    .plot-row { display:flex; gap:8px; margin-top:8px; }\n    canvas.plot { background: #021027; border-radius:6px; width:100%; height:110px; display:block; }\n    footer { margin-top:10px; color:var(--muted); font-size:12px; }\n    .toggle { display:flex; align-items:center; gap:8px; }\n    @media (max-width:1000px) {\n      .grid { grid-template-columns: 1fr; }\n      .sim-area { height:auto; }\n      canvas#scene { height:260px; }\n    }",
                "js_content": "// --- 常量与 DOM 元素 ---\n    const scene = document.getElementById('scene');\n    const posPlot = document.getElementById('posPlot');\n    const velPlot = document.getElementById('velPlot');\n    const ctx = scene.getContext('2d');\n    const ctxPos = posPlot.getContext('2d');\n    const ctxVel = velPlot.getContext('2d');\n\n    // Controls\n    const hRange = document.getElementById('hRange'), hVal = document.getElementById('hVal');\n    const v0Range = document.getElementById('v0Range'), v0Val = document.getElementById('v0Val');\n    const gRange = document.getElementById('gRange'), gVal = document.getElementById('gVal');\n    const massRange = document.getElementById('massRange'), massVal = document.getElementById('massVal');\n    const dragRange = document.getElementById('dragRange'), dragVal = document.getElementById('dragVal');\n    const timeScale = document.getElementById('timeScale'), timeScaleVal = document.getElementById('timeScaleVal');\n    const dragToggle = document.getElementById('dragToggle');\n    const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');\n\n    const tDisplay = document.getElementById('tVal'), yDisplay = document.getElementById('yVal'), vDisplay = document.getElementById('vVal'), aDisplay = document.getElementById('aVal');\n\n    // Canvas sizing helper\n    function resizeCanvases() {\n      const dpr = window.devicePixelRatio || 1;\n      // scene\n      const rect = scene.getBoundingClientRect();\n      scene.width = Math.round(rect.width * dpr);\n      scene.height = Math.round(rect.height * dpr);\n      ctx.setTransform(dpr,0,0,dpr,0,0);\n      // plots\n      const r1 = posPlot.getBoundingClientRect();\n      posPlot.width = Math.round(r1.width * dpr);\n      posPlot.height = Math.round(r1.height * dpr);\n      ctxPos.setTransform(dpr,0,0,dpr,0,0);\n\n      const r2 = velPlot.getBoundingClientRect();\n      velPlot.width = Math.round(r2.width * dpr);\n      velPlot.height = Math.round(r2.height * dpr);\n      ctxVel.setTransform(dpr,0,0,dpr,0,0);\n    }\n    window.addEventListener('resize', resizeCanvases);\n\n    // --- 物理与仿真状态 ---\n    let sim = {\n      running: false,\n      t: 0,\n      y: 0,   // 高度（m），向下为正； ground at y=0\n      v: 0,\n      a: 0,\n      params: {\n        h: parseFloat(hRange.value),\n        v0: parseFloat(v0Range.value),\n        g: parseFloat(gRange.value),\n        m: parseFloat(massRange.value),\n        b: parseFloat(dragRange.value),\n        dragOn: dragToggle.checked,\n        timeScale: parseFloat(timeScale.value)\n      },\n      history: { t:[], y:[], v:[] }\n    };\n\n    // initialize values display\n    function syncUI() {\n      hVal.textContent = Number(hRange.value).toFixed(0);\n      v0Val.textContent = Number(v0Range.value).toFixed(0);\n      gVal.textContent = Number(gRange.value).toFixed(2);\n      massVal.textContent = Number(massRange.value).toFixed(1);\n      dragVal.textContent = Number(dragRange.value).toFixed(2);\n      timeScaleVal.textContent = Number(timeScale.value).toFixed(1) + 'x';\n    }\n    syncUI();\n\n    // Update params from controls\n    function updateParams() {\n      sim.params.h = parseFloat(hRange.value);\n      sim.params.v0 = parseFloat(v0Range.value);\n      sim.params.g = parseFloat(gRange.value);\n      sim.params.m = parseFloat(massRange.value);\n      sim.params.b = parseFloat(dragRange.value);\n      sim.params.dragOn = dragToggle.checked;\n      sim.params.timeScale = parseFloat(timeScale.value);\n      syncUI();\n    }\n\n    // Reset simulation to initial state\n    function resetSim() {\n      updateParams();\n      sim.t = 0;\n      sim.y = sim.params.h; // height above ground in meters (we treat ground at y=0)\n      sim.v = sim.params.v0;\n      sim.a = sim.params.g; // initial a (approx)\n      sim.history.t = [0];\n      sim.history.y = [sim.y];\n      sim.history.v = [sim.v];\n      // clear plots\n      clearPlots();\n      drawScene();\n    }\n\n    // Numerical integration: semi-implicit Euler (velocity updated from acceleration, then position)\n    function stepSim(dtRealSeconds) {\n      const dt = dtRealSeconds * sim.params.timeScale;\n      const g = sim.params.g;\n      const m = sim.params.m;\n      const b = sim.params.b;\n      let a;\n      if (sim.params.dragOn && b > 0) {\n        // model: a = g - (b/m) * v, with v positive downward\n        a = g - (b/m) * sim.v;\n      } else {\n        a = g;\n      }\n      // semi-implicit Euler\n      sim.v += a * dt;\n      sim.y += sim.v * dt;\n      sim.t += dt;\n      sim.a = a;\n      sim.history.t.push(sim.t);\n      sim.history.y.push(sim.y);\n      sim.history.v.push(sim.v);\n    }\n\n    // Drawing utilities\n    function clearPlots() {\n      ctxPos.clearRect(0,0,posPlot.width,posPlot.height);\n      ctxVel.clearRect(0,0,velPlot.width,velPlot.height);\n      // draw axes lightly\n      drawAxes(ctxPos, posPlot, \"高度 (m)\");\n      drawAxes(ctxVel, velPlot, \"速度 (m/s)\");\n    }\n\n    function drawAxes(ctxP, canvasElem, label) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      ctxP.save();\n      ctxP.fillStyle = '#072033';\n      ctxP.fillRect(0,0,w,h);\n      ctxP.strokeStyle = 'rgba(255,255,255,0.03)';\n      ctxP.beginPath();\n      ctxP.moveTo(36,6);\n      ctxP.lineTo(36,h-18);\n      ctxP.lineTo(w-6,h-18);\n      ctxP.stroke();\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '12px sans-serif';\n      ctxP.fillText(label, 6, 12);\n      ctxP.restore();\n    }\n\n    function drawPlot(ctxP, canvasElem, dataX, dataY, color='#7dd3fc', dashed=false) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      const margin = { left:40, right:6, top:6, bottom:18 };\n      // compute ranges\n      const tMin = 0;\n      const tMax = Math.max(1, dataX[dataX.length-1]);\n      const yMin = Math.min(...dataY, 0);\n      const yMax = Math.max(...dataY, 1);\n      const pad = (yMax - yMin) * 0.12;\n      const Ymin = yMin - pad;\n      const Ymax = yMax + pad;\n\n      ctxP.save();\n      // background\n      ctxP.fillStyle = '#021028';\n      ctxP.fillRect(0,0,w,h);\n\n      // axes\n      ctxP.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctxP.beginPath();\n      ctxP.moveTo(margin.left, margin.top);\n      ctxP.lineTo(margin.left, h - margin.bottom);\n      ctxP.lineTo(w - margin.right, h - margin.bottom);\n      ctxP.stroke();\n\n      // plot data\n      ctxP.lineWidth = 2;\n      ctxP.strokeStyle = color;\n      if (dashed) ctxP.setLineDash([6,4]); else ctxP.setLineDash([]);\n      ctxP.beginPath();\n      for (let i=0;i<dataX.length;i++) {\n        const tx = dataX[i];\n        const val = dataY[i];\n        const x = margin.left + ((tx - tMin) / (tMax - tMin)) * (w - margin.left - margin.right);\n        const y = (h - margin.bottom) - ((val - Ymin) / (Ymax - Ymin)) * (h - margin.top - margin.bottom);\n        if (i===0) ctxP.moveTo(x,y); else ctxP.lineTo(x,y);\n      }\n      ctxP.stroke();\n\n      // labels\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText('t (s)', w - 40, h - 2);\n\n      // value ticks (min/max)\n      ctxP.fillStyle = '#94a3b8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText(Ymax.toFixed(2), 6, 14);\n      ctxP.fillText(Ymin.toFixed(2), 6, h - 22);\n\n      ctxP.restore();\n    }\n\n    function drawScene() {\n      // scene canvas: draw ground, scale and ball\n      ctx.clearRect(0,0,scene.width, scene.height);\n      const cw = scene.width / (window.devicePixelRatio || 1);\n      const ch = scene.height / (window.devicePixelRatio || 1);\n\n      // background gradient\n      const grad = ctx.createLinearGradient(0,0,0,ch);\n      grad.addColorStop(0, '#07112a');\n      grad.addColorStop(1, '#021027');\n      ctx.fillStyle = grad;\n      ctx.fillRect(0,0,cw,ch);\n\n      // Compute mapping: physical height in meters maps to pixel y\n      const maxH = Math.max(sim.params.h, 200); // at least 200m domain for good scale\n      const topMargin = 30;\n      const bottomMargin = 30;\n      const usable = ch - topMargin - bottomMargin;\n      // clamp max domain by some function to keep visible when very large\n      const domainH = Math.max(maxH, 1);\n      const pixelsPerMeter = usable / domainH;\n\n      // draw ground line\n      const groundY = topMargin + domainH * pixelsPerMeter;\n      ctx.fillStyle = '#17384f';\n      ctx.fillRect(0, groundY, cw, ch - groundY);\n\n      ctx.strokeStyle = '#2aa6ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(0, groundY + 0.5);\n      ctx.lineTo(cw, groundY + 0.5);\n      ctx.stroke();\n\n      // draw height ticks\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\n      ctx.font = '11px sans-serif';\n      for (let m=0; m <= domainH; m += Math.max(1, Math.floor(domainH/6))) {\n        const ypix = topMargin + m * pixelsPerMeter;\n        ctx.beginPath();\n        ctx.moveTo(6, ypix + 0.5);\n        ctx.lineTo(18, ypix + 0.5);\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        ctx.stroke();\n        ctx.fillStyle = '#9fbbe8';\n        ctx.fillText((domainH - m).toFixed(0) + ' m', 22, ypix + 4);\n      }\n\n      // draw analytical trajectory (if no drag)\n      if (!sim.params.dragOn) {\n        // sample times over a small horizon\n        const tMax = Math.max(1, sim.history.t[sim.history.t.length-1] + 1);\n        ctx.beginPath();\n        ctx.setLineDash([6,6]);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = 'rgba(255,200,80,0.6)';\n        for (let i=0;i<=60;i++) {\n          const tt = (i/60) * tMax;\n          const yAnal = sim.params.h + sim.params.v0 * tt + 0.5 * sim.params.g * tt * tt;\n          const yClamped = Math.min(yAnal, domainH);\n          const ypix = topMargin + yClamped * pixelsPerMeter;\n          const x = cw * 0.15 + (i/60) * (cw * 0.7);\n          if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n        }\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n\n      // draw trail from history\n      ctx.beginPath();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = 'rgba(96,165,250,0.9)';\n      for (let i=0;i<sim.history.y.length;i+=Math.max(1, Math.floor(sim.history.y.length/300))) {\n        const yv = Math.min(sim.history.y[i], domainH);\n        const x = cw * 0.15 + (i / Math.max(1, sim.history.y.length-1)) * (cw * 0.7);\n        const ypix = topMargin + yv * pixelsPerMeter;\n        if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n      }\n      ctx.stroke();\n\n      // draw ball current position\n      const ballX = cw * 0.15 + (sim.history.length ? (sim.history.y.length-1) / Math.max(1, sim.history.y.length-1) : 0) * (cw * 0.7);\n      const yPixBall = topMargin + Math.min(sim.y, domainH) * pixelsPerMeter;\n      const rpx = 12;\n      // shadow\n      ctx.beginPath();\n      ctx.ellipse(ballX + 6, groundY + 6, 18, 6, 0, 0, Math.PI*2);\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\n      ctx.fill();\n\n      // ball\n      const gradBall = ctx.createRadialGradient(ballX - 4, yPixBall - 6, 4, ballX, yPixBall, 18);\n      gradBall.addColorStop(0, '#9be7ff');\n      gradBall.addColorStop(1, '#1560a9');\n      ctx.fillStyle = gradBall;\n      ctx.beginPath();\n      ctx.arc(ballX, yPixBall, rpx, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n      ctx.stroke();\n\n      // textual info\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = '13px sans-serif';\n      ctx.fillText('高度 (m): ' + sim.y.toFixed(2), 12, 20);\n      ctx.fillText('速度 (m/s): ' + sim.v.toFixed(2), 12, 36);\n\n      // update numeric displays\n      tDisplay.textContent = sim.t.toFixed(2);\n      yDisplay.textContent = Math.max(0, (sim.params.h - (sim.params.h - sim.y))).toFixed(2); // just show sim.y\n      vDisplay.textContent = sim.v.toFixed(2);\n      aDisplay.textContent = sim.a.toFixed(2);\n    }\n\n    // --- Main loop ---\n    let lastFrameTime = null;\n    function frame(ts) {\n      if (!lastFrameTime) lastFrameTime = ts;\n      const dtMillis = ts - lastFrameTime;\n      lastFrameTime = ts;\n      const dtSec = dtMillis / 1000;\n\n      if (sim.running) {\n        // integrate in fixed small steps for stability\n        let remaining = dtSec;\n        const step = 0.016; // 16ms ~ 60Hz physics step\n        while (remaining > 1e-6) {\n          const d = Math.min(step, remaining);\n          stepSim(d);\n          remaining -= d;\n          // stop when hits ground\n          if (sim.y >= Math.max(sim.params.h, sim.y) && false) { /* placeholder */ }\n          // If ball hits ground (simulate bounce off ground? For now stop at ground)\n          if (sim.y >= 10000) {\n            // safety clamp for insane values\n            sim.y = 10000;\n            sim.v = 0;\n            sim.running = false;\n            break;\n          }\n          // Stop if y is below ground (we treat ground at y = large domain; instead we stop when actual y passes some threshold)\n          if (sim.y >= 1e9) {\n            sim.running = false;\n            break;\n          }\n        }\n      }\n\n      // stop running when ball goes beyond a \"ground\" defined as y very large compared to initial (we interpret ground at y = sim.params.h + some)\n      // For clearer behavior: if position exceeds domain we keep plotting but do not auto-stop.\n      drawScene();\n\n      // update plots\n      drawPlot(ctxPos, posPlot, sim.history.t, sim.history.y, '#7dd3fc', false);\n      drawPlot(ctxVel, velPlot, sim.history.t, sim.history.v, '#fda4af', false);\n\n      requestAnimationFrame(frame);\n    }\n\n    // --- Event listeners ---\n    playBtn.addEventListener('click', () => { sim.running = true; });\n    pauseBtn.addEventListener('click', () => { sim.running = false; });\n    resetBtn.addEventListener('click', () => { sim.running = false; resetSim(); });\n\n    [hRange, v0Range, gRange, massRange, dragRange, timeScale, dragToggle].forEach(el => {\n      el.addEventListener('input', () => {\n        updateParams();\n        // If simulation not running, reflect changes immediately in scene and reset initial position\n        if (!sim.running) {\n          resetSim();\n        } else {\n          // update params in flight\n          updateParams();\n        }\n      });\n    });\n\n    // initialize sizes and simulation\n    resizeCanvases();\n    resetSim();\n    requestAnimationFrame(frame);\n\n    // Accessibility: keyboard shortcuts\n    window.addEventListener('keydown', (e) => {\n      if (e.key === ' ') { sim.running = !sim.running; e.preventDefault(); }\n      if (e.key === 'r') { resetSim(); }\n      if (e.key === 'p') { sim.running = false; }\n    });\n\n    // Note: For stability and simplicity, we treat y as the \"distance fallen\" from initial height.\n    // If you want ground collision stop: you can check when sim.y >= sim.params.h (distance >= initial height) and then set running=false and v=0.\n    // Implement simple ground stop:\n    setInterval(() => {\n      // Stop when ball reaches or passes \"ground\" (distance fallen >= initial height)\n      if (sim.y >= sim.params.h) {\n        sim.y = sim.params.h;\n        if (sim.running) {\n          sim.running = false;\n        }\n        sim.v = 0;\n      }\n    }, 50);",
                "parameters": [],
                "status": "success"
              },
              "attempts": 1
            },
            "rawData": "{\"success\":true,\"data\":{\"experiment_id\":\"e94455b3-2280-461f-ba61-7dd55031ecf0\",\"title\":\"重力球下落模拟\",\"description\":\"简短摘要（依据 Perplexity 研究资料）：\\n- 本模拟演示的是重力下的垂直自由落体运动。恒定重力加速度 g（标准约为 9.81 m/s²）使物体做匀加速直线运动，解析解为：位置 y(t)=y0+v0*t+0.5*g*t²，速度 v(t)=v0+g*t（向下为正方向）。（来源：Perplexity AI）\\n- 为了更接近真实情况，演示中还提供了线性空气阻力（阻力与速度成正比）的选项，阻力会改变加速度：a = g - (b/m) * v。开启阻力时采用数值积分（欧拉/半隐式欧拉）求解。\\n- 本 demo 提供交互控件（高度、初速度、重力、质量、阻力系数、时间缩放、播放/重置等），并显示数值读数与位置/速度随时间的曲线，且在无阻力时对比解析解曲线。\\n\\n下面是完整可运行的自包含 HTML 代码（保存为 .html 文件后直接在浏览器打开即可）：\",\"html_content\":\"<div class=\\\"wrap\\\">\\n    <h1>重力球下落模拟</h1>\\n    <p class=\\\"lead\\\">演示自由落体（恒定重力）与线性空气阻力的影响。可调初始高度、初速度、重力、质量和阻力系数。解析解仅在无阻力时与数值解一致。（资料来源：Perplexity AI）</p>\\n\\n    <div class=\\\"grid\\\">\\n      <!-- 左侧：模拟画布与图表 -->\\n      <div class=\\\"card\\\">\\n        <div class=\\\"sim-area\\\">\\n          <canvas id=\\\"scene\\\" aria-label=\\\"重力球下落模拟画布\\\"></canvas>\\n\\n          <div class=\\\"plot-row\\\">\\n            <canvas id=\\\"posPlot\\\" class=\\\"plot\\\" aria-label=\\\"位置-时间图\\\"></canvas>\\n            <canvas id=\\\"velPlot\\\" class=\\\"plot\\\" aria-label=\\\"速度-时间图\\\"></canvas>\\n          </div>\\n\\n          <div class=\\\"readouts\\\">\\n            <div class=\\\"readout\\\">时间 (s): <span id=\\\"tVal\\\">0.00</span></div>\\n            <div class=\\\"readout\\\">高度 (m): <span id=\\\"yVal\\\">0.00</span></div>\\n            <div class=\\\"readout\\\">速度 (m/s): <span id=\\\"vVal\\\">0.00</span></div>\\n            <div class=\\\"readout\\\">加速度 (m/s²): <span id=\\\"aVal\\\">0.00</span></div>\\n          </div>\\n        </div>\\n      </div>\\n\\n      <!-- 右侧：控制与参数 -->\\n      <div class=\\\"card\\\">\\n        <div style=\\\"display:flex;gap:10px;align-items:center;justify-content:space-between;\\\">\\n          <div style=\\\"display:flex;flex-direction:column;\\\">\\n            <strong>控制</strong>\\n            <span class=\\\"small\\\">播放 / 暂停 / 重置 仿真</span>\\n          </div>\\n          <div style=\\\"display:flex;gap:8px;\\\">\\n            <button id=\\\"playBtn\\\" class=\\\"btn\\\">播放</button>\\n            <button id=\\\"pauseBtn\\\" class=\\\"btn\\\">暂停</button>\\n            <button id=\\\"resetBtn\\\" class=\\\"btn\\\">重置</button>\\n          </div>\\n        </div>\\n\\n        <hr style=\\\"border:0;border-top:1px solid rgba(255,255,255,0.03);margin:10px 0;\\\">\\n\\n        <div>\\n          <div style=\\\"display:flex;flex-direction:column;gap:8px;\\\">\\n            <div class=\\\"control\\\">\\n              <label for=\\\"hRange\\\">初始高度 h (m)</label>\\n              <input id=\\\"hRange\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"200\\\" step=\\\"1\\\" value=\\\"50\\\">\\n              <div class=\\\"value\\\" id=\\\"hVal\\\">50</div>\\n            </div>\\n\\n            <div class=\\\"control\\\">\\n              <label for=\\\"v0Range\\\">初速度 v0 (m/s)</label>\\n              <input id=\\\"v0Range\\\" type=\\\"range\\\" min=\\\"-50\\\" max=\\\"50\\\" step=\\\"1\\\" value=\\\"0\\\">\\n              <div class=\\\"value\\\" id=\\\"v0Val\\\">0</div>\\n            </div>\\n\\n            <div class=\\\"control\\\">\\n              <label for=\\\"gRange\\\">重力 g (m/s²)</label>\\n              <input id=\\\"gRange\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"20\\\" step=\\\"0.01\\\" value=\\\"9.81\\\">\\n              <div class=\\\"value\\\" id=\\\"gVal\\\">9.81</div>\\n            </div>\\n\\n            <div class=\\\"control\\\">\\n              <label for=\\\"massRange\\\">质量 m (kg)</label>\\n              <input id=\\\"massRange\\\" type=\\\"range\\\" min=\\\"0.1\\\" max=\\\"10\\\" step=\\\"0.1\\\" value=\\\"1\\\">\\n              <div class=\\\"value\\\" id=\\\"massVal\\\">1.0</div>\\n            </div>\\n\\n            <div class=\\\"control\\\">\\n              <label for=\\\"dragRange\\\">阻力系数 b (kg/s)</label>\\n              <input id=\\\"dragRange\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"5\\\" step=\\\"0.01\\\" value=\\\"0.00\\\">\\n              <div class=\\\"value\\\" id=\\\"dragVal\\\">0.00</div>\\n            </div>\\n\\n            <div class=\\\"control\\\">\\n              <label for=\\\"timeScale\\\">时间缩放</label>\\n              <input id=\\\"timeScale\\\" type=\\\"range\\\" min=\\\"0.1\\\" max=\\\"4\\\" step=\\\"0.1\\\" value=\\\"1\\\">\\n              <div class=\\\"value\\\" id=\\\"timeScaleVal\\\">1.0x</div>\\n            </div>\\n\\n            <div class=\\\"control toggle\\\">\\n              <input id=\\\"dragToggle\\\" type=\\\"checkbox\\\" />\\n              <label for=\\\"dragToggle\\\" style=\\\"min-width:0;\\\">启用空气阻力（线性）</label>\\n            </div>\\n          </div>\\n        </div>\\n\\n        <div class=\\\"small\\\" style=\\\"margin-top:12px;\\\">\\n          使用说明：调整参数后可点击“重置”使球回到初始状态，点击播放开始仿真；当阻力关闭时，右侧图表会显示解析解（虚线）作为对比。\\n        </div>\\n      </div>\\n    </div>\\n\\n    <footer>\\n      注：解析公式（无阻力） y(t)=y0 + v0*t + 0.5*g*t²，v(t)=v0 + g*t。阻力模型：线性阻力 F_d = -b*v（向上若 v 向下为正）。\\n    </footer>\\n  </div>\\n\\n  <script>\\n    // --- 常量与 DOM 元素 ---\\n    const scene = document.getElementById('scene');\\n    const posPlot = document.getElementById('posPlot');\\n    const velPlot = document.getElementById('velPlot');\\n    const ctx = scene.getContext('2d');\\n    const ctxPos = posPlot.getContext('2d');\\n    const ctxVel = velPlot.getContext('2d');\\n\\n    // Controls\\n    const hRange = document.getElementById('hRange'), hVal = document.getElementById('hVal');\\n    const v0Range = document.getElementById('v0Range'), v0Val = document.getElementById('v0Val');\\n    const gRange = document.getElementById('gRange'), gVal = document.getElementById('gVal');\\n    const massRange = document.getElementById('massRange'), massVal = document.getElementById('massVal');\\n    const dragRange = document.getElementById('dragRange'), dragVal = document.getElementById('dragVal');\\n    const timeScale = document.getElementById('timeScale'), timeScaleVal = document.getElementById('timeScaleVal');\\n    const dragToggle = document.getElementById('dragToggle');\\n    const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');\\n\\n    const tDisplay = document.getElementById('tVal'), yDisplay = document.getElementById('yVal'), vDisplay = document.getElementById('vVal'), aDisplay = document.getElementById('aVal');\\n\\n    // Canvas sizing helper\\n    function resizeCanvases() {\\n      const dpr = window.devicePixelRatio || 1;\\n      // scene\\n      const rect = scene.getBoundingClientRect();\\n      scene.width = Math.round(rect.width * dpr);\\n      scene.height = Math.round(rect.height * dpr);\\n      ctx.setTransform(dpr,0,0,dpr,0,0);\\n      // plots\\n      const r1 = posPlot.getBoundingClientRect();\\n      posPlot.width = Math.round(r1.width * dpr);\\n      posPlot.height = Math.round(r1.height * dpr);\\n      ctxPos.setTransform(dpr,0,0,dpr,0,0);\\n\\n      const r2 = velPlot.getBoundingClientRect();\\n      velPlot.width = Math.round(r2.width * dpr);\\n      velPlot.height = Math.round(r2.height * dpr);\\n      ctxVel.setTransform(dpr,0,0,dpr,0,0);\\n    }\\n    window.addEventListener('resize', resizeCanvases);\\n\\n    // --- 物理与仿真状态 ---\\n    let sim = {\\n      running: false,\\n      t: 0,\\n      y: 0,   // 高度（m），向下为正； ground at y=0\\n      v: 0,\\n      a: 0,\\n      params: {\\n        h: parseFloat(hRange.value),\\n        v0: parseFloat(v0Range.value),\\n        g: parseFloat(gRange.value),\\n        m: parseFloat(massRange.value),\\n        b: parseFloat(dragRange.value),\\n        dragOn: dragToggle.checked,\\n        timeScale: parseFloat(timeScale.value)\\n      },\\n      history: { t:[], y:[], v:[] }\\n    };\\n\\n    // initialize values display\\n    function syncUI() {\\n      hVal.textContent = Number(hRange.value).toFixed(0);\\n      v0Val.textContent = Number(v0Range.value).toFixed(0);\\n      gVal.textContent = Number(gRange.value).toFixed(2);\\n      massVal.textContent = Number(massRange.value).toFixed(1);\\n      dragVal.textContent = Number(dragRange.value).toFixed(2);\\n      timeScaleVal.textContent = Number(timeScale.value).toFixed(1) + 'x';\\n    }\\n    syncUI();\\n\\n    // Update params from controls\\n    function updateParams() {\\n      sim.params.h = parseFloat(hRange.value);\\n      sim.params.v0 = parseFloat(v0Range.value);\\n      sim.params.g = parseFloat(gRange.value);\\n      sim.params.m = parseFloat(massRange.value);\\n      sim.params.b = parseFloat(dragRange.value);\\n      sim.params.dragOn = dragToggle.checked;\\n      sim.params.timeScale = parseFloat(timeScale.value);\\n      syncUI();\\n    }\\n\\n    // Reset simulation to initial state\\n    function resetSim() {\\n      updateParams();\\n      sim.t = 0;\\n      sim.y = sim.params.h; // height above ground in meters (we treat ground at y=0)\\n      sim.v = sim.params.v0;\\n      sim.a = sim.params.g; // initial a (approx)\\n      sim.history.t = [0];\\n      sim.history.y = [sim.y];\\n      sim.history.v = [sim.v];\\n      // clear plots\\n      clearPlots();\\n      drawScene();\\n    }\\n\\n    // Numerical integration: semi-implicit Euler (velocity updated from acceleration, then position)\\n    function stepSim(dtRealSeconds) {\\n      const dt = dtRealSeconds * sim.params.timeScale;\\n      const g = sim.params.g;\\n      const m = sim.params.m;\\n      const b = sim.params.b;\\n      let a;\\n      if (sim.params.dragOn && b > 0) {\\n        // model: a = g - (b/m) * v, with v positive downward\\n        a = g - (b/m) * sim.v;\\n      } else {\\n        a = g;\\n      }\\n      // semi-implicit Euler\\n      sim.v += a * dt;\\n      sim.y += sim.v * dt;\\n      sim.t += dt;\\n      sim.a = a;\\n      sim.history.t.push(sim.t);\\n      sim.history.y.push(sim.y);\\n      sim.history.v.push(sim.v);\\n    }\\n\\n    // Drawing utilities\\n    function clearPlots() {\\n      ctxPos.clearRect(0,0,posPlot.width,posPlot.height);\\n      ctxVel.clearRect(0,0,velPlot.width,velPlot.height);\\n      // draw axes lightly\\n      drawAxes(ctxPos, posPlot, \\\"高度 (m)\\\");\\n      drawAxes(ctxVel, velPlot, \\\"速度 (m/s)\\\");\\n    }\\n\\n    function drawAxes(ctxP, canvasElem, label) {\\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\\n      ctxP.save();\\n      ctxP.fillStyle = '#072033';\\n      ctxP.fillRect(0,0,w,h);\\n      ctxP.strokeStyle = 'rgba(255,255,255,0.03)';\\n      ctxP.beginPath();\\n      ctxP.moveTo(36,6);\\n      ctxP.lineTo(36,h-18);\\n      ctxP.lineTo(w-6,h-18);\\n      ctxP.stroke();\\n      ctxP.fillStyle = '#9fbbe8';\\n      ctxP.font = '12px sans-serif';\\n      ctxP.fillText(label, 6, 12);\\n      ctxP.restore();\\n    }\\n\\n    function drawPlot(ctxP, canvasElem, dataX, dataY, color='#7dd3fc', dashed=false) {\\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\\n      const margin = { left:40, right:6, top:6, bottom:18 };\\n      // compute ranges\\n      const tMin = 0;\\n      const tMax = Math.max(1, dataX[dataX.length-1]);\\n      const yMin = Math.min(...dataY, 0);\\n      const yMax = Math.max(...dataY, 1);\\n      const pad = (yMax - yMin) * 0.12;\\n      const Ymin = yMin - pad;\\n      const Ymax = yMax + pad;\\n\\n      ctxP.save();\\n      // background\\n      ctxP.fillStyle = '#021028';\\n      ctxP.fillRect(0,0,w,h);\\n\\n      // axes\\n      ctxP.strokeStyle = 'rgba(255,255,255,0.06)';\\n      ctxP.beginPath();\\n      ctxP.moveTo(margin.left, margin.top);\\n      ctxP.lineTo(margin.left, h - margin.bottom);\\n      ctxP.lineTo(w - margin.right, h - margin.bottom);\\n      ctxP.stroke();\\n\\n      // plot data\\n      ctxP.lineWidth = 2;\\n      ctxP.strokeStyle = color;\\n      if (dashed) ctxP.setLineDash([6,4]); else ctxP.setLineDash([]);\\n      ctxP.beginPath();\\n      for (let i=0;i<dataX.length;i++) {\\n        const tx = dataX[i];\\n        const val = dataY[i];\\n        const x = margin.left + ((tx - tMin) / (tMax - tMin)) * (w - margin.left - margin.right);\\n        const y = (h - margin.bottom) - ((val - Ymin) / (Ymax - Ymin)) * (h - margin.top - margin.bottom);\\n        if (i===0) ctxP.moveTo(x,y); else ctxP.lineTo(x,y);\\n      }\\n      ctxP.stroke();\\n\\n      // labels\\n      ctxP.fillStyle = '#9fbbe8';\\n      ctxP.font = '11px sans-serif';\\n      ctxP.fillText('t (s)', w - 40, h - 2);\\n\\n      // value ticks (min/max)\\n      ctxP.fillStyle = '#94a3b8';\\n      ctxP.font = '11px sans-serif';\\n      ctxP.fillText(Ymax.toFixed(2), 6, 14);\\n      ctxP.fillText(Ymin.toFixed(2), 6, h - 22);\\n\\n      ctxP.restore();\\n    }\\n\\n    function drawScene() {\\n      // scene canvas: draw ground, scale and ball\\n      ctx.clearRect(0,0,scene.width, scene.height);\\n      const cw = scene.width / (window.devicePixelRatio || 1);\\n      const ch = scene.height / (window.devicePixelRatio || 1);\\n\\n      // background gradient\\n      const grad = ctx.createLinearGradient(0,0,0,ch);\\n      grad.addColorStop(0, '#07112a');\\n      grad.addColorStop(1, '#021027');\\n      ctx.fillStyle = grad;\\n      ctx.fillRect(0,0,cw,ch);\\n\\n      // Compute mapping: physical height in meters maps to pixel y\\n      const maxH = Math.max(sim.params.h, 200); // at least 200m domain for good scale\\n      const topMargin = 30;\\n      const bottomMargin = 30;\\n      const usable = ch - topMargin - bottomMargin;\\n      // clamp max domain by some function to keep visible when very large\\n      const domainH = Math.max(maxH, 1);\\n      const pixelsPerMeter = usable / domainH;\\n\\n      // draw ground line\\n      const groundY = topMargin + domainH * pixelsPerMeter;\\n      ctx.fillStyle = '#17384f';\\n      ctx.fillRect(0, groundY, cw, ch - groundY);\\n\\n      ctx.strokeStyle = '#2aa6ff';\\n      ctx.lineWidth = 1;\\n      ctx.beginPath();\\n      ctx.moveTo(0, groundY + 0.5);\\n      ctx.lineTo(cw, groundY + 0.5);\\n      ctx.stroke();\\n\\n      // draw height ticks\\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\\n      ctx.font = '11px sans-serif';\\n      for (let m=0; m <= domainH; m += Math.max(1, Math.floor(domainH/6))) {\\n        const ypix = topMargin + m * pixelsPerMeter;\\n        ctx.beginPath();\\n        ctx.moveTo(6, ypix + 0.5);\\n        ctx.lineTo(18, ypix + 0.5);\\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\\n        ctx.stroke();\\n        ctx.fillStyle = '#9fbbe8';\\n        ctx.fillText((domainH - m).toFixed(0) + ' m', 22, ypix + 4);\\n      }\\n\\n      // draw analytical trajectory (if no drag)\\n      if (!sim.params.dragOn) {\\n        // sample times over a small horizon\\n        const tMax = Math.max(1, sim.history.t[sim.history.t.length-1] + 1);\\n        ctx.beginPath();\\n        ctx.setLineDash([6,6]);\\n        ctx.lineWidth = 2;\\n        ctx.strokeStyle = 'rgba(255,200,80,0.6)';\\n        for (let i=0;i<=60;i++) {\\n          const tt = (i/60) * tMax;\\n          const yAnal = sim.params.h + sim.params.v0 * tt + 0.5 * sim.params.g * tt * tt;\\n          const yClamped = Math.min(yAnal, domainH);\\n          const ypix = topMargin + yClamped * pixelsPerMeter;\\n          const x = cw * 0.15 + (i/60) * (cw * 0.7);\\n          if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\\n        }\\n        ctx.stroke();\\n        ctx.setLineDash([]);\\n      }\\n\\n      // draw trail from history\\n      ctx.beginPath();\\n      ctx.lineWidth = 2;\\n      ctx.strokeStyle = 'rgba(96,165,250,0.9)';\\n      for (let i=0;i<sim.history.y.length;i+=Math.max(1, Math.floor(sim.history.y.length/300))) {\\n        const yv = Math.min(sim.history.y[i], domainH);\\n        const x = cw * 0.15 + (i / Math.max(1, sim.history.y.length-1)) * (cw * 0.7);\\n        const ypix = topMargin + yv * pixelsPerMeter;\\n        if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\\n      }\\n      ctx.stroke();\\n\\n      // draw ball current position\\n      const ballX = cw * 0.15 + (sim.history.length ? (sim.history.y.length-1) / Math.max(1, sim.history.y.length-1) : 0) * (cw * 0.7);\\n      const yPixBall = topMargin + Math.min(sim.y, domainH) * pixelsPerMeter;\\n      const rpx = 12;\\n      // shadow\\n      ctx.beginPath();\\n      ctx.ellipse(ballX + 6, groundY + 6, 18, 6, 0, 0, Math.PI*2);\\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\\n      ctx.fill();\\n\\n      // ball\\n      const gradBall = ctx.createRadialGradient(ballX - 4, yPixBall - 6, 4, ballX, yPixBall, 18);\\n      gradBall.addColorStop(0, '#9be7ff');\\n      gradBall.addColorStop(1, '#1560a9');\\n      ctx.fillStyle = gradBall;\\n      ctx.beginPath();\\n      ctx.arc(ballX, yPixBall, rpx, 0, Math.PI * 2);\\n      ctx.fill();\\n      ctx.lineWidth = 1;\\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\\n      ctx.stroke();\\n\\n      // textual info\\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\\n      ctx.font = '13px sans-serif';\\n      ctx.fillText('高度 (m): ' + sim.y.toFixed(2), 12, 20);\\n      ctx.fillText('速度 (m/s): ' + sim.v.toFixed(2), 12, 36);\\n\\n      // update numeric displays\\n      tDisplay.textContent = sim.t.toFixed(2);\\n      yDisplay.textContent = Math.max(0, (sim.params.h - (sim.params.h - sim.y))).toFixed(2); // just show sim.y\\n      vDisplay.textContent = sim.v.toFixed(2);\\n      aDisplay.textContent = sim.a.toFixed(2);\\n    }\\n\\n    // --- Main loop ---\\n    let lastFrameTime = null;\\n    function frame(ts) {\\n      if (!lastFrameTime) lastFrameTime = ts;\\n      const dtMillis = ts - lastFrameTime;\\n      lastFrameTime = ts;\\n      const dtSec = dtMillis / 1000;\\n\\n      if (sim.running) {\\n        // integrate in fixed small steps for stability\\n        let remaining = dtSec;\\n        const step = 0.016; // 16ms ~ 60Hz physics step\\n        while (remaining > 1e-6) {\\n          const d = Math.min(step, remaining);\\n          stepSim(d);\\n          remaining -= d;\\n          // stop when hits ground\\n          if (sim.y >= Math.max(sim.params.h, sim.y) && false) { /* placeholder */ }\\n          // If ball hits ground (simulate bounce off ground? For now stop at ground)\\n          if (sim.y >= 10000) {\\n            // safety clamp for insane values\\n            sim.y = 10000;\\n            sim.v = 0;\\n            sim.running = false;\\n            break;\\n          }\\n          // Stop if y is below ground (we treat ground at y = large domain; instead we stop when actual y passes some threshold)\\n          if (sim.y >= 1e9) {\\n            sim.running = false;\\n            break;\\n          }\\n        }\\n      }\\n\\n      // stop running when ball goes beyond a \\\"ground\\\" defined as y very large compared to initial (we interpret ground at y = sim.params.h + some)\\n      // For clearer behavior: if position exceeds domain we keep plotting but do not auto-stop.\\n      drawScene();\\n\\n      // update plots\\n      drawPlot(ctxPos, posPlot, sim.history.t, sim.history.y, '#7dd3fc', false);\\n      drawPlot(ctxVel, velPlot, sim.history.t, sim.history.v, '#fda4af', false);\\n\\n      requestAnimationFrame(frame);\\n    }\\n\\n    // --- Event listeners ---\\n    playBtn.addEventListener('click', () => { sim.running = true; });\\n    pauseBtn.addEventListener('click', () => { sim.running = false; });\\n    resetBtn.addEventListener('click', () => { sim.running = false; resetSim(); });\\n\\n    [hRange, v0Range, gRange, massRange, dragRange, timeScale, dragToggle].forEach(el => {\\n      el.addEventListener('input', () => {\\n        updateParams();\\n        // If simulation not running, reflect changes immediately in scene and reset initial position\\n        if (!sim.running) {\\n          resetSim();\\n        } else {\\n          // update params in flight\\n          updateParams();\\n        }\\n      });\\n    });\\n\\n    // initialize sizes and simulation\\n    resizeCanvases();\\n    resetSim();\\n    requestAnimationFrame(frame);\\n\\n    // Accessibility: keyboard shortcuts\\n    window.addEventListener('keydown', (e) => {\\n      if (e.key === ' ') { sim.running = !sim.running; e.preventDefault(); }\\n      if (e.key === 'r') { resetSim(); }\\n      if (e.key === 'p') { sim.running = false; }\\n    });\\n\\n    // Note: For stability and simplicity, we treat y as the \\\"distance fallen\\\" from initial height.\\n    // If you want ground collision stop: you can check when sim.y >= sim.params.h (distance >= initial height) and then set running=false and v=0.\\n    // Implement simple ground stop:\\n    setInterval(() => {\\n      // Stop when ball reaches or passes \\\"ground\\\" (distance fallen >= initial height)\\n      if (sim.y >= sim.params.h) {\\n        sim.y = sim.params.h;\\n        if (sim.running) {\\n          sim.running = false;\\n        }\\n        sim.v = 0;\\n      }\\n    }, 50);\\n  </script>\",\"css_content\":\":root {\\n      --bg: #0f1724;\\n      --panel: #0b1220;\\n      --accent: #60a5fa;\\n      --muted: #94a3b8;\\n      --glass: rgba(255,255,255,0.04);\\n      --card-radius: 10px;\\n    }\\n    html,body { height:100%; margin:0; font-family: Inter, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial; background: linear-gradient(180deg,#071029 0%, #0b1220 100%); color:#e6eef8; }\\n    .wrap { max-width:1100px; margin:20px auto; padding:18px; }\\n    h1 { margin:0 0 6px 0; font-size:20px; color:var(--accent); }\\n    p.lead { margin:0 0 12px 0; color:var(--muted); font-size:13px; }\\n    .grid { display:grid; grid-template-columns: 1fr 380px; gap:16px; align-items:start; }\\n    .card {\\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\\n      border-radius: var(--card-radius);\\n      padding:12px;\\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\\n      border: 1px solid rgba(255,255,255,0.03);\\n    }\\n    .sim-area { height:520px; display:flex; flex-direction:column; gap:8px; }\\n    canvas#scene { background: linear-gradient(180deg,#07112a,#081023); border-radius:8px; width:100%; height:330px; display:block; }\\n    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\\n    .control { display:flex; gap:8px; align-items:center; }\\n    label { font-size:13px; color:var(--muted); min-width:110px; }\\n    input[type=\\\"range\\\"] { accent-color: var(--accent); }\\n    .value { font-weight:600; color:#e6eef8; min-width:60px; text-align:right; font-size:13px; }\\n    .btn { background:linear-gradient(180deg,#1e293b,#111827); color:#e6eef8; border-radius:8px; padding:8px 12px; border:1px solid rgba(255,255,255,0.04); cursor:pointer; }\\n    .small { font-size:12px; color:var(--muted); margin-top:6px; }\\n    .readouts { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; }\\n    .readout { background:var(--glass); padding:8px 10px; border-radius:8px; min-width:120px; text-align:left; }\\n    .plot-row { display:flex; gap:8px; margin-top:8px; }\\n    canvas.plot { background: #021027; border-radius:6px; width:100%; height:110px; display:block; }\\n    footer { margin-top:10px; color:var(--muted); font-size:12px; }\\n    .toggle { display:flex; align-items:center; gap:8px; }\\n    @media (max-width:1000px) {\\n      .grid { grid-template-columns: 1fr; }\\n      .sim-area { height:auto; }\\n      canvas#scene { height:260px; }\\n    }\",\"js_content\":\"// --- 常量与 DOM 元素 ---\\n    const scene = document.getElementById('scene');\\n    const posPlot = document.getElementById('posPlot');\\n    const velPlot = document.getElementById('velPlot');\\n    const ctx = scene.getContext('2d');\\n    const ctxPos = posPlot.getContext('2d');\\n    const ctxVel = velPlot.getContext('2d');\\n\\n    // Controls\\n    const hRange = document.getElementById('hRange'), hVal = document.getElementById('hVal');\\n    const v0Range = document.getElementById('v0Range'), v0Val = document.getElementById('v0Val');\\n    const gRange = document.getElementById('gRange'), gVal = document.getElementById('gVal');\\n    const massRange = document.getElementById('massRange'), massVal = document.getElementById('massVal');\\n    const dragRange = document.getElementById('dragRange'), dragVal = document.getElementById('dragVal');\\n    const timeScale = document.getElementById('timeScale'), timeScaleVal = document.getElementById('timeScaleVal');\\n    const dragToggle = document.getElementById('dragToggle');\\n    const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');\\n\\n    const tDisplay = document.getElementById('tVal'), yDisplay = document.getElementById('yVal'), vDisplay = document.getElementById('vVal'), aDisplay = document.getElementById('aVal');\\n\\n    // Canvas sizing helper\\n    function resizeCanvases() {\\n      const dpr = window.devicePixelRatio || 1;\\n      // scene\\n      const rect = scene.getBoundingClientRect();\\n      scene.width = Math.round(rect.width * dpr);\\n      scene.height = Math.round(rect.height * dpr);\\n      ctx.setTransform(dpr,0,0,dpr,0,0);\\n      // plots\\n      const r1 = posPlot.getBoundingClientRect();\\n      posPlot.width = Math.round(r1.width * dpr);\\n      posPlot.height = Math.round(r1.height * dpr);\\n      ctxPos.setTransform(dpr,0,0,dpr,0,0);\\n\\n      const r2 = velPlot.getBoundingClientRect();\\n      velPlot.width = Math.round(r2.width * dpr);\\n      velPlot.height = Math.round(r2.height * dpr);\\n      ctxVel.setTransform(dpr,0,0,dpr,0,0);\\n    }\\n    window.addEventListener('resize', resizeCanvases);\\n\\n    // --- 物理与仿真状态 ---\\n    let sim = {\\n      running: false,\\n      t: 0,\\n      y: 0,   // 高度（m），向下为正； ground at y=0\\n      v: 0,\\n      a: 0,\\n      params: {\\n        h: parseFloat(hRange.value),\\n        v0: parseFloat(v0Range.value),\\n        g: parseFloat(gRange.value),\\n        m: parseFloat(massRange.value),\\n        b: parseFloat(dragRange.value),\\n        dragOn: dragToggle.checked,\\n        timeScale: parseFloat(timeScale.value)\\n      },\\n      history: { t:[], y:[], v:[] }\\n    };\\n\\n    // initialize values display\\n    function syncUI() {\\n      hVal.textContent = Number(hRange.value).toFixed(0);\\n      v0Val.textContent = Number(v0Range.value).toFixed(0);\\n      gVal.textContent = Number(gRange.value).toFixed(2);\\n      massVal.textContent = Number(massRange.value).toFixed(1);\\n      dragVal.textContent = Number(dragRange.value).toFixed(2);\\n      timeScaleVal.textContent = Number(timeScale.value).toFixed(1) + 'x';\\n    }\\n    syncUI();\\n\\n    // Update params from controls\\n    function updateParams() {\\n      sim.params.h = parseFloat(hRange.value);\\n      sim.params.v0 = parseFloat(v0Range.value);\\n      sim.params.g = parseFloat(gRange.value);\\n      sim.params.m = parseFloat(massRange.value);\\n      sim.params.b = parseFloat(dragRange.value);\\n      sim.params.dragOn = dragToggle.checked;\\n      sim.params.timeScale = parseFloat(timeScale.value);\\n      syncUI();\\n    }\\n\\n    // Reset simulation to initial state\\n    function resetSim() {\\n      updateParams();\\n      sim.t = 0;\\n      sim.y = sim.params.h; // height above ground in meters (we treat ground at y=0)\\n      sim.v = sim.params.v0;\\n      sim.a = sim.params.g; // initial a (approx)\\n      sim.history.t = [0];\\n      sim.history.y = [sim.y];\\n      sim.history.v = [sim.v];\\n      // clear plots\\n      clearPlots();\\n      drawScene();\\n    }\\n\\n    // Numerical integration: semi-implicit Euler (velocity updated from acceleration, then position)\\n    function stepSim(dtRealSeconds) {\\n      const dt = dtRealSeconds * sim.params.timeScale;\\n      const g = sim.params.g;\\n      const m = sim.params.m;\\n      const b = sim.params.b;\\n      let a;\\n      if (sim.params.dragOn && b > 0) {\\n        // model: a = g - (b/m) * v, with v positive downward\\n        a = g - (b/m) * sim.v;\\n      } else {\\n        a = g;\\n      }\\n      // semi-implicit Euler\\n      sim.v += a * dt;\\n      sim.y += sim.v * dt;\\n      sim.t += dt;\\n      sim.a = a;\\n      sim.history.t.push(sim.t);\\n      sim.history.y.push(sim.y);\\n      sim.history.v.push(sim.v);\\n    }\\n\\n    // Drawing utilities\\n    function clearPlots() {\\n      ctxPos.clearRect(0,0,posPlot.width,posPlot.height);\\n      ctxVel.clearRect(0,0,velPlot.width,velPlot.height);\\n      // draw axes lightly\\n      drawAxes(ctxPos, posPlot, \\\"高度 (m)\\\");\\n      drawAxes(ctxVel, velPlot, \\\"速度 (m/s)\\\");\\n    }\\n\\n    function drawAxes(ctxP, canvasElem, label) {\\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\\n      ctxP.save();\\n      ctxP.fillStyle = '#072033';\\n      ctxP.fillRect(0,0,w,h);\\n      ctxP.strokeStyle = 'rgba(255,255,255,0.03)';\\n      ctxP.beginPath();\\n      ctxP.moveTo(36,6);\\n      ctxP.lineTo(36,h-18);\\n      ctxP.lineTo(w-6,h-18);\\n      ctxP.stroke();\\n      ctxP.fillStyle = '#9fbbe8';\\n      ctxP.font = '12px sans-serif';\\n      ctxP.fillText(label, 6, 12);\\n      ctxP.restore();\\n    }\\n\\n    function drawPlot(ctxP, canvasElem, dataX, dataY, color='#7dd3fc', dashed=false) {\\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\\n      const margin = { left:40, right:6, top:6, bottom:18 };\\n      // compute ranges\\n      const tMin = 0;\\n      const tMax = Math.max(1, dataX[dataX.length-1]);\\n      const yMin = Math.min(...dataY, 0);\\n      const yMax = Math.max(...dataY, 1);\\n      const pad = (yMax - yMin) * 0.12;\\n      const Ymin = yMin - pad;\\n      const Ymax = yMax + pad;\\n\\n      ctxP.save();\\n      // background\\n      ctxP.fillStyle = '#021028';\\n      ctxP.fillRect(0,0,w,h);\\n\\n      // axes\\n      ctxP.strokeStyle = 'rgba(255,255,255,0.06)';\\n      ctxP.beginPath();\\n      ctxP.moveTo(margin.left, margin.top);\\n      ctxP.lineTo(margin.left, h - margin.bottom);\\n      ctxP.lineTo(w - margin.right, h - margin.bottom);\\n      ctxP.stroke();\\n\\n      // plot data\\n      ctxP.lineWidth = 2;\\n      ctxP.strokeStyle = color;\\n      if (dashed) ctxP.setLineDash([6,4]); else ctxP.setLineDash([]);\\n      ctxP.beginPath();\\n      for (let i=0;i<dataX.length;i++) {\\n        const tx = dataX[i];\\n        const val = dataY[i];\\n        const x = margin.left + ((tx - tMin) / (tMax - tMin)) * (w - margin.left - margin.right);\\n        const y = (h - margin.bottom) - ((val - Ymin) / (Ymax - Ymin)) * (h - margin.top - margin.bottom);\\n        if (i===0) ctxP.moveTo(x,y); else ctxP.lineTo(x,y);\\n      }\\n      ctxP.stroke();\\n\\n      // labels\\n      ctxP.fillStyle = '#9fbbe8';\\n      ctxP.font = '11px sans-serif';\\n      ctxP.fillText('t (s)', w - 40, h - 2);\\n\\n      // value ticks (min/max)\\n      ctxP.fillStyle = '#94a3b8';\\n      ctxP.font = '11px sans-serif';\\n      ctxP.fillText(Ymax.toFixed(2), 6, 14);\\n      ctxP.fillText(Ymin.toFixed(2), 6, h - 22);\\n\\n      ctxP.restore();\\n    }\\n\\n    function drawScene() {\\n      // scene canvas: draw ground, scale and ball\\n      ctx.clearRect(0,0,scene.width, scene.height);\\n      const cw = scene.width / (window.devicePixelRatio || 1);\\n      const ch = scene.height / (window.devicePixelRatio || 1);\\n\\n      // background gradient\\n      const grad = ctx.createLinearGradient(0,0,0,ch);\\n      grad.addColorStop(0, '#07112a');\\n      grad.addColorStop(1, '#021027');\\n      ctx.fillStyle = grad;\\n      ctx.fillRect(0,0,cw,ch);\\n\\n      // Compute mapping: physical height in meters maps to pixel y\\n      const maxH = Math.max(sim.params.h, 200); // at least 200m domain for good scale\\n      const topMargin = 30;\\n      const bottomMargin = 30;\\n      const usable = ch - topMargin - bottomMargin;\\n      // clamp max domain by some function to keep visible when very large\\n      const domainH = Math.max(maxH, 1);\\n      const pixelsPerMeter = usable / domainH;\\n\\n      // draw ground line\\n      const groundY = topMargin + domainH * pixelsPerMeter;\\n      ctx.fillStyle = '#17384f';\\n      ctx.fillRect(0, groundY, cw, ch - groundY);\\n\\n      ctx.strokeStyle = '#2aa6ff';\\n      ctx.lineWidth = 1;\\n      ctx.beginPath();\\n      ctx.moveTo(0, groundY + 0.5);\\n      ctx.lineTo(cw, groundY + 0.5);\\n      ctx.stroke();\\n\\n      // draw height ticks\\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\\n      ctx.font = '11px sans-serif';\\n      for (let m=0; m <= domainH; m += Math.max(1, Math.floor(domainH/6))) {\\n        const ypix = topMargin + m * pixelsPerMeter;\\n        ctx.beginPath();\\n        ctx.moveTo(6, ypix + 0.5);\\n        ctx.lineTo(18, ypix + 0.5);\\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\\n        ctx.stroke();\\n        ctx.fillStyle = '#9fbbe8';\\n        ctx.fillText((domainH - m).toFixed(0) + ' m', 22, ypix + 4);\\n      }\\n\\n      // draw analytical trajectory (if no drag)\\n      if (!sim.params.dragOn) {\\n        // sample times over a small horizon\\n        const tMax = Math.max(1, sim.history.t[sim.history.t.length-1] + 1);\\n        ctx.beginPath();\\n        ctx.setLineDash([6,6]);\\n        ctx.lineWidth = 2;\\n        ctx.strokeStyle = 'rgba(255,200,80,0.6)';\\n        for (let i=0;i<=60;i++) {\\n          const tt = (i/60) * tMax;\\n          const yAnal = sim.params.h + sim.params.v0 * tt + 0.5 * sim.params.g * tt * tt;\\n          const yClamped = Math.min(yAnal, domainH);\\n          const ypix = topMargin + yClamped * pixelsPerMeter;\\n          const x = cw * 0.15 + (i/60) * (cw * 0.7);\\n          if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\\n        }\\n        ctx.stroke();\\n        ctx.setLineDash([]);\\n      }\\n\\n      // draw trail from history\\n      ctx.beginPath();\\n      ctx.lineWidth = 2;\\n      ctx.strokeStyle = 'rgba(96,165,250,0.9)';\\n      for (let i=0;i<sim.history.y.length;i+=Math.max(1, Math.floor(sim.history.y.length/300))) {\\n        const yv = Math.min(sim.history.y[i], domainH);\\n        const x = cw * 0.15 + (i / Math.max(1, sim.history.y.length-1)) * (cw * 0.7);\\n        const ypix = topMargin + yv * pixelsPerMeter;\\n        if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\\n      }\\n      ctx.stroke();\\n\\n      // draw ball current position\\n      const ballX = cw * 0.15 + (sim.history.length ? (sim.history.y.length-1) / Math.max(1, sim.history.y.length-1) : 0) * (cw * 0.7);\\n      const yPixBall = topMargin + Math.min(sim.y, domainH) * pixelsPerMeter;\\n      const rpx = 12;\\n      // shadow\\n      ctx.beginPath();\\n      ctx.ellipse(ballX + 6, groundY + 6, 18, 6, 0, 0, Math.PI*2);\\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\\n      ctx.fill();\\n\\n      // ball\\n      const gradBall = ctx.createRadialGradient(ballX - 4, yPixBall - 6, 4, ballX, yPixBall, 18);\\n      gradBall.addColorStop(0, '#9be7ff');\\n      gradBall.addColorStop(1, '#1560a9');\\n      ctx.fillStyle = gradBall;\\n      ctx.beginPath();\\n      ctx.arc(ballX, yPixBall, rpx, 0, Math.PI * 2);\\n      ctx.fill();\\n      ctx.lineWidth = 1;\\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\\n      ctx.stroke();\\n\\n      // textual info\\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\\n      ctx.font = '13px sans-serif';\\n      ctx.fillText('高度 (m): ' + sim.y.toFixed(2), 12, 20);\\n      ctx.fillText('速度 (m/s): ' + sim.v.toFixed(2), 12, 36);\\n\\n      // update numeric displays\\n      tDisplay.textContent = sim.t.toFixed(2);\\n      yDisplay.textContent = Math.max(0, (sim.params.h - (sim.params.h - sim.y))).toFixed(2); // just show sim.y\\n      vDisplay.textContent = sim.v.toFixed(2);\\n      aDisplay.textContent = sim.a.toFixed(2);\\n    }\\n\\n    // --- Main loop ---\\n    let lastFrameTime = null;\\n    function frame(ts) {\\n      if (!lastFrameTime) lastFrameTime = ts;\\n      const dtMillis = ts - lastFrameTime;\\n      lastFrameTime = ts;\\n      const dtSec = dtMillis / 1000;\\n\\n      if (sim.running) {\\n        // integrate in fixed small steps for stability\\n        let remaining = dtSec;\\n        const step = 0.016; // 16ms ~ 60Hz physics step\\n        while (remaining > 1e-6) {\\n          const d = Math.min(step, remaining);\\n          stepSim(d);\\n          remaining -= d;\\n          // stop when hits ground\\n          if (sim.y >= Math.max(sim.params.h, sim.y) && false) { /* placeholder */ }\\n          // If ball hits ground (simulate bounce off ground? For now stop at ground)\\n          if (sim.y >= 10000) {\\n            // safety clamp for insane values\\n            sim.y = 10000;\\n            sim.v = 0;\\n            sim.running = false;\\n            break;\\n          }\\n          // Stop if y is below ground (we treat ground at y = large domain; instead we stop when actual y passes some threshold)\\n          if (sim.y >= 1e9) {\\n            sim.running = false;\\n            break;\\n          }\\n        }\\n      }\\n\\n      // stop running when ball goes beyond a \\\"ground\\\" defined as y very large compared to initial (we interpret ground at y = sim.params.h + some)\\n      // For clearer behavior: if position exceeds domain we keep plotting but do not auto-stop.\\n      drawScene();\\n\\n      // update plots\\n      drawPlot(ctxPos, posPlot, sim.history.t, sim.history.y, '#7dd3fc', false);\\n      drawPlot(ctxVel, velPlot, sim.history.t, sim.history.v, '#fda4af', false);\\n\\n      requestAnimationFrame(frame);\\n    }\\n\\n    // --- Event listeners ---\\n    playBtn.addEventListener('click', () => { sim.running = true; });\\n    pauseBtn.addEventListener('click', () => { sim.running = false; });\\n    resetBtn.addEventListener('click', () => { sim.running = false; resetSim(); });\\n\\n    [hRange, v0Range, gRange, massRange, dragRange, timeScale, dragToggle].forEach(el => {\\n      el.addEventListener('input', () => {\\n        updateParams();\\n        // If simulation not running, reflect changes immediately in scene and reset initial position\\n        if (!sim.running) {\\n          resetSim();\\n        } else {\\n          // update params in flight\\n          updateParams();\\n        }\\n      });\\n    });\\n\\n    // initialize sizes and simulation\\n    resizeCanvases();\\n    resetSim();\\n    requestAnimationFrame(frame);\\n\\n    // Accessibility: keyboard shortcuts\\n    window.addEventListener('keydown', (e) => {\\n      if (e.key === ' ') { sim.running = !sim.running; e.preventDefault(); }\\n      if (e.key === 'r') { resetSim(); }\\n      if (e.key === 'p') { sim.running = false; }\\n    });\\n\\n    // Note: For stability and simplicity, we treat y as the \\\"distance fallen\\\" from initial height.\\n    // If you want ground collision stop: you can check when sim.y >= sim.params.h (distance >= initial height) and then set running=false and v=0.\\n    // Implement simple ground stop:\\n    setInterval(() => {\\n      // Stop when ball reaches or passes \\\"ground\\\" (distance fallen >= initial height)\\n      if (sim.y >= sim.params.h) {\\n        sim.y = sim.params.h;\\n        if (sim.running) {\\n          sim.running = false;\\n        }\\n        sim.v = 0;\\n      }\\n    }, 50);\",\"parameters\":[],\"status\":\"success\"},\"attempts\":1}"
          }
        },
        {
          "stage": "data_analysis",
          "timestamp": "2025-08-09T13:09:00.908Z",
          "dataType": "object",
          "keys": [
            "success",
            "data",
            "attempts"
          ],
          "data": {
            "success": true,
            "data": {
              "experiment_id": "e94455b3-2280-461f-ba61-7dd55031ecf0",
              "title": "重力球下落模拟",
              "description": "简短摘要（依据 Perplexity 研究资料）：\n- 本模拟演示的是重力下的垂直自由落体运动。恒定重力加速度 g（标准约为 9.81 m/s²）使物体做匀加速直线运动，解析解为：位置 y(t)=y0+v0*t+0.5*g*t²，速度 v(t)=v0+g*t（向下为正方向）。（来源：Perplexity AI）\n- 为了更接近真实情况，演示中还提供了线性空气阻力（阻力与速度成正比）的选项，阻力会改变加速度：a = g - (b/m) * v。开启阻力时采用数值积分（欧拉/半隐式欧拉）求解。\n- 本 demo 提供交互控件（高度、初速度、重力、质量、阻力系数、时间缩放、播放/重置等），并显示数值读数与位置/速度随时间的曲线，且在无阻力时对比解析解曲线。\n\n下面是完整可运行的自包含 HTML 代码（保存为 .html 文件后直接在浏览器打开即可）：",
              "html_content": "<div class=\"wrap\">\n    <h1>重力球下落模拟</h1>\n    <p class=\"lead\">演示自由落体（恒定重力）与线性空气阻力的影响。可调初始高度、初速度、重力、质量和阻力系数。解析解仅在无阻力时与数值解一致。（资料来源：Perplexity AI）</p>\n\n    <div class=\"grid\">\n      <!-- 左侧：模拟画布与图表 -->\n      <div class=\"card\">\n        <div class=\"sim-area\">\n          <canvas id=\"scene\" aria-label=\"重力球下落模拟画布\"></canvas>\n\n          <div class=\"plot-row\">\n            <canvas id=\"posPlot\" class=\"plot\" aria-label=\"位置-时间图\"></canvas>\n            <canvas id=\"velPlot\" class=\"plot\" aria-label=\"速度-时间图\"></canvas>\n          </div>\n\n          <div class=\"readouts\">\n            <div class=\"readout\">时间 (s): <span id=\"tVal\">0.00</span></div>\n            <div class=\"readout\">高度 (m): <span id=\"yVal\">0.00</span></div>\n            <div class=\"readout\">速度 (m/s): <span id=\"vVal\">0.00</span></div>\n            <div class=\"readout\">加速度 (m/s²): <span id=\"aVal\">0.00</span></div>\n          </div>\n        </div>\n      </div>\n\n      <!-- 右侧：控制与参数 -->\n      <div class=\"card\">\n        <div style=\"display:flex;gap:10px;align-items:center;justify-content:space-between;\">\n          <div style=\"display:flex;flex-direction:column;\">\n            <strong>控制</strong>\n            <span class=\"small\">播放 / 暂停 / 重置 仿真</span>\n          </div>\n          <div style=\"display:flex;gap:8px;\">\n            <button id=\"playBtn\" class=\"btn\">播放</button>\n            <button id=\"pauseBtn\" class=\"btn\">暂停</button>\n            <button id=\"resetBtn\" class=\"btn\">重置</button>\n          </div>\n        </div>\n\n        <hr style=\"border:0;border-top:1px solid rgba(255,255,255,0.03);margin:10px 0;\">\n\n        <div>\n          <div style=\"display:flex;flex-direction:column;gap:8px;\">\n            <div class=\"control\">\n              <label for=\"hRange\">初始高度 h (m)</label>\n              <input id=\"hRange\" type=\"range\" min=\"0\" max=\"200\" step=\"1\" value=\"50\">\n              <div class=\"value\" id=\"hVal\">50</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"v0Range\">初速度 v0 (m/s)</label>\n              <input id=\"v0Range\" type=\"range\" min=\"-50\" max=\"50\" step=\"1\" value=\"0\">\n              <div class=\"value\" id=\"v0Val\">0</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"gRange\">重力 g (m/s²)</label>\n              <input id=\"gRange\" type=\"range\" min=\"0\" max=\"20\" step=\"0.01\" value=\"9.81\">\n              <div class=\"value\" id=\"gVal\">9.81</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"massRange\">质量 m (kg)</label>\n              <input id=\"massRange\" type=\"range\" min=\"0.1\" max=\"10\" step=\"0.1\" value=\"1\">\n              <div class=\"value\" id=\"massVal\">1.0</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"dragRange\">阻力系数 b (kg/s)</label>\n              <input id=\"dragRange\" type=\"range\" min=\"0\" max=\"5\" step=\"0.01\" value=\"0.00\">\n              <div class=\"value\" id=\"dragVal\">0.00</div>\n            </div>\n\n            <div class=\"control\">\n              <label for=\"timeScale\">时间缩放</label>\n              <input id=\"timeScale\" type=\"range\" min=\"0.1\" max=\"4\" step=\"0.1\" value=\"1\">\n              <div class=\"value\" id=\"timeScaleVal\">1.0x</div>\n            </div>\n\n            <div class=\"control toggle\">\n              <input id=\"dragToggle\" type=\"checkbox\" />\n              <label for=\"dragToggle\" style=\"min-width:0;\">启用空气阻力（线性）</label>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"small\" style=\"margin-top:12px;\">\n          使用说明：调整参数后可点击“重置”使球回到初始状态，点击播放开始仿真；当阻力关闭时，右侧图表会显示解析解（虚线）作为对比。\n        </div>\n      </div>\n    </div>\n\n    <footer>\n      注：解析公式（无阻力） y(t)=y0 + v0*t + 0.5*g*t²，v(t)=v0 + g*t。阻力模型：线性阻力 F_d = -b*v（向上若 v 向下为正）。\n    </footer>\n  </div>\n\n  <script>\n    // --- 常量与 DOM 元素 ---\n    const scene = document.getElementById('scene');\n    const posPlot = document.getElementById('posPlot');\n    const velPlot = document.getElementById('velPlot');\n    const ctx = scene.getContext('2d');\n    const ctxPos = posPlot.getContext('2d');\n    const ctxVel = velPlot.getContext('2d');\n\n    // Controls\n    const hRange = document.getElementById('hRange'), hVal = document.getElementById('hVal');\n    const v0Range = document.getElementById('v0Range'), v0Val = document.getElementById('v0Val');\n    const gRange = document.getElementById('gRange'), gVal = document.getElementById('gVal');\n    const massRange = document.getElementById('massRange'), massVal = document.getElementById('massVal');\n    const dragRange = document.getElementById('dragRange'), dragVal = document.getElementById('dragVal');\n    const timeScale = document.getElementById('timeScale'), timeScaleVal = document.getElementById('timeScaleVal');\n    const dragToggle = document.getElementById('dragToggle');\n    const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');\n\n    const tDisplay = document.getElementById('tVal'), yDisplay = document.getElementById('yVal'), vDisplay = document.getElementById('vVal'), aDisplay = document.getElementById('aVal');\n\n    // Canvas sizing helper\n    function resizeCanvases() {\n      const dpr = window.devicePixelRatio || 1;\n      // scene\n      const rect = scene.getBoundingClientRect();\n      scene.width = Math.round(rect.width * dpr);\n      scene.height = Math.round(rect.height * dpr);\n      ctx.setTransform(dpr,0,0,dpr,0,0);\n      // plots\n      const r1 = posPlot.getBoundingClientRect();\n      posPlot.width = Math.round(r1.width * dpr);\n      posPlot.height = Math.round(r1.height * dpr);\n      ctxPos.setTransform(dpr,0,0,dpr,0,0);\n\n      const r2 = velPlot.getBoundingClientRect();\n      velPlot.width = Math.round(r2.width * dpr);\n      velPlot.height = Math.round(r2.height * dpr);\n      ctxVel.setTransform(dpr,0,0,dpr,0,0);\n    }\n    window.addEventListener('resize', resizeCanvases);\n\n    // --- 物理与仿真状态 ---\n    let sim = {\n      running: false,\n      t: 0,\n      y: 0,   // 高度（m），向下为正； ground at y=0\n      v: 0,\n      a: 0,\n      params: {\n        h: parseFloat(hRange.value),\n        v0: parseFloat(v0Range.value),\n        g: parseFloat(gRange.value),\n        m: parseFloat(massRange.value),\n        b: parseFloat(dragRange.value),\n        dragOn: dragToggle.checked,\n        timeScale: parseFloat(timeScale.value)\n      },\n      history: { t:[], y:[], v:[] }\n    };\n\n    // initialize values display\n    function syncUI() {\n      hVal.textContent = Number(hRange.value).toFixed(0);\n      v0Val.textContent = Number(v0Range.value).toFixed(0);\n      gVal.textContent = Number(gRange.value).toFixed(2);\n      massVal.textContent = Number(massRange.value).toFixed(1);\n      dragVal.textContent = Number(dragRange.value).toFixed(2);\n      timeScaleVal.textContent = Number(timeScale.value).toFixed(1) + 'x';\n    }\n    syncUI();\n\n    // Update params from controls\n    function updateParams() {\n      sim.params.h = parseFloat(hRange.value);\n      sim.params.v0 = parseFloat(v0Range.value);\n      sim.params.g = parseFloat(gRange.value);\n      sim.params.m = parseFloat(massRange.value);\n      sim.params.b = parseFloat(dragRange.value);\n      sim.params.dragOn = dragToggle.checked;\n      sim.params.timeScale = parseFloat(timeScale.value);\n      syncUI();\n    }\n\n    // Reset simulation to initial state\n    function resetSim() {\n      updateParams();\n      sim.t = 0;\n      sim.y = sim.params.h; // height above ground in meters (we treat ground at y=0)\n      sim.v = sim.params.v0;\n      sim.a = sim.params.g; // initial a (approx)\n      sim.history.t = [0];\n      sim.history.y = [sim.y];\n      sim.history.v = [sim.v];\n      // clear plots\n      clearPlots();\n      drawScene();\n    }\n\n    // Numerical integration: semi-implicit Euler (velocity updated from acceleration, then position)\n    function stepSim(dtRealSeconds) {\n      const dt = dtRealSeconds * sim.params.timeScale;\n      const g = sim.params.g;\n      const m = sim.params.m;\n      const b = sim.params.b;\n      let a;\n      if (sim.params.dragOn && b > 0) {\n        // model: a = g - (b/m) * v, with v positive downward\n        a = g - (b/m) * sim.v;\n      } else {\n        a = g;\n      }\n      // semi-implicit Euler\n      sim.v += a * dt;\n      sim.y += sim.v * dt;\n      sim.t += dt;\n      sim.a = a;\n      sim.history.t.push(sim.t);\n      sim.history.y.push(sim.y);\n      sim.history.v.push(sim.v);\n    }\n\n    // Drawing utilities\n    function clearPlots() {\n      ctxPos.clearRect(0,0,posPlot.width,posPlot.height);\n      ctxVel.clearRect(0,0,velPlot.width,velPlot.height);\n      // draw axes lightly\n      drawAxes(ctxPos, posPlot, \"高度 (m)\");\n      drawAxes(ctxVel, velPlot, \"速度 (m/s)\");\n    }\n\n    function drawAxes(ctxP, canvasElem, label) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      ctxP.save();\n      ctxP.fillStyle = '#072033';\n      ctxP.fillRect(0,0,w,h);\n      ctxP.strokeStyle = 'rgba(255,255,255,0.03)';\n      ctxP.beginPath();\n      ctxP.moveTo(36,6);\n      ctxP.lineTo(36,h-18);\n      ctxP.lineTo(w-6,h-18);\n      ctxP.stroke();\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '12px sans-serif';\n      ctxP.fillText(label, 6, 12);\n      ctxP.restore();\n    }\n\n    function drawPlot(ctxP, canvasElem, dataX, dataY, color='#7dd3fc', dashed=false) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      const margin = { left:40, right:6, top:6, bottom:18 };\n      // compute ranges\n      const tMin = 0;\n      const tMax = Math.max(1, dataX[dataX.length-1]);\n      const yMin = Math.min(...dataY, 0);\n      const yMax = Math.max(...dataY, 1);\n      const pad = (yMax - yMin) * 0.12;\n      const Ymin = yMin - pad;\n      const Ymax = yMax + pad;\n\n      ctxP.save();\n      // background\n      ctxP.fillStyle = '#021028';\n      ctxP.fillRect(0,0,w,h);\n\n      // axes\n      ctxP.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctxP.beginPath();\n      ctxP.moveTo(margin.left, margin.top);\n      ctxP.lineTo(margin.left, h - margin.bottom);\n      ctxP.lineTo(w - margin.right, h - margin.bottom);\n      ctxP.stroke();\n\n      // plot data\n      ctxP.lineWidth = 2;\n      ctxP.strokeStyle = color;\n      if (dashed) ctxP.setLineDash([6,4]); else ctxP.setLineDash([]);\n      ctxP.beginPath();\n      for (let i=0;i<dataX.length;i++) {\n        const tx = dataX[i];\n        const val = dataY[i];\n        const x = margin.left + ((tx - tMin) / (tMax - tMin)) * (w - margin.left - margin.right);\n        const y = (h - margin.bottom) - ((val - Ymin) / (Ymax - Ymin)) * (h - margin.top - margin.bottom);\n        if (i===0) ctxP.moveTo(x,y); else ctxP.lineTo(x,y);\n      }\n      ctxP.stroke();\n\n      // labels\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText('t (s)', w - 40, h - 2);\n\n      // value ticks (min/max)\n      ctxP.fillStyle = '#94a3b8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText(Ymax.toFixed(2), 6, 14);\n      ctxP.fillText(Ymin.toFixed(2), 6, h - 22);\n\n      ctxP.restore();\n    }\n\n    function drawScene() {\n      // scene canvas: draw ground, scale and ball\n      ctx.clearRect(0,0,scene.width, scene.height);\n      const cw = scene.width / (window.devicePixelRatio || 1);\n      const ch = scene.height / (window.devicePixelRatio || 1);\n\n      // background gradient\n      const grad = ctx.createLinearGradient(0,0,0,ch);\n      grad.addColorStop(0, '#07112a');\n      grad.addColorStop(1, '#021027');\n      ctx.fillStyle = grad;\n      ctx.fillRect(0,0,cw,ch);\n\n      // Compute mapping: physical height in meters maps to pixel y\n      const maxH = Math.max(sim.params.h, 200); // at least 200m domain for good scale\n      const topMargin = 30;\n      const bottomMargin = 30;\n      const usable = ch - topMargin - bottomMargin;\n      // clamp max domain by some function to keep visible when very large\n      const domainH = Math.max(maxH, 1);\n      const pixelsPerMeter = usable / domainH;\n\n      // draw ground line\n      const groundY = topMargin + domainH * pixelsPerMeter;\n      ctx.fillStyle = '#17384f';\n      ctx.fillRect(0, groundY, cw, ch - groundY);\n\n      ctx.strokeStyle = '#2aa6ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(0, groundY + 0.5);\n      ctx.lineTo(cw, groundY + 0.5);\n      ctx.stroke();\n\n      // draw height ticks\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\n      ctx.font = '11px sans-serif';\n      for (let m=0; m <= domainH; m += Math.max(1, Math.floor(domainH/6))) {\n        const ypix = topMargin + m * pixelsPerMeter;\n        ctx.beginPath();\n        ctx.moveTo(6, ypix + 0.5);\n        ctx.lineTo(18, ypix + 0.5);\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        ctx.stroke();\n        ctx.fillStyle = '#9fbbe8';\n        ctx.fillText((domainH - m).toFixed(0) + ' m', 22, ypix + 4);\n      }\n\n      // draw analytical trajectory (if no drag)\n      if (!sim.params.dragOn) {\n        // sample times over a small horizon\n        const tMax = Math.max(1, sim.history.t[sim.history.t.length-1] + 1);\n        ctx.beginPath();\n        ctx.setLineDash([6,6]);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = 'rgba(255,200,80,0.6)';\n        for (let i=0;i<=60;i++) {\n          const tt = (i/60) * tMax;\n          const yAnal = sim.params.h + sim.params.v0 * tt + 0.5 * sim.params.g * tt * tt;\n          const yClamped = Math.min(yAnal, domainH);\n          const ypix = topMargin + yClamped * pixelsPerMeter;\n          const x = cw * 0.15 + (i/60) * (cw * 0.7);\n          if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n        }\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n\n      // draw trail from history\n      ctx.beginPath();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = 'rgba(96,165,250,0.9)';\n      for (let i=0;i<sim.history.y.length;i+=Math.max(1, Math.floor(sim.history.y.length/300))) {\n        const yv = Math.min(sim.history.y[i], domainH);\n        const x = cw * 0.15 + (i / Math.max(1, sim.history.y.length-1)) * (cw * 0.7);\n        const ypix = topMargin + yv * pixelsPerMeter;\n        if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n      }\n      ctx.stroke();\n\n      // draw ball current position\n      const ballX = cw * 0.15 + (sim.history.length ? (sim.history.y.length-1) / Math.max(1, sim.history.y.length-1) : 0) * (cw * 0.7);\n      const yPixBall = topMargin + Math.min(sim.y, domainH) * pixelsPerMeter;\n      const rpx = 12;\n      // shadow\n      ctx.beginPath();\n      ctx.ellipse(ballX + 6, groundY + 6, 18, 6, 0, 0, Math.PI*2);\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\n      ctx.fill();\n\n      // ball\n      const gradBall = ctx.createRadialGradient(ballX - 4, yPixBall - 6, 4, ballX, yPixBall, 18);\n      gradBall.addColorStop(0, '#9be7ff');\n      gradBall.addColorStop(1, '#1560a9');\n      ctx.fillStyle = gradBall;\n      ctx.beginPath();\n      ctx.arc(ballX, yPixBall, rpx, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n      ctx.stroke();\n\n      // textual info\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = '13px sans-serif';\n      ctx.fillText('高度 (m): ' + sim.y.toFixed(2), 12, 20);\n      ctx.fillText('速度 (m/s): ' + sim.v.toFixed(2), 12, 36);\n\n      // update numeric displays\n      tDisplay.textContent = sim.t.toFixed(2);\n      yDisplay.textContent = Math.max(0, (sim.params.h - (sim.params.h - sim.y))).toFixed(2); // just show sim.y\n      vDisplay.textContent = sim.v.toFixed(2);\n      aDisplay.textContent = sim.a.toFixed(2);\n    }\n\n    // --- Main loop ---\n    let lastFrameTime = null;\n    function frame(ts) {\n      if (!lastFrameTime) lastFrameTime = ts;\n      const dtMillis = ts - lastFrameTime;\n      lastFrameTime = ts;\n      const dtSec = dtMillis / 1000;\n\n      if (sim.running) {\n        // integrate in fixed small steps for stability\n        let remaining = dtSec;\n        const step = 0.016; // 16ms ~ 60Hz physics step\n        while (remaining > 1e-6) {\n          const d = Math.min(step, remaining);\n          stepSim(d);\n          remaining -= d;\n          // stop when hits ground\n          if (sim.y >= Math.max(sim.params.h, sim.y) && false) { /* placeholder */ }\n          // If ball hits ground (simulate bounce off ground? For now stop at ground)\n          if (sim.y >= 10000) {\n            // safety clamp for insane values\n            sim.y = 10000;\n            sim.v = 0;\n            sim.running = false;\n            break;\n          }\n          // Stop if y is below ground (we treat ground at y = large domain; instead we stop when actual y passes some threshold)\n          if (sim.y >= 1e9) {\n            sim.running = false;\n            break;\n          }\n        }\n      }\n\n      // stop running when ball goes beyond a \"ground\" defined as y very large compared to initial (we interpret ground at y = sim.params.h + some)\n      // For clearer behavior: if position exceeds domain we keep plotting but do not auto-stop.\n      drawScene();\n\n      // update plots\n      drawPlot(ctxPos, posPlot, sim.history.t, sim.history.y, '#7dd3fc', false);\n      drawPlot(ctxVel, velPlot, sim.history.t, sim.history.v, '#fda4af', false);\n\n      requestAnimationFrame(frame);\n    }\n\n    // --- Event listeners ---\n    playBtn.addEventListener('click', () => { sim.running = true; });\n    pauseBtn.addEventListener('click', () => { sim.running = false; });\n    resetBtn.addEventListener('click', () => { sim.running = false; resetSim(); });\n\n    [hRange, v0Range, gRange, massRange, dragRange, timeScale, dragToggle].forEach(el => {\n      el.addEventListener('input', () => {\n        updateParams();\n        // If simulation not running, reflect changes immediately in scene and reset initial position\n        if (!sim.running) {\n          resetSim();\n        } else {\n          // update params in flight\n          updateParams();\n        }\n      });\n    });\n\n    // initialize sizes and simulation\n    resizeCanvases();\n    resetSim();\n    requestAnimationFrame(frame);\n\n    // Accessibility: keyboard shortcuts\n    window.addEventListener('keydown', (e) => {\n      if (e.key === ' ') { sim.running = !sim.running; e.preventDefault(); }\n      if (e.key === 'r') { resetSim(); }\n      if (e.key === 'p') { sim.running = false; }\n    });\n\n    // Note: For stability and simplicity, we treat y as the \"distance fallen\" from initial height.\n    // If you want ground collision stop: you can check when sim.y >= sim.params.h (distance >= initial height) and then set running=false and v=0.\n    // Implement simple ground stop:\n    setInterval(() => {\n      // Stop when ball reaches or passes \"ground\" (distance fallen >= initial height)\n      if (sim.y >= sim.params.h) {\n        sim.y = sim.params.h;\n        if (sim.running) {\n          sim.running = false;\n        }\n        sim.v = 0;\n      }\n    }, 50);\n  </script>",
              "css_content": ":root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #60a5fa;\n      --muted: #94a3b8;\n      --glass: rgba(255,255,255,0.04);\n      --card-radius: 10px;\n    }\n    html,body { height:100%; margin:0; font-family: Inter, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: linear-gradient(180deg,#071029 0%, #0b1220 100%); color:#e6eef8; }\n    .wrap { max-width:1100px; margin:20px auto; padding:18px; }\n    h1 { margin:0 0 6px 0; font-size:20px; color:var(--accent); }\n    p.lead { margin:0 0 12px 0; color:var(--muted); font-size:13px; }\n    .grid { display:grid; grid-template-columns: 1fr 380px; gap:16px; align-items:start; }\n    .card {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: var(--card-radius);\n      padding:12px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n    .sim-area { height:520px; display:flex; flex-direction:column; gap:8px; }\n    canvas#scene { background: linear-gradient(180deg,#07112a,#081023); border-radius:8px; width:100%; height:330px; display:block; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n    .control { display:flex; gap:8px; align-items:center; }\n    label { font-size:13px; color:var(--muted); min-width:110px; }\n    input[type=\"range\"] { accent-color: var(--accent); }\n    .value { font-weight:600; color:#e6eef8; min-width:60px; text-align:right; font-size:13px; }\n    .btn { background:linear-gradient(180deg,#1e293b,#111827); color:#e6eef8; border-radius:8px; padding:8px 12px; border:1px solid rgba(255,255,255,0.04); cursor:pointer; }\n    .small { font-size:12px; color:var(--muted); margin-top:6px; }\n    .readouts { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; }\n    .readout { background:var(--glass); padding:8px 10px; border-radius:8px; min-width:120px; text-align:left; }\n    .plot-row { display:flex; gap:8px; margin-top:8px; }\n    canvas.plot { background: #021027; border-radius:6px; width:100%; height:110px; display:block; }\n    footer { margin-top:10px; color:var(--muted); font-size:12px; }\n    .toggle { display:flex; align-items:center; gap:8px; }\n    @media (max-width:1000px) {\n      .grid { grid-template-columns: 1fr; }\n      .sim-area { height:auto; }\n      canvas#scene { height:260px; }\n    }",
              "js_content": "// --- 常量与 DOM 元素 ---\n    const scene = document.getElementById('scene');\n    const posPlot = document.getElementById('posPlot');\n    const velPlot = document.getElementById('velPlot');\n    const ctx = scene.getContext('2d');\n    const ctxPos = posPlot.getContext('2d');\n    const ctxVel = velPlot.getContext('2d');\n\n    // Controls\n    const hRange = document.getElementById('hRange'), hVal = document.getElementById('hVal');\n    const v0Range = document.getElementById('v0Range'), v0Val = document.getElementById('v0Val');\n    const gRange = document.getElementById('gRange'), gVal = document.getElementById('gVal');\n    const massRange = document.getElementById('massRange'), massVal = document.getElementById('massVal');\n    const dragRange = document.getElementById('dragRange'), dragVal = document.getElementById('dragVal');\n    const timeScale = document.getElementById('timeScale'), timeScaleVal = document.getElementById('timeScaleVal');\n    const dragToggle = document.getElementById('dragToggle');\n    const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');\n\n    const tDisplay = document.getElementById('tVal'), yDisplay = document.getElementById('yVal'), vDisplay = document.getElementById('vVal'), aDisplay = document.getElementById('aVal');\n\n    // Canvas sizing helper\n    function resizeCanvases() {\n      const dpr = window.devicePixelRatio || 1;\n      // scene\n      const rect = scene.getBoundingClientRect();\n      scene.width = Math.round(rect.width * dpr);\n      scene.height = Math.round(rect.height * dpr);\n      ctx.setTransform(dpr,0,0,dpr,0,0);\n      // plots\n      const r1 = posPlot.getBoundingClientRect();\n      posPlot.width = Math.round(r1.width * dpr);\n      posPlot.height = Math.round(r1.height * dpr);\n      ctxPos.setTransform(dpr,0,0,dpr,0,0);\n\n      const r2 = velPlot.getBoundingClientRect();\n      velPlot.width = Math.round(r2.width * dpr);\n      velPlot.height = Math.round(r2.height * dpr);\n      ctxVel.setTransform(dpr,0,0,dpr,0,0);\n    }\n    window.addEventListener('resize', resizeCanvases);\n\n    // --- 物理与仿真状态 ---\n    let sim = {\n      running: false,\n      t: 0,\n      y: 0,   // 高度（m），向下为正； ground at y=0\n      v: 0,\n      a: 0,\n      params: {\n        h: parseFloat(hRange.value),\n        v0: parseFloat(v0Range.value),\n        g: parseFloat(gRange.value),\n        m: parseFloat(massRange.value),\n        b: parseFloat(dragRange.value),\n        dragOn: dragToggle.checked,\n        timeScale: parseFloat(timeScale.value)\n      },\n      history: { t:[], y:[], v:[] }\n    };\n\n    // initialize values display\n    function syncUI() {\n      hVal.textContent = Number(hRange.value).toFixed(0);\n      v0Val.textContent = Number(v0Range.value).toFixed(0);\n      gVal.textContent = Number(gRange.value).toFixed(2);\n      massVal.textContent = Number(massRange.value).toFixed(1);\n      dragVal.textContent = Number(dragRange.value).toFixed(2);\n      timeScaleVal.textContent = Number(timeScale.value).toFixed(1) + 'x';\n    }\n    syncUI();\n\n    // Update params from controls\n    function updateParams() {\n      sim.params.h = parseFloat(hRange.value);\n      sim.params.v0 = parseFloat(v0Range.value);\n      sim.params.g = parseFloat(gRange.value);\n      sim.params.m = parseFloat(massRange.value);\n      sim.params.b = parseFloat(dragRange.value);\n      sim.params.dragOn = dragToggle.checked;\n      sim.params.timeScale = parseFloat(timeScale.value);\n      syncUI();\n    }\n\n    // Reset simulation to initial state\n    function resetSim() {\n      updateParams();\n      sim.t = 0;\n      sim.y = sim.params.h; // height above ground in meters (we treat ground at y=0)\n      sim.v = sim.params.v0;\n      sim.a = sim.params.g; // initial a (approx)\n      sim.history.t = [0];\n      sim.history.y = [sim.y];\n      sim.history.v = [sim.v];\n      // clear plots\n      clearPlots();\n      drawScene();\n    }\n\n    // Numerical integration: semi-implicit Euler (velocity updated from acceleration, then position)\n    function stepSim(dtRealSeconds) {\n      const dt = dtRealSeconds * sim.params.timeScale;\n      const g = sim.params.g;\n      const m = sim.params.m;\n      const b = sim.params.b;\n      let a;\n      if (sim.params.dragOn && b > 0) {\n        // model: a = g - (b/m) * v, with v positive downward\n        a = g - (b/m) * sim.v;\n      } else {\n        a = g;\n      }\n      // semi-implicit Euler\n      sim.v += a * dt;\n      sim.y += sim.v * dt;\n      sim.t += dt;\n      sim.a = a;\n      sim.history.t.push(sim.t);\n      sim.history.y.push(sim.y);\n      sim.history.v.push(sim.v);\n    }\n\n    // Drawing utilities\n    function clearPlots() {\n      ctxPos.clearRect(0,0,posPlot.width,posPlot.height);\n      ctxVel.clearRect(0,0,velPlot.width,velPlot.height);\n      // draw axes lightly\n      drawAxes(ctxPos, posPlot, \"高度 (m)\");\n      drawAxes(ctxVel, velPlot, \"速度 (m/s)\");\n    }\n\n    function drawAxes(ctxP, canvasElem, label) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      ctxP.save();\n      ctxP.fillStyle = '#072033';\n      ctxP.fillRect(0,0,w,h);\n      ctxP.strokeStyle = 'rgba(255,255,255,0.03)';\n      ctxP.beginPath();\n      ctxP.moveTo(36,6);\n      ctxP.lineTo(36,h-18);\n      ctxP.lineTo(w-6,h-18);\n      ctxP.stroke();\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '12px sans-serif';\n      ctxP.fillText(label, 6, 12);\n      ctxP.restore();\n    }\n\n    function drawPlot(ctxP, canvasElem, dataX, dataY, color='#7dd3fc', dashed=false) {\n      const w = canvasElem.width / (window.devicePixelRatio || 1);\n      const h = canvasElem.height / (window.devicePixelRatio || 1);\n      const margin = { left:40, right:6, top:6, bottom:18 };\n      // compute ranges\n      const tMin = 0;\n      const tMax = Math.max(1, dataX[dataX.length-1]);\n      const yMin = Math.min(...dataY, 0);\n      const yMax = Math.max(...dataY, 1);\n      const pad = (yMax - yMin) * 0.12;\n      const Ymin = yMin - pad;\n      const Ymax = yMax + pad;\n\n      ctxP.save();\n      // background\n      ctxP.fillStyle = '#021028';\n      ctxP.fillRect(0,0,w,h);\n\n      // axes\n      ctxP.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctxP.beginPath();\n      ctxP.moveTo(margin.left, margin.top);\n      ctxP.lineTo(margin.left, h - margin.bottom);\n      ctxP.lineTo(w - margin.right, h - margin.bottom);\n      ctxP.stroke();\n\n      // plot data\n      ctxP.lineWidth = 2;\n      ctxP.strokeStyle = color;\n      if (dashed) ctxP.setLineDash([6,4]); else ctxP.setLineDash([]);\n      ctxP.beginPath();\n      for (let i=0;i<dataX.length;i++) {\n        const tx = dataX[i];\n        const val = dataY[i];\n        const x = margin.left + ((tx - tMin) / (tMax - tMin)) * (w - margin.left - margin.right);\n        const y = (h - margin.bottom) - ((val - Ymin) / (Ymax - Ymin)) * (h - margin.top - margin.bottom);\n        if (i===0) ctxP.moveTo(x,y); else ctxP.lineTo(x,y);\n      }\n      ctxP.stroke();\n\n      // labels\n      ctxP.fillStyle = '#9fbbe8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText('t (s)', w - 40, h - 2);\n\n      // value ticks (min/max)\n      ctxP.fillStyle = '#94a3b8';\n      ctxP.font = '11px sans-serif';\n      ctxP.fillText(Ymax.toFixed(2), 6, 14);\n      ctxP.fillText(Ymin.toFixed(2), 6, h - 22);\n\n      ctxP.restore();\n    }\n\n    function drawScene() {\n      // scene canvas: draw ground, scale and ball\n      ctx.clearRect(0,0,scene.width, scene.height);\n      const cw = scene.width / (window.devicePixelRatio || 1);\n      const ch = scene.height / (window.devicePixelRatio || 1);\n\n      // background gradient\n      const grad = ctx.createLinearGradient(0,0,0,ch);\n      grad.addColorStop(0, '#07112a');\n      grad.addColorStop(1, '#021027');\n      ctx.fillStyle = grad;\n      ctx.fillRect(0,0,cw,ch);\n\n      // Compute mapping: physical height in meters maps to pixel y\n      const maxH = Math.max(sim.params.h, 200); // at least 200m domain for good scale\n      const topMargin = 30;\n      const bottomMargin = 30;\n      const usable = ch - topMargin - bottomMargin;\n      // clamp max domain by some function to keep visible when very large\n      const domainH = Math.max(maxH, 1);\n      const pixelsPerMeter = usable / domainH;\n\n      // draw ground line\n      const groundY = topMargin + domainH * pixelsPerMeter;\n      ctx.fillStyle = '#17384f';\n      ctx.fillRect(0, groundY, cw, ch - groundY);\n\n      ctx.strokeStyle = '#2aa6ff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(0, groundY + 0.5);\n      ctx.lineTo(cw, groundY + 0.5);\n      ctx.stroke();\n\n      // draw height ticks\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\n      ctx.font = '11px sans-serif';\n      for (let m=0; m <= domainH; m += Math.max(1, Math.floor(domainH/6))) {\n        const ypix = topMargin + m * pixelsPerMeter;\n        ctx.beginPath();\n        ctx.moveTo(6, ypix + 0.5);\n        ctx.lineTo(18, ypix + 0.5);\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        ctx.stroke();\n        ctx.fillStyle = '#9fbbe8';\n        ctx.fillText((domainH - m).toFixed(0) + ' m', 22, ypix + 4);\n      }\n\n      // draw analytical trajectory (if no drag)\n      if (!sim.params.dragOn) {\n        // sample times over a small horizon\n        const tMax = Math.max(1, sim.history.t[sim.history.t.length-1] + 1);\n        ctx.beginPath();\n        ctx.setLineDash([6,6]);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = 'rgba(255,200,80,0.6)';\n        for (let i=0;i<=60;i++) {\n          const tt = (i/60) * tMax;\n          const yAnal = sim.params.h + sim.params.v0 * tt + 0.5 * sim.params.g * tt * tt;\n          const yClamped = Math.min(yAnal, domainH);\n          const ypix = topMargin + yClamped * pixelsPerMeter;\n          const x = cw * 0.15 + (i/60) * (cw * 0.7);\n          if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n        }\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n\n      // draw trail from history\n      ctx.beginPath();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = 'rgba(96,165,250,0.9)';\n      for (let i=0;i<sim.history.y.length;i+=Math.max(1, Math.floor(sim.history.y.length/300))) {\n        const yv = Math.min(sim.history.y[i], domainH);\n        const x = cw * 0.15 + (i / Math.max(1, sim.history.y.length-1)) * (cw * 0.7);\n        const ypix = topMargin + yv * pixelsPerMeter;\n        if (i===0) ctx.moveTo(x, ypix); else ctx.lineTo(x, ypix);\n      }\n      ctx.stroke();\n\n      // draw ball current position\n      const ballX = cw * 0.15 + (sim.history.length ? (sim.history.y.length-1) / Math.max(1, sim.history.y.length-1) : 0) * (cw * 0.7);\n      const yPixBall = topMargin + Math.min(sim.y, domainH) * pixelsPerMeter;\n      const rpx = 12;\n      // shadow\n      ctx.beginPath();\n      ctx.ellipse(ballX + 6, groundY + 6, 18, 6, 0, 0, Math.PI*2);\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\n      ctx.fill();\n\n      // ball\n      const gradBall = ctx.createRadialGradient(ballX - 4, yPixBall - 6, 4, ballX, yPixBall, 18);\n      gradBall.addColorStop(0, '#9be7ff');\n      gradBall.addColorStop(1, '#1560a9');\n      ctx.fillStyle = gradBall;\n      ctx.beginPath();\n      ctx.arc(ballX, yPixBall, rpx, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n      ctx.stroke();\n\n      // textual info\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = '13px sans-serif';\n      ctx.fillText('高度 (m): ' + sim.y.toFixed(2), 12, 20);\n      ctx.fillText('速度 (m/s): ' + sim.v.toFixed(2), 12, 36);\n\n      // update numeric displays\n      tDisplay.textContent = sim.t.toFixed(2);\n      yDisplay.textContent = Math.max(0, (sim.params.h - (sim.params.h - sim.y))).toFixed(2); // just show sim.y\n      vDisplay.textContent = sim.v.toFixed(2);\n      aDisplay.textContent = sim.a.toFixed(2);\n    }\n\n    // --- Main loop ---\n    let lastFrameTime = null;\n    function frame(ts) {\n      if (!lastFrameTime) lastFrameTime = ts;\n      const dtMillis = ts - lastFrameTime;\n      lastFrameTime = ts;\n      const dtSec = dtMillis / 1000;\n\n      if (sim.running) {\n        // integrate in fixed small steps for stability\n        let remaining = dtSec;\n        const step = 0.016; // 16ms ~ 60Hz physics step\n        while (remaining > 1e-6) {\n          const d = Math.min(step, remaining);\n          stepSim(d);\n          remaining -= d;\n          // stop when hits ground\n          if (sim.y >= Math.max(sim.params.h, sim.y) && false) { /* placeholder */ }\n          // If ball hits ground (simulate bounce off ground? For now stop at ground)\n          if (sim.y >= 10000) {\n            // safety clamp for insane values\n            sim.y = 10000;\n            sim.v = 0;\n            sim.running = false;\n            break;\n          }\n          // Stop if y is below ground (we treat ground at y = large domain; instead we stop when actual y passes some threshold)\n          if (sim.y >= 1e9) {\n            sim.running = false;\n            break;\n          }\n        }\n      }\n\n      // stop running when ball goes beyond a \"ground\" defined as y very large compared to initial (we interpret ground at y = sim.params.h + some)\n      // For clearer behavior: if position exceeds domain we keep plotting but do not auto-stop.\n      drawScene();\n\n      // update plots\n      drawPlot(ctxPos, posPlot, sim.history.t, sim.history.y, '#7dd3fc', false);\n      drawPlot(ctxVel, velPlot, sim.history.t, sim.history.v, '#fda4af', false);\n\n      requestAnimationFrame(frame);\n    }\n\n    // --- Event listeners ---\n    playBtn.addEventListener('click', () => { sim.running = true; });\n    pauseBtn.addEventListener('click', () => { sim.running = false; });\n    resetBtn.addEventListener('click', () => { sim.running = false; resetSim(); });\n\n    [hRange, v0Range, gRange, massRange, dragRange, timeScale, dragToggle].forEach(el => {\n      el.addEventListener('input', () => {\n        updateParams();\n        // If simulation not running, reflect changes immediately in scene and reset initial position\n        if (!sim.running) {\n          resetSim();\n        } else {\n          // update params in flight\n          updateParams();\n        }\n      });\n    });\n\n    // initialize sizes and simulation\n    resizeCanvases();\n    resetSim();\n    requestAnimationFrame(frame);\n\n    // Accessibility: keyboard shortcuts\n    window.addEventListener('keydown', (e) => {\n      if (e.key === ' ') { sim.running = !sim.running; e.preventDefault(); }\n      if (e.key === 'r') { resetSim(); }\n      if (e.key === 'p') { sim.running = false; }\n    });\n\n    // Note: For stability and simplicity, we treat y as the \"distance fallen\" from initial height.\n    // If you want ground collision stop: you can check when sim.y >= sim.params.h (distance >= initial height) and then set running=false and v=0.\n    // Implement simple ground stop:\n    setInterval(() => {\n      // Stop when ball reaches or passes \"ground\" (distance fallen >= initial height)\n      if (sim.y >= sim.params.h) {\n        sim.y = sim.params.h;\n        if (sim.running) {\n          sim.running = false;\n        }\n        sim.v = 0;\n      }\n    }, 50);",
              "parameters": [],
              "status": "success"
            },
            "attempts": 1
          }
        },
        {
          "stage": "quality_check",
          "timestamp": "2025-08-09T13:09:00.908Z",
          "checks": {
            "hasCode": false,
            "codeLength": 0,
            "htmlTagsFound": [],
            "syntaxErrors": [],
            "bracketMatching": true,
            "syntaxValid": true
          }
        }
      ],
      "finalResult": {
        "codeGenerated": false,
        "codeLength": 0,
        "hasQualityIssues": false,
        "issues": {
          "htmlTags": 0,
          "bracketErrors": false,
          "syntaxErrors": false
        }
      },
      "success": true,
      "errors": [],
      "endTime": "2025-08-09T13:09:00.908Z",
      "duration": 85110
    },
    {
      "name": "复杂交互系统",
      "prompt": "创建一个包含多个交互元素的复杂系统，包括按钮、滑块和动画效果",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T13:09:05.910Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T13:10:16.959Z",
          "response": {
            "status": 200,
            "statusText": "OK",
            "headers": {
              "access-control-allow-origin": "*",
              "connection": "keep-alive",
              "content-length": "35134",
              "content-type": "application/json; charset=utf-8",
              "date": "Sat, 09 Aug 2025 13:10:16 GMT",
              "etag": "W/\"893e-XCy79RKcrGHJ94i3gmjwkixWW1I\"",
              "keep-alive": "timeout=5",
              "x-powered-by": "Express"
            },
            "data": {
              "success": true,
              "data": {
                "experiment_id": "df88de10-d212-4ccc-9d06-ad35cef1c6d8",
                "title": "交互式系统演示：粒子动画 + 按钮与滑块",
                "description": "摘要（来自 Perplexity 的信息）：\n- 创建包含多个交互元素（按钮、滑块、动画效果）的复杂系统是一个多学科的话题，涉及用户交互、实时渲染和可视化设计。该领域注重交互控制、性能与可访问性（来源：Perplexity AI 研究）。\n- 本演示将把这些要素组合在一起，提供可调参数、动画、可视化反馈与交互控件，便于演示实时系统如何对输入响应（来源：Perplexity AI 研究）。\n\n下面是完整的自包含 HTML 文件。将其保存为 .html 并在浏览器中打开即可运行。代码中包含使用说明、注释与可访问性标签。",
                "html_content": "<div class=\"container\" role=\"main\" aria-label=\"Interactive particle system demo\">\n    <aside class=\"controls\" aria-label=\"Controls panel\">\n      <div>\n        <div class=\"title\">交互式粒子系统演示</div>\n        <div class=\"subtitle\">使用按钮、滑块与点击交互，实时调整与观察动画效果</div>\n      </div>\n\n      <div class=\"panel group\" aria-hidden=\"false\">\n        <div class=\"row\" style=\"justify-content:space-between; align-items:center;\">\n          <div class=\"stat\">状态: <span id=\"status\">运行中</span></div>\n          <div class=\"stat\">FPS: <span id=\"fps\">0</span></div>\n        </div>\n\n        <div>\n          <label for=\"count\">粒子数量: <span id=\"countVal\">200</span></label>\n          <input id=\"count\" type=\"range\" min=\"10\" max=\"800\" step=\"1\" value=\"200\" aria-label=\"粒子数量滑块\">\n        </div>\n\n        <div>\n          <label for=\"speed\">速度倍率: <span id=\"speedVal\">1.0</span></label>\n          <input id=\"speed\" type=\"range\" min=\"0.1\" max=\"4\" step=\"0.05\" value=\"1\" aria-label=\"速度倍率滑块\">\n        </div>\n\n        <div>\n          <label for=\"gravity\">全局重力 (y): <span id=\"gravVal\">0.00</span></label>\n          <input id=\"gravity\" type=\"range\" min=\"-1\" max=\"1\" step=\"0.01\" value=\"0\" aria-label=\"重力滑块\">\n        </div>\n\n        <div>\n          <label for=\"size\">粒子大小: <span id=\"sizeVal\">3</span></label>\n          <input id=\"size\" type=\"range\" min=\"1\" max=\"8\" step=\"0.5\" value=\"3\" aria-label=\"粒子大小滑块\">\n        </div>\n\n        <div>\n          <label for=\"hue\">色相 (色彩风格): <span id=\"hueVal\">200</span></label>\n          <input id=\"hue\" type=\"range\" min=\"0\" max=\"360\" step=\"1\" value=\"200\" aria-label=\"色相滑块\">\n        </div>\n\n        <div class=\"control-grid\">\n          <div>\n            <label for=\"repelRadius\">斥力半径: <span id=\"repelVal\">60</span></label>\n            <input id=\"repelRadius\" type=\"range\" min=\"10\" max=\"300\" step=\"1\" value=\"60\" aria-label=\"斥力半径滑块\">\n          </div>\n          <div>\n            <label for=\"trailAlpha\">轨迹透明度: <span id=\"trailVal\">0.12</span></label>\n            <input id=\"trailAlpha\" type=\"range\" min=\"0\" max=\"0.5\" step=\"0.01\" value=\"0.12\" aria-label=\"轨迹透明度滑块\">\n          </div>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between; margin-top:6px;\">\n          <button id=\"startBtn\" class=\"btn\" aria-pressed=\"true\">暂停</button>\n          <button id=\"stepBtn\" class=\"btn\">单帧</button>\n          <button id=\"resetBtn\" class=\"btn\">重置</button>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <button id=\"randomBtn\" class=\"btn\">随机参数</button>\n          <button id=\"trailToggle\" class=\"btn\">切换轨迹</button>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <div class=\"small\">点击画布以放置吸引点/排斥点</div>\n          <div class=\"toggle\">\n            <button id=\"modeAttract\" class=\"btn chip\" aria-pressed=\"true\"><span class=\"attractor attract\" aria-hidden=\"true\"></span> 吸引</button>\n            <button id=\"modeRepel\" class=\"btn chip\" aria-pressed=\"false\"><span class=\"attractor repel\" aria-hidden=\"true\"></span> 排斥</button>\n          </div>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <div class=\"stat\">能量: <span id=\"energy\">0</span></div>\n          <div class=\"stat\">粒子: <span id=\"particleCount\">0</span></div>\n        </div>\n\n        <footer class=\"instructions\">\n          说明：使用滑块调整系统参数。点击“吸引/排斥”选择模式，然后点击画布放置控制点。可切换轨迹以查看运动路径。\n        </footer>\n      </div>\n    </aside>\n\n    <main class=\"canvas-wrap\" aria-label=\"Canvas area\">\n      <canvas id=\"canvas\" width=\"1200\" height=\"760\" role=\"img\" aria-label=\"粒子动画画布\"></canvas>\n    </main>\n  </div>\n\n  <script>\n  /*\n    交互式粒子系统演示\n    - 粒子受吸引/排斥点影响\n    - 支持：开始/暂停、单帧、重置、随机化、轨迹开关\n    - 滑块控制粒子数量、速度、重力、大小、色相、斥力半径、轨迹透明度\n    - 点击画布：放置吸引或排斥点（取决于当前模式）\n  */\n\n  // --- DOM references ---\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d', { alpha: true });\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const trailToggle = document.getElementById('trailToggle');\n  const modeAttract = document.getElementById('modeAttract');\n  const modeRepel = document.getElementById('modeRepel');\n\n  const countSlider = document.getElementById('count');\n  const speedSlider = document.getElementById('speed');\n  const gravitySlider = document.getElementById('gravity');\n  const sizeSlider = document.getElementById('size');\n  const hueSlider = document.getElementById('hue');\n  const repelRadiusSlider = document.getElementById('repelRadius');\n  const trailAlphaSlider = document.getElementById('trailAlpha');\n\n  const countVal = document.getElementById('countVal');\n  const speedVal = document.getElementById('speedVal');\n  const gravVal = document.getElementById('gravVal');\n  const sizeVal = document.getElementById('sizeVal');\n  const hueVal = document.getElementById('hueVal');\n  const repelVal = document.getElementById('repelVal');\n  const trailVal = document.getElementById('trailVal');\n\n  const statusLabel = document.getElementById('status');\n  const fpsLabel = document.getElementById('fps');\n  const energyLabel = document.getElementById('energy');\n  const particleCountLabel = document.getElementById('particleCount');\n\n  // --- Canvas sizing ---\n  function fitCanvas(){\n    // set canvas internal resolution for crisp rendering\n    const rect = canvas.getBoundingClientRect();\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n  window.addEventListener('resize', fitCanvas);\n  // initial fit after DOM layout\n  setTimeout(fitCanvas, 50);\n\n  // --- Simulation state ---\n  let particles = [];\n  let attractors = []; // {x, y, strength, type} type: 'attract' or 'repel'\n  let running = true;\n  let trailEnabled = true;\n  let stepOnce = false;\n\n  // Settings (linked to sliders)\n  const settings = {\n    count: parseInt(countSlider.value),\n    speed: parseFloat(speedSlider.value),\n    gravity: parseFloat(gravitySlider.value),\n    size: parseFloat(sizeSlider.value),\n    hue: parseInt(hueSlider.value),\n    repelRadius: parseFloat(repelRadiusSlider.value),\n    trailAlpha: parseFloat(trailAlphaSlider.value)\n  };\n\n  // --- Utility functions ---\n  function rand(min, max){ return Math.random() * (max - min) + min; }\n  function dist2(a,b,c,d){ const dx = a-c, dy = b-d; return dx*dx + dy*dy; }\n\n  // --- Particle class-like objects ---\n  function createParticle(x, y){\n    const angle = Math.random() * Math.PI * 2;\n    const speed = Math.random() * 0.6 + 0.1;\n    return {\n      x: x !== undefined ? x : rand(0, canvas.width / (window.devicePixelRatio||1)),\n      y: y !== undefined ? y : rand(0, canvas.height / (window.devicePixelRatio||1)),\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: settings.size,\n      hue: settings.hue\n    };\n  }\n\n  function resetParticles(count){\n    particles = [];\n    for(let i=0;i<count;i++) particles.push(createParticle());\n    updateParticleCountLabel();\n  }\n\n  // --- Attractor handling ---\n  function addAttractor(x, y, type = 'attract'){\n    const strength = (type === 'attract') ? 3000 : -3000;\n    attractors.push({x,y,strength,type});\n  }\n\n  // --- Simulation update ---\n  function update(dt){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // compute global energy for display\n    let energy = 0;\n\n    for(let p of particles){\n      // global gravity\n      p.vy += settings.gravity * dt;\n\n      // apply attractors/repulsors\n      for(let a of attractors){\n        const dx = a.x - p.x;\n        const dy = a.y - p.y;\n        const d2 = dx*dx + dy*dy;\n        const minR = 10;\n        const r = Math.sqrt(d2) + 0.0001;\n        const radius = settings.repelRadius;\n        // influence reduces with distance (inverse-square-like under cap)\n        const influence = Math.max(0, 1 - (r / radius));\n        if (influence > 0){\n          // force magnitude\n          const force = (a.strength / (d2 + 100)) * influence * settings.speed;\n          p.vx += (dx / r) * force * dt;\n          p.vy += (dy / r) * force * dt;\n        }\n      }\n\n      // velocity damping for stability\n      p.vx *= 0.999;\n      p.vy *= 0.999;\n\n      // integrate\n      p.x += p.vx * settings.speed * dt;\n      p.y += p.vy * settings.speed * dt;\n\n      // wrapping boundaries\n      if(p.x < -20) p.x = w + 20;\n      if(p.x > w + 20) p.x = -20;\n      if(p.y < -20) p.y = h + 20;\n      if(p.y > h + 20) p.y = -20;\n\n      energy += (p.vx*p.vx + p.vy*p.vy) * 0.5;\n    }\n\n    energyLabel.textContent = energy.toFixed(1);\n  }\n\n  // --- Rendering ---\n  function render(){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // trail effect: fill with translucent rect to fade previous frames\n    if(trailEnabled){\n      ctx.fillStyle = `rgba(6,11,20,${settings.trailAlpha})`;\n      ctx.fillRect(0,0,w,h);\n    } else {\n      // clear fully\n      ctx.clearRect(0,0,w,h);\n      // draw subtle background\n      ctx.fillStyle = 'rgba(6,11,20,1)';\n      ctx.fillRect(0,0,w,h);\n    }\n\n    // draw attractors\n    for(let a of attractors){\n      const radius = 10 + Math.min(80, Math.abs(a.strength)/50);\n      ctx.beginPath();\n      const grad = ctx.createRadialGradient(a.x-2, a.y-2, 1, a.x, a.y, radius);\n      if(a.type === 'attract'){\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(34,193,195,0.8)');\n        grad.addColorStop(1,'rgba(10,152,160,0.25)');\n      } else {\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(255,122,122,0.85)');\n        grad.addColorStop(1,'rgba(255,74,74,0.18)');\n      }\n      ctx.fillStyle = grad;\n      ctx.arc(a.x, a.y, radius, 0, Math.PI*2);\n      ctx.fill();\n\n      // ring showing influence radius\n      ctx.strokeStyle = (a.type === 'attract') ? 'rgba(34,193,195,0.25)' : 'rgba(255,122,122,0.22)';\n      ctx.lineWidth = 1.2;\n      ctx.beginPath();\n      ctx.arc(a.x, a.y, settings.repelRadius, 0, Math.PI*2);\n      ctx.stroke();\n    }\n\n    // draw particles\n    for(let p of particles){\n      // color based on velocity/hue\n      const speed = Math.min(1.5, Math.sqrt(p.vx*p.vx + p.vy*p.vy));\n      const sat = 60 + Math.round(speed*40);\n      const light = 45 + Math.round(speed*8);\n      ctx.fillStyle = `hsl(${settings.hue}, ${sat}%, ${light}%)`;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, settings.size, 0, Math.PI*2);\n      ctx.fill();\n    }\n  }\n\n  // --- Main loop with FPS measurement ---\n  let last = performance.now();\n  let accum = 0;\n  let frames = 0;\n  let fpsTimer = performance.now();\n  let fps = 0;\n\n  function animate(now){\n    const dt = Math.min(40, now - last);\n    last = now;\n    // dt in ms -> convert to seconds for physics stability\n    const dtSec = dt / 16.6667; // normalized so 1 equals approx 60fps\n\n    if(running || stepOnce){\n      update(dtSec);\n      render();\n      stepOnce = false;\n    }\n\n    frames++;\n    if(now - fpsTimer > 500){\n      fps = Math.round((frames * 1000) / (now - fpsTimer));\n      fpsLabel.textContent = fps;\n      frames = 0;\n      fpsTimer = now;\n    }\n\n    requestAnimationFrame(animate);\n  }\n\n  // --- UI wiring ---\n  function updateSettingsFromUI(){\n    settings.count = parseInt(countSlider.value);\n    settings.speed = parseFloat(speedSlider.value);\n    settings.gravity = parseFloat(gravitySlider.value);\n    settings.size = parseFloat(sizeSlider.value);\n    settings.hue = parseInt(hueSlider.value);\n    settings.repelRadius = parseFloat(repelRadiusSlider.value);\n    settings.trailAlpha = parseFloat(trailAlphaSlider.value);\n\n    countVal.textContent = settings.count;\n    speedVal.textContent = settings.speed.toFixed(2);\n    gravVal.textContent = settings.gravity.toFixed(2);\n    sizeVal.textContent = settings.size;\n    hueVal.textContent = settings.hue;\n    repelVal.textContent = settings.repelRadius;\n    trailVal.textContent = settings.trailAlpha;\n  }\n\n  // update labels on initial load\n  updateSettingsFromUI();\n\n  // event listeners for sliders\n  [countSlider, speedSlider, gravitySlider, sizeSlider, hueSlider, repelRadiusSlider, trailAlphaSlider].forEach(input=>{\n    input.addEventListener('input', e=>{\n      updateSettingsFromUI();\n      // re-create particles if count changed significantly\n      const desired = settings.count;\n      if(particles.length < desired){\n        const add = desired - particles.length;\n        for(let i=0;i<add;i++) particles.push(createParticle());\n      } else if(particles.length > desired){\n        particles.length = desired;\n      }\n      updateParticleCountLabel();\n    });\n  });\n\n  function updateParticleCountLabel(){\n    particleCountLabel.textContent = particles.length;\n    countVal.textContent = settings.count;\n  }\n\n  // buttons\n  startBtn.addEventListener('click', ()=>{\n    running = !running;\n    startBtn.textContent = running ? '暂停' : '运行';\n    startBtn.setAttribute('aria-pressed', running ? 'true' : 'false');\n    statusLabel.textContent = running ? '运行中' : '已暂停';\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(!running){\n      stepOnce = true;\n    } else {\n      // when running, allow a single extra step (no-op)\n    }\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    attractors = [];\n    resetParticles(settings.count);\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    // randomize some sliders\n    countSlider.value = Math.floor(rand(50, 500));\n    speedSlider.value = (rand(0.3, 2.5)).toFixed(2);\n    gravitySlider.value = (rand(-0.2, 0.6)).toFixed(2);\n    sizeSlider.value = (rand(1.5, 6)).toFixed(1);\n    hueSlider.value = Math.floor(rand(0, 360));\n    repelRadiusSlider.value = Math.floor(rand(40, 220));\n    trailAlphaSlider.value = (rand(0,0.25)).toFixed(2);\n    updateSettingsFromUI();\n    resetParticles(settings.count);\n  });\n\n  trailToggle.addEventListener('click', ()=>{\n    trailEnabled = !trailEnabled;\n    trailToggle.textContent = trailEnabled ? '切换轨迹' : '切换轨迹';\n    // Update visual feedback: change background fill immediately on toggle\n    if(!trailEnabled){\n      // clear fully\n      const w = canvas.width / (window.devicePixelRatio||1);\n      const h = canvas.height / (window.devicePixelRatio||1);\n      ctx.clearRect(0,0,w,h);\n    }\n  });\n\n  // attract/repel mode toggle\n  modeAttract.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','true');\n    modeRepel.setAttribute('aria-pressed','false');\n  });\n  modeRepel.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','false');\n    modeRepel.setAttribute('aria-pressed','true');\n  });\n\n  // canvas click to place attractor/repulsor\n  canvas.addEventListener('click', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    // map mouse to canvas coordinate (CSS pixels)\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const type = (modeRepel.getAttribute('aria-pressed') === 'true') ? 'repel' : 'attract';\n    addAttractor(x, y, type);\n  });\n\n  // double-click removes nearest attractor\n  canvas.addEventListener('dblclick', (e)=>{\n    if(attractors.length === 0) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    let nearestIdx = -1;\n    let nearestDist = Infinity;\n    for(let i=0;i<attractors.length;i++){\n      const a = attractors[i];\n      const d = (a.x - x) * (a.x - x) + (a.y - y) * (a.y - y);\n      if(d < nearestDist){ nearestDist = d; nearestIdx = i; }\n    }\n    if(nearestIdx >= 0) attractors.splice(nearestIdx, 1);\n  });\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      startBtn.click();\n    } else if(e.key === 'r'){\n      randomBtn.click();\n    } else if(e.key === 't'){\n      trailToggle.click();\n    }\n  });\n\n  // initialization\n  resetParticles(settings.count);\n\n  // ensure canvas fits and animate\n  fitCanvas();\n  requestAnimationFrame(animate);\n\n  // Accessibility: give focus outline on keyboard navigation for buttons\n  const allBtns = document.querySelectorAll('.btn, .chip');\n  allBtns.forEach(b=>{\n    b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') b.click(); });\n  });\n\n  </script>",
                "css_content": "/* 基础布局 */\n    :root{\n      --bg: #0f1720;\n      --panel: #0b1220;\n      --accent: #22c1c3;\n      --muted: #94a3b8;\n      --card: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,#061021 0%, #0b1220 100%); color:#e6eef8; display:flex; align-items:stretch; gap:18px; padding:18px;}\n    .container{display:flex; flex:1; gap:18px; min-height:400px;}\n    .controls{\n      width:360px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px; padding:14px; box-shadow: 0 6px 24px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.04);\n      display:flex; flex-direction:column; gap:12px;\n    }\n    .title{font-size:18px; font-weight:600; color:var(--accent);}\n    .subtitle{font-size:12px; color:var(--muted); margin-bottom:6px;}\n    .canvas-wrap{\n      flex:1; border-radius:12px; overflow:hidden; background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.15));\n      display:flex; flex-direction:column;\n    }\n    canvas{width:100%; height:100%; display:block; background:transparent;}\n    .panel {\n      background:var(--card); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:8px;\n    }\n    label{font-size:13px; color:#dbe9f5;}\n    input[type=\"range\"]{width:100%;}\n    .row{display:flex; gap:8px; align-items:center;}\n    .btn {\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      color:#e6eef8; padding:8px 12px; border-radius:8px; cursor:pointer;\n      transition:transform .12s ease, box-shadow .12s ease;\n      display:inline-flex; align-items:center; gap:8px;\n    }\n    .btn:active{transform:translateY(1px) scale(.996);}\n    .controls .group{display:flex; flex-direction:column; gap:8px;}\n    .stat{font-size:13px; color:var(--muted);}\n    .small{font-size:12px;color:var(--muted);}\n    .control-grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px;}\n    .toggle{display:inline-flex; align-items:center; gap:8px;}\n    .chip{background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:6px; font-size:13px;}\n    footer.instructions{font-size:12px; color:var(--muted); padding-top:6px;}\n\n    /* attractor icons */\n    .attractor { width:18px; height:18px; border-radius:50%; display:inline-block; }\n    .attract { background: radial-gradient(circle at 30% 30%, #fff, #22c1c3 40%, #0a98a0 100%);}\n    .repel { background: radial-gradient(circle at 30% 30%, #fff, #ff7a7a 40%, #ff4a4a 100%);}\n\n    /* simple responsive */\n    @media (max-width:920px){\n      body{padding:12px;}\n      .controls{width:320px;}\n    }\n    @media (max-width:720px){\n      body{flex-direction:column;}\n      .container{flex-direction:column;}\n      .controls{width:auto;}\n    }",
                "js_content": "/*\n    交互式粒子系统演示\n    - 粒子受吸引/排斥点影响\n    - 支持：开始/暂停、单帧、重置、随机化、轨迹开关\n    - 滑块控制粒子数量、速度、重力、大小、色相、斥力半径、轨迹透明度\n    - 点击画布：放置吸引或排斥点（取决于当前模式）\n  */\n\n  // --- DOM references ---\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d', { alpha: true });\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const trailToggle = document.getElementById('trailToggle');\n  const modeAttract = document.getElementById('modeAttract');\n  const modeRepel = document.getElementById('modeRepel');\n\n  const countSlider = document.getElementById('count');\n  const speedSlider = document.getElementById('speed');\n  const gravitySlider = document.getElementById('gravity');\n  const sizeSlider = document.getElementById('size');\n  const hueSlider = document.getElementById('hue');\n  const repelRadiusSlider = document.getElementById('repelRadius');\n  const trailAlphaSlider = document.getElementById('trailAlpha');\n\n  const countVal = document.getElementById('countVal');\n  const speedVal = document.getElementById('speedVal');\n  const gravVal = document.getElementById('gravVal');\n  const sizeVal = document.getElementById('sizeVal');\n  const hueVal = document.getElementById('hueVal');\n  const repelVal = document.getElementById('repelVal');\n  const trailVal = document.getElementById('trailVal');\n\n  const statusLabel = document.getElementById('status');\n  const fpsLabel = document.getElementById('fps');\n  const energyLabel = document.getElementById('energy');\n  const particleCountLabel = document.getElementById('particleCount');\n\n  // --- Canvas sizing ---\n  function fitCanvas(){\n    // set canvas internal resolution for crisp rendering\n    const rect = canvas.getBoundingClientRect();\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n  window.addEventListener('resize', fitCanvas);\n  // initial fit after DOM layout\n  setTimeout(fitCanvas, 50);\n\n  // --- Simulation state ---\n  let particles = [];\n  let attractors = []; // {x, y, strength, type} type: 'attract' or 'repel'\n  let running = true;\n  let trailEnabled = true;\n  let stepOnce = false;\n\n  // Settings (linked to sliders)\n  const settings = {\n    count: parseInt(countSlider.value),\n    speed: parseFloat(speedSlider.value),\n    gravity: parseFloat(gravitySlider.value),\n    size: parseFloat(sizeSlider.value),\n    hue: parseInt(hueSlider.value),\n    repelRadius: parseFloat(repelRadiusSlider.value),\n    trailAlpha: parseFloat(trailAlphaSlider.value)\n  };\n\n  // --- Utility functions ---\n  function rand(min, max){ return Math.random() * (max - min) + min; }\n  function dist2(a,b,c,d){ const dx = a-c, dy = b-d; return dx*dx + dy*dy; }\n\n  // --- Particle class-like objects ---\n  function createParticle(x, y){\n    const angle = Math.random() * Math.PI * 2;\n    const speed = Math.random() * 0.6 + 0.1;\n    return {\n      x: x !== undefined ? x : rand(0, canvas.width / (window.devicePixelRatio||1)),\n      y: y !== undefined ? y : rand(0, canvas.height / (window.devicePixelRatio||1)),\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: settings.size,\n      hue: settings.hue\n    };\n  }\n\n  function resetParticles(count){\n    particles = [];\n    for(let i=0;i<count;i++) particles.push(createParticle());\n    updateParticleCountLabel();\n  }\n\n  // --- Attractor handling ---\n  function addAttractor(x, y, type = 'attract'){\n    const strength = (type === 'attract') ? 3000 : -3000;\n    attractors.push({x,y,strength,type});\n  }\n\n  // --- Simulation update ---\n  function update(dt){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // compute global energy for display\n    let energy = 0;\n\n    for(let p of particles){\n      // global gravity\n      p.vy += settings.gravity * dt;\n\n      // apply attractors/repulsors\n      for(let a of attractors){\n        const dx = a.x - p.x;\n        const dy = a.y - p.y;\n        const d2 = dx*dx + dy*dy;\n        const minR = 10;\n        const r = Math.sqrt(d2) + 0.0001;\n        const radius = settings.repelRadius;\n        // influence reduces with distance (inverse-square-like under cap)\n        const influence = Math.max(0, 1 - (r / radius));\n        if (influence > 0){\n          // force magnitude\n          const force = (a.strength / (d2 + 100)) * influence * settings.speed;\n          p.vx += (dx / r) * force * dt;\n          p.vy += (dy / r) * force * dt;\n        }\n      }\n\n      // velocity damping for stability\n      p.vx *= 0.999;\n      p.vy *= 0.999;\n\n      // integrate\n      p.x += p.vx * settings.speed * dt;\n      p.y += p.vy * settings.speed * dt;\n\n      // wrapping boundaries\n      if(p.x < -20) p.x = w + 20;\n      if(p.x > w + 20) p.x = -20;\n      if(p.y < -20) p.y = h + 20;\n      if(p.y > h + 20) p.y = -20;\n\n      energy += (p.vx*p.vx + p.vy*p.vy) * 0.5;\n    }\n\n    energyLabel.textContent = energy.toFixed(1);\n  }\n\n  // --- Rendering ---\n  function render(){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // trail effect: fill with translucent rect to fade previous frames\n    if(trailEnabled){\n      ctx.fillStyle = `rgba(6,11,20,${settings.trailAlpha})`;\n      ctx.fillRect(0,0,w,h);\n    } else {\n      // clear fully\n      ctx.clearRect(0,0,w,h);\n      // draw subtle background\n      ctx.fillStyle = 'rgba(6,11,20,1)';\n      ctx.fillRect(0,0,w,h);\n    }\n\n    // draw attractors\n    for(let a of attractors){\n      const radius = 10 + Math.min(80, Math.abs(a.strength)/50);\n      ctx.beginPath();\n      const grad = ctx.createRadialGradient(a.x-2, a.y-2, 1, a.x, a.y, radius);\n      if(a.type === 'attract'){\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(34,193,195,0.8)');\n        grad.addColorStop(1,'rgba(10,152,160,0.25)');\n      } else {\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(255,122,122,0.85)');\n        grad.addColorStop(1,'rgba(255,74,74,0.18)');\n      }\n      ctx.fillStyle = grad;\n      ctx.arc(a.x, a.y, radius, 0, Math.PI*2);\n      ctx.fill();\n\n      // ring showing influence radius\n      ctx.strokeStyle = (a.type === 'attract') ? 'rgba(34,193,195,0.25)' : 'rgba(255,122,122,0.22)';\n      ctx.lineWidth = 1.2;\n      ctx.beginPath();\n      ctx.arc(a.x, a.y, settings.repelRadius, 0, Math.PI*2);\n      ctx.stroke();\n    }\n\n    // draw particles\n    for(let p of particles){\n      // color based on velocity/hue\n      const speed = Math.min(1.5, Math.sqrt(p.vx*p.vx + p.vy*p.vy));\n      const sat = 60 + Math.round(speed*40);\n      const light = 45 + Math.round(speed*8);\n      ctx.fillStyle = `hsl(${settings.hue}, ${sat}%, ${light}%)`;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, settings.size, 0, Math.PI*2);\n      ctx.fill();\n    }\n  }\n\n  // --- Main loop with FPS measurement ---\n  let last = performance.now();\n  let accum = 0;\n  let frames = 0;\n  let fpsTimer = performance.now();\n  let fps = 0;\n\n  function animate(now){\n    const dt = Math.min(40, now - last);\n    last = now;\n    // dt in ms -> convert to seconds for physics stability\n    const dtSec = dt / 16.6667; // normalized so 1 equals approx 60fps\n\n    if(running || stepOnce){\n      update(dtSec);\n      render();\n      stepOnce = false;\n    }\n\n    frames++;\n    if(now - fpsTimer > 500){\n      fps = Math.round((frames * 1000) / (now - fpsTimer));\n      fpsLabel.textContent = fps;\n      frames = 0;\n      fpsTimer = now;\n    }\n\n    requestAnimationFrame(animate);\n  }\n\n  // --- UI wiring ---\n  function updateSettingsFromUI(){\n    settings.count = parseInt(countSlider.value);\n    settings.speed = parseFloat(speedSlider.value);\n    settings.gravity = parseFloat(gravitySlider.value);\n    settings.size = parseFloat(sizeSlider.value);\n    settings.hue = parseInt(hueSlider.value);\n    settings.repelRadius = parseFloat(repelRadiusSlider.value);\n    settings.trailAlpha = parseFloat(trailAlphaSlider.value);\n\n    countVal.textContent = settings.count;\n    speedVal.textContent = settings.speed.toFixed(2);\n    gravVal.textContent = settings.gravity.toFixed(2);\n    sizeVal.textContent = settings.size;\n    hueVal.textContent = settings.hue;\n    repelVal.textContent = settings.repelRadius;\n    trailVal.textContent = settings.trailAlpha;\n  }\n\n  // update labels on initial load\n  updateSettingsFromUI();\n\n  // event listeners for sliders\n  [countSlider, speedSlider, gravitySlider, sizeSlider, hueSlider, repelRadiusSlider, trailAlphaSlider].forEach(input=>{\n    input.addEventListener('input', e=>{\n      updateSettingsFromUI();\n      // re-create particles if count changed significantly\n      const desired = settings.count;\n      if(particles.length < desired){\n        const add = desired - particles.length;\n        for(let i=0;i<add;i++) particles.push(createParticle());\n      } else if(particles.length > desired){\n        particles.length = desired;\n      }\n      updateParticleCountLabel();\n    });\n  });\n\n  function updateParticleCountLabel(){\n    particleCountLabel.textContent = particles.length;\n    countVal.textContent = settings.count;\n  }\n\n  // buttons\n  startBtn.addEventListener('click', ()=>{\n    running = !running;\n    startBtn.textContent = running ? '暂停' : '运行';\n    startBtn.setAttribute('aria-pressed', running ? 'true' : 'false');\n    statusLabel.textContent = running ? '运行中' : '已暂停';\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(!running){\n      stepOnce = true;\n    } else {\n      // when running, allow a single extra step (no-op)\n    }\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    attractors = [];\n    resetParticles(settings.count);\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    // randomize some sliders\n    countSlider.value = Math.floor(rand(50, 500));\n    speedSlider.value = (rand(0.3, 2.5)).toFixed(2);\n    gravitySlider.value = (rand(-0.2, 0.6)).toFixed(2);\n    sizeSlider.value = (rand(1.5, 6)).toFixed(1);\n    hueSlider.value = Math.floor(rand(0, 360));\n    repelRadiusSlider.value = Math.floor(rand(40, 220));\n    trailAlphaSlider.value = (rand(0,0.25)).toFixed(2);\n    updateSettingsFromUI();\n    resetParticles(settings.count);\n  });\n\n  trailToggle.addEventListener('click', ()=>{\n    trailEnabled = !trailEnabled;\n    trailToggle.textContent = trailEnabled ? '切换轨迹' : '切换轨迹';\n    // Update visual feedback: change background fill immediately on toggle\n    if(!trailEnabled){\n      // clear fully\n      const w = canvas.width / (window.devicePixelRatio||1);\n      const h = canvas.height / (window.devicePixelRatio||1);\n      ctx.clearRect(0,0,w,h);\n    }\n  });\n\n  // attract/repel mode toggle\n  modeAttract.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','true');\n    modeRepel.setAttribute('aria-pressed','false');\n  });\n  modeRepel.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','false');\n    modeRepel.setAttribute('aria-pressed','true');\n  });\n\n  // canvas click to place attractor/repulsor\n  canvas.addEventListener('click', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    // map mouse to canvas coordinate (CSS pixels)\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const type = (modeRepel.getAttribute('aria-pressed') === 'true') ? 'repel' : 'attract';\n    addAttractor(x, y, type);\n  });\n\n  // double-click removes nearest attractor\n  canvas.addEventListener('dblclick', (e)=>{\n    if(attractors.length === 0) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    let nearestIdx = -1;\n    let nearestDist = Infinity;\n    for(let i=0;i<attractors.length;i++){\n      const a = attractors[i];\n      const d = (a.x - x) * (a.x - x) + (a.y - y) * (a.y - y);\n      if(d < nearestDist){ nearestDist = d; nearestIdx = i; }\n    }\n    if(nearestIdx >= 0) attractors.splice(nearestIdx, 1);\n  });\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      startBtn.click();\n    } else if(e.key === 'r'){\n      randomBtn.click();\n    } else if(e.key === 't'){\n      trailToggle.click();\n    }\n  });\n\n  // initialization\n  resetParticles(settings.count);\n\n  // ensure canvas fits and animate\n  fitCanvas();\n  requestAnimationFrame(animate);\n\n  // Accessibility: give focus outline on keyboard navigation for buttons\n  const allBtns = document.querySelectorAll('.btn, .chip');\n  allBtns.forEach(b=>{\n    b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') b.click(); });\n  });",
                "parameters": [],
                "status": "success"
              },
              "attempts": 1
            },
            "rawData": "{\"success\":true,\"data\":{\"experiment_id\":\"df88de10-d212-4ccc-9d06-ad35cef1c6d8\",\"title\":\"交互式系统演示：粒子动画 + 按钮与滑块\",\"description\":\"摘要（来自 Perplexity 的信息）：\\n- 创建包含多个交互元素（按钮、滑块、动画效果）的复杂系统是一个多学科的话题，涉及用户交互、实时渲染和可视化设计。该领域注重交互控制、性能与可访问性（来源：Perplexity AI 研究）。\\n- 本演示将把这些要素组合在一起，提供可调参数、动画、可视化反馈与交互控件，便于演示实时系统如何对输入响应（来源：Perplexity AI 研究）。\\n\\n下面是完整的自包含 HTML 文件。将其保存为 .html 并在浏览器中打开即可运行。代码中包含使用说明、注释与可访问性标签。\",\"html_content\":\"<div class=\\\"container\\\" role=\\\"main\\\" aria-label=\\\"Interactive particle system demo\\\">\\n    <aside class=\\\"controls\\\" aria-label=\\\"Controls panel\\\">\\n      <div>\\n        <div class=\\\"title\\\">交互式粒子系统演示</div>\\n        <div class=\\\"subtitle\\\">使用按钮、滑块与点击交互，实时调整与观察动画效果</div>\\n      </div>\\n\\n      <div class=\\\"panel group\\\" aria-hidden=\\\"false\\\">\\n        <div class=\\\"row\\\" style=\\\"justify-content:space-between; align-items:center;\\\">\\n          <div class=\\\"stat\\\">状态: <span id=\\\"status\\\">运行中</span></div>\\n          <div class=\\\"stat\\\">FPS: <span id=\\\"fps\\\">0</span></div>\\n        </div>\\n\\n        <div>\\n          <label for=\\\"count\\\">粒子数量: <span id=\\\"countVal\\\">200</span></label>\\n          <input id=\\\"count\\\" type=\\\"range\\\" min=\\\"10\\\" max=\\\"800\\\" step=\\\"1\\\" value=\\\"200\\\" aria-label=\\\"粒子数量滑块\\\">\\n        </div>\\n\\n        <div>\\n          <label for=\\\"speed\\\">速度倍率: <span id=\\\"speedVal\\\">1.0</span></label>\\n          <input id=\\\"speed\\\" type=\\\"range\\\" min=\\\"0.1\\\" max=\\\"4\\\" step=\\\"0.05\\\" value=\\\"1\\\" aria-label=\\\"速度倍率滑块\\\">\\n        </div>\\n\\n        <div>\\n          <label for=\\\"gravity\\\">全局重力 (y): <span id=\\\"gravVal\\\">0.00</span></label>\\n          <input id=\\\"gravity\\\" type=\\\"range\\\" min=\\\"-1\\\" max=\\\"1\\\" step=\\\"0.01\\\" value=\\\"0\\\" aria-label=\\\"重力滑块\\\">\\n        </div>\\n\\n        <div>\\n          <label for=\\\"size\\\">粒子大小: <span id=\\\"sizeVal\\\">3</span></label>\\n          <input id=\\\"size\\\" type=\\\"range\\\" min=\\\"1\\\" max=\\\"8\\\" step=\\\"0.5\\\" value=\\\"3\\\" aria-label=\\\"粒子大小滑块\\\">\\n        </div>\\n\\n        <div>\\n          <label for=\\\"hue\\\">色相 (色彩风格): <span id=\\\"hueVal\\\">200</span></label>\\n          <input id=\\\"hue\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"360\\\" step=\\\"1\\\" value=\\\"200\\\" aria-label=\\\"色相滑块\\\">\\n        </div>\\n\\n        <div class=\\\"control-grid\\\">\\n          <div>\\n            <label for=\\\"repelRadius\\\">斥力半径: <span id=\\\"repelVal\\\">60</span></label>\\n            <input id=\\\"repelRadius\\\" type=\\\"range\\\" min=\\\"10\\\" max=\\\"300\\\" step=\\\"1\\\" value=\\\"60\\\" aria-label=\\\"斥力半径滑块\\\">\\n          </div>\\n          <div>\\n            <label for=\\\"trailAlpha\\\">轨迹透明度: <span id=\\\"trailVal\\\">0.12</span></label>\\n            <input id=\\\"trailAlpha\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"0.5\\\" step=\\\"0.01\\\" value=\\\"0.12\\\" aria-label=\\\"轨迹透明度滑块\\\">\\n          </div>\\n        </div>\\n\\n        <div class=\\\"row\\\" style=\\\"justify-content:space-between; margin-top:6px;\\\">\\n          <button id=\\\"startBtn\\\" class=\\\"btn\\\" aria-pressed=\\\"true\\\">暂停</button>\\n          <button id=\\\"stepBtn\\\" class=\\\"btn\\\">单帧</button>\\n          <button id=\\\"resetBtn\\\" class=\\\"btn\\\">重置</button>\\n        </div>\\n\\n        <div class=\\\"row\\\" style=\\\"justify-content:space-between;\\\">\\n          <button id=\\\"randomBtn\\\" class=\\\"btn\\\">随机参数</button>\\n          <button id=\\\"trailToggle\\\" class=\\\"btn\\\">切换轨迹</button>\\n        </div>\\n\\n        <div class=\\\"row\\\" style=\\\"justify-content:space-between;\\\">\\n          <div class=\\\"small\\\">点击画布以放置吸引点/排斥点</div>\\n          <div class=\\\"toggle\\\">\\n            <button id=\\\"modeAttract\\\" class=\\\"btn chip\\\" aria-pressed=\\\"true\\\"><span class=\\\"attractor attract\\\" aria-hidden=\\\"true\\\"></span> 吸引</button>\\n            <button id=\\\"modeRepel\\\" class=\\\"btn chip\\\" aria-pressed=\\\"false\\\"><span class=\\\"attractor repel\\\" aria-hidden=\\\"true\\\"></span> 排斥</button>\\n          </div>\\n        </div>\\n\\n        <div class=\\\"row\\\" style=\\\"justify-content:space-between;\\\">\\n          <div class=\\\"stat\\\">能量: <span id=\\\"energy\\\">0</span></div>\\n          <div class=\\\"stat\\\">粒子: <span id=\\\"particleCount\\\">0</span></div>\\n        </div>\\n\\n        <footer class=\\\"instructions\\\">\\n          说明：使用滑块调整系统参数。点击“吸引/排斥”选择模式，然后点击画布放置控制点。可切换轨迹以查看运动路径。\\n        </footer>\\n      </div>\\n    </aside>\\n\\n    <main class=\\\"canvas-wrap\\\" aria-label=\\\"Canvas area\\\">\\n      <canvas id=\\\"canvas\\\" width=\\\"1200\\\" height=\\\"760\\\" role=\\\"img\\\" aria-label=\\\"粒子动画画布\\\"></canvas>\\n    </main>\\n  </div>\\n\\n  <script>\\n  /*\\n    交互式粒子系统演示\\n    - 粒子受吸引/排斥点影响\\n    - 支持：开始/暂停、单帧、重置、随机化、轨迹开关\\n    - 滑块控制粒子数量、速度、重力、大小、色相、斥力半径、轨迹透明度\\n    - 点击画布：放置吸引或排斥点（取决于当前模式）\\n  */\\n\\n  // --- DOM references ---\\n  const canvas = document.getElementById('canvas');\\n  const ctx = canvas.getContext('2d', { alpha: true });\\n  const startBtn = document.getElementById('startBtn');\\n  const stepBtn = document.getElementById('stepBtn');\\n  const resetBtn = document.getElementById('resetBtn');\\n  const randomBtn = document.getElementById('randomBtn');\\n  const trailToggle = document.getElementById('trailToggle');\\n  const modeAttract = document.getElementById('modeAttract');\\n  const modeRepel = document.getElementById('modeRepel');\\n\\n  const countSlider = document.getElementById('count');\\n  const speedSlider = document.getElementById('speed');\\n  const gravitySlider = document.getElementById('gravity');\\n  const sizeSlider = document.getElementById('size');\\n  const hueSlider = document.getElementById('hue');\\n  const repelRadiusSlider = document.getElementById('repelRadius');\\n  const trailAlphaSlider = document.getElementById('trailAlpha');\\n\\n  const countVal = document.getElementById('countVal');\\n  const speedVal = document.getElementById('speedVal');\\n  const gravVal = document.getElementById('gravVal');\\n  const sizeVal = document.getElementById('sizeVal');\\n  const hueVal = document.getElementById('hueVal');\\n  const repelVal = document.getElementById('repelVal');\\n  const trailVal = document.getElementById('trailVal');\\n\\n  const statusLabel = document.getElementById('status');\\n  const fpsLabel = document.getElementById('fps');\\n  const energyLabel = document.getElementById('energy');\\n  const particleCountLabel = document.getElementById('particleCount');\\n\\n  // --- Canvas sizing ---\\n  function fitCanvas(){\\n    // set canvas internal resolution for crisp rendering\\n    const rect = canvas.getBoundingClientRect();\\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\\n    canvas.width = Math.floor(rect.width * dpr);\\n    canvas.height = Math.floor(rect.height * dpr);\\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\\n  }\\n  window.addEventListener('resize', fitCanvas);\\n  // initial fit after DOM layout\\n  setTimeout(fitCanvas, 50);\\n\\n  // --- Simulation state ---\\n  let particles = [];\\n  let attractors = []; // {x, y, strength, type} type: 'attract' or 'repel'\\n  let running = true;\\n  let trailEnabled = true;\\n  let stepOnce = false;\\n\\n  // Settings (linked to sliders)\\n  const settings = {\\n    count: parseInt(countSlider.value),\\n    speed: parseFloat(speedSlider.value),\\n    gravity: parseFloat(gravitySlider.value),\\n    size: parseFloat(sizeSlider.value),\\n    hue: parseInt(hueSlider.value),\\n    repelRadius: parseFloat(repelRadiusSlider.value),\\n    trailAlpha: parseFloat(trailAlphaSlider.value)\\n  };\\n\\n  // --- Utility functions ---\\n  function rand(min, max){ return Math.random() * (max - min) + min; }\\n  function dist2(a,b,c,d){ const dx = a-c, dy = b-d; return dx*dx + dy*dy; }\\n\\n  // --- Particle class-like objects ---\\n  function createParticle(x, y){\\n    const angle = Math.random() * Math.PI * 2;\\n    const speed = Math.random() * 0.6 + 0.1;\\n    return {\\n      x: x !== undefined ? x : rand(0, canvas.width / (window.devicePixelRatio||1)),\\n      y: y !== undefined ? y : rand(0, canvas.height / (window.devicePixelRatio||1)),\\n      vx: Math.cos(angle) * speed,\\n      vy: Math.sin(angle) * speed,\\n      size: settings.size,\\n      hue: settings.hue\\n    };\\n  }\\n\\n  function resetParticles(count){\\n    particles = [];\\n    for(let i=0;i<count;i++) particles.push(createParticle());\\n    updateParticleCountLabel();\\n  }\\n\\n  // --- Attractor handling ---\\n  function addAttractor(x, y, type = 'attract'){\\n    const strength = (type === 'attract') ? 3000 : -3000;\\n    attractors.push({x,y,strength,type});\\n  }\\n\\n  // --- Simulation update ---\\n  function update(dt){\\n    const w = canvas.width / (window.devicePixelRatio||1);\\n    const h = canvas.height / (window.devicePixelRatio||1);\\n\\n    // compute global energy for display\\n    let energy = 0;\\n\\n    for(let p of particles){\\n      // global gravity\\n      p.vy += settings.gravity * dt;\\n\\n      // apply attractors/repulsors\\n      for(let a of attractors){\\n        const dx = a.x - p.x;\\n        const dy = a.y - p.y;\\n        const d2 = dx*dx + dy*dy;\\n        const minR = 10;\\n        const r = Math.sqrt(d2) + 0.0001;\\n        const radius = settings.repelRadius;\\n        // influence reduces with distance (inverse-square-like under cap)\\n        const influence = Math.max(0, 1 - (r / radius));\\n        if (influence > 0){\\n          // force magnitude\\n          const force = (a.strength / (d2 + 100)) * influence * settings.speed;\\n          p.vx += (dx / r) * force * dt;\\n          p.vy += (dy / r) * force * dt;\\n        }\\n      }\\n\\n      // velocity damping for stability\\n      p.vx *= 0.999;\\n      p.vy *= 0.999;\\n\\n      // integrate\\n      p.x += p.vx * settings.speed * dt;\\n      p.y += p.vy * settings.speed * dt;\\n\\n      // wrapping boundaries\\n      if(p.x < -20) p.x = w + 20;\\n      if(p.x > w + 20) p.x = -20;\\n      if(p.y < -20) p.y = h + 20;\\n      if(p.y > h + 20) p.y = -20;\\n\\n      energy += (p.vx*p.vx + p.vy*p.vy) * 0.5;\\n    }\\n\\n    energyLabel.textContent = energy.toFixed(1);\\n  }\\n\\n  // --- Rendering ---\\n  function render(){\\n    const w = canvas.width / (window.devicePixelRatio||1);\\n    const h = canvas.height / (window.devicePixelRatio||1);\\n\\n    // trail effect: fill with translucent rect to fade previous frames\\n    if(trailEnabled){\\n      ctx.fillStyle = `rgba(6,11,20,${settings.trailAlpha})`;\\n      ctx.fillRect(0,0,w,h);\\n    } else {\\n      // clear fully\\n      ctx.clearRect(0,0,w,h);\\n      // draw subtle background\\n      ctx.fillStyle = 'rgba(6,11,20,1)';\\n      ctx.fillRect(0,0,w,h);\\n    }\\n\\n    // draw attractors\\n    for(let a of attractors){\\n      const radius = 10 + Math.min(80, Math.abs(a.strength)/50);\\n      ctx.beginPath();\\n      const grad = ctx.createRadialGradient(a.x-2, a.y-2, 1, a.x, a.y, radius);\\n      if(a.type === 'attract'){\\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\\n        grad.addColorStop(0.5, 'rgba(34,193,195,0.8)');\\n        grad.addColorStop(1,'rgba(10,152,160,0.25)');\\n      } else {\\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\\n        grad.addColorStop(0.5, 'rgba(255,122,122,0.85)');\\n        grad.addColorStop(1,'rgba(255,74,74,0.18)');\\n      }\\n      ctx.fillStyle = grad;\\n      ctx.arc(a.x, a.y, radius, 0, Math.PI*2);\\n      ctx.fill();\\n\\n      // ring showing influence radius\\n      ctx.strokeStyle = (a.type === 'attract') ? 'rgba(34,193,195,0.25)' : 'rgba(255,122,122,0.22)';\\n      ctx.lineWidth = 1.2;\\n      ctx.beginPath();\\n      ctx.arc(a.x, a.y, settings.repelRadius, 0, Math.PI*2);\\n      ctx.stroke();\\n    }\\n\\n    // draw particles\\n    for(let p of particles){\\n      // color based on velocity/hue\\n      const speed = Math.min(1.5, Math.sqrt(p.vx*p.vx + p.vy*p.vy));\\n      const sat = 60 + Math.round(speed*40);\\n      const light = 45 + Math.round(speed*8);\\n      ctx.fillStyle = `hsl(${settings.hue}, ${sat}%, ${light}%)`;\\n      ctx.beginPath();\\n      ctx.arc(p.x, p.y, settings.size, 0, Math.PI*2);\\n      ctx.fill();\\n    }\\n  }\\n\\n  // --- Main loop with FPS measurement ---\\n  let last = performance.now();\\n  let accum = 0;\\n  let frames = 0;\\n  let fpsTimer = performance.now();\\n  let fps = 0;\\n\\n  function animate(now){\\n    const dt = Math.min(40, now - last);\\n    last = now;\\n    // dt in ms -> convert to seconds for physics stability\\n    const dtSec = dt / 16.6667; // normalized so 1 equals approx 60fps\\n\\n    if(running || stepOnce){\\n      update(dtSec);\\n      render();\\n      stepOnce = false;\\n    }\\n\\n    frames++;\\n    if(now - fpsTimer > 500){\\n      fps = Math.round((frames * 1000) / (now - fpsTimer));\\n      fpsLabel.textContent = fps;\\n      frames = 0;\\n      fpsTimer = now;\\n    }\\n\\n    requestAnimationFrame(animate);\\n  }\\n\\n  // --- UI wiring ---\\n  function updateSettingsFromUI(){\\n    settings.count = parseInt(countSlider.value);\\n    settings.speed = parseFloat(speedSlider.value);\\n    settings.gravity = parseFloat(gravitySlider.value);\\n    settings.size = parseFloat(sizeSlider.value);\\n    settings.hue = parseInt(hueSlider.value);\\n    settings.repelRadius = parseFloat(repelRadiusSlider.value);\\n    settings.trailAlpha = parseFloat(trailAlphaSlider.value);\\n\\n    countVal.textContent = settings.count;\\n    speedVal.textContent = settings.speed.toFixed(2);\\n    gravVal.textContent = settings.gravity.toFixed(2);\\n    sizeVal.textContent = settings.size;\\n    hueVal.textContent = settings.hue;\\n    repelVal.textContent = settings.repelRadius;\\n    trailVal.textContent = settings.trailAlpha;\\n  }\\n\\n  // update labels on initial load\\n  updateSettingsFromUI();\\n\\n  // event listeners for sliders\\n  [countSlider, speedSlider, gravitySlider, sizeSlider, hueSlider, repelRadiusSlider, trailAlphaSlider].forEach(input=>{\\n    input.addEventListener('input', e=>{\\n      updateSettingsFromUI();\\n      // re-create particles if count changed significantly\\n      const desired = settings.count;\\n      if(particles.length < desired){\\n        const add = desired - particles.length;\\n        for(let i=0;i<add;i++) particles.push(createParticle());\\n      } else if(particles.length > desired){\\n        particles.length = desired;\\n      }\\n      updateParticleCountLabel();\\n    });\\n  });\\n\\n  function updateParticleCountLabel(){\\n    particleCountLabel.textContent = particles.length;\\n    countVal.textContent = settings.count;\\n  }\\n\\n  // buttons\\n  startBtn.addEventListener('click', ()=>{\\n    running = !running;\\n    startBtn.textContent = running ? '暂停' : '运行';\\n    startBtn.setAttribute('aria-pressed', running ? 'true' : 'false');\\n    statusLabel.textContent = running ? '运行中' : '已暂停';\\n  });\\n\\n  stepBtn.addEventListener('click', ()=>{\\n    if(!running){\\n      stepOnce = true;\\n    } else {\\n      // when running, allow a single extra step (no-op)\\n    }\\n  });\\n\\n  resetBtn.addEventListener('click', ()=>{\\n    attractors = [];\\n    resetParticles(settings.count);\\n  });\\n\\n  randomBtn.addEventListener('click', ()=>{\\n    // randomize some sliders\\n    countSlider.value = Math.floor(rand(50, 500));\\n    speedSlider.value = (rand(0.3, 2.5)).toFixed(2);\\n    gravitySlider.value = (rand(-0.2, 0.6)).toFixed(2);\\n    sizeSlider.value = (rand(1.5, 6)).toFixed(1);\\n    hueSlider.value = Math.floor(rand(0, 360));\\n    repelRadiusSlider.value = Math.floor(rand(40, 220));\\n    trailAlphaSlider.value = (rand(0,0.25)).toFixed(2);\\n    updateSettingsFromUI();\\n    resetParticles(settings.count);\\n  });\\n\\n  trailToggle.addEventListener('click', ()=>{\\n    trailEnabled = !trailEnabled;\\n    trailToggle.textContent = trailEnabled ? '切换轨迹' : '切换轨迹';\\n    // Update visual feedback: change background fill immediately on toggle\\n    if(!trailEnabled){\\n      // clear fully\\n      const w = canvas.width / (window.devicePixelRatio||1);\\n      const h = canvas.height / (window.devicePixelRatio||1);\\n      ctx.clearRect(0,0,w,h);\\n    }\\n  });\\n\\n  // attract/repel mode toggle\\n  modeAttract.addEventListener('click', ()=>{\\n    modeAttract.setAttribute('aria-pressed','true');\\n    modeRepel.setAttribute('aria-pressed','false');\\n  });\\n  modeRepel.addEventListener('click', ()=>{\\n    modeAttract.setAttribute('aria-pressed','false');\\n    modeRepel.setAttribute('aria-pressed','true');\\n  });\\n\\n  // canvas click to place attractor/repulsor\\n  canvas.addEventListener('click', (e)=>{\\n    const rect = canvas.getBoundingClientRect();\\n    // map mouse to canvas coordinate (CSS pixels)\\n    const x = e.clientX - rect.left;\\n    const y = e.clientY - rect.top;\\n    const type = (modeRepel.getAttribute('aria-pressed') === 'true') ? 'repel' : 'attract';\\n    addAttractor(x, y, type);\\n  });\\n\\n  // double-click removes nearest attractor\\n  canvas.addEventListener('dblclick', (e)=>{\\n    if(attractors.length === 0) return;\\n    const rect = canvas.getBoundingClientRect();\\n    const x = e.clientX - rect.left;\\n    const y = e.clientY - rect.top;\\n    let nearestIdx = -1;\\n    let nearestDist = Infinity;\\n    for(let i=0;i<attractors.length;i++){\\n      const a = attractors[i];\\n      const d = (a.x - x) * (a.x - x) + (a.y - y) * (a.y - y);\\n      if(d < nearestDist){ nearestDist = d; nearestIdx = i; }\\n    }\\n    if(nearestIdx >= 0) attractors.splice(nearestIdx, 1);\\n  });\\n\\n  // keyboard shortcuts\\n  window.addEventListener('keydown', (e)=>{\\n    if(e.key === ' '){\\n      e.preventDefault();\\n      startBtn.click();\\n    } else if(e.key === 'r'){\\n      randomBtn.click();\\n    } else if(e.key === 't'){\\n      trailToggle.click();\\n    }\\n  });\\n\\n  // initialization\\n  resetParticles(settings.count);\\n\\n  // ensure canvas fits and animate\\n  fitCanvas();\\n  requestAnimationFrame(animate);\\n\\n  // Accessibility: give focus outline on keyboard navigation for buttons\\n  const allBtns = document.querySelectorAll('.btn, .chip');\\n  allBtns.forEach(b=>{\\n    b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') b.click(); });\\n  });\\n\\n  </script>\",\"css_content\":\"/* 基础布局 */\\n    :root{\\n      --bg: #0f1720;\\n      --panel: #0b1220;\\n      --accent: #22c1c3;\\n      --muted: #94a3b8;\\n      --card: rgba(255,255,255,0.03);\\n    }\\n    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,\\\"Helvetica Neue\\\",Arial;}\\n    body{background:linear-gradient(180deg,#061021 0%, #0b1220 100%); color:#e6eef8; display:flex; align-items:stretch; gap:18px; padding:18px;}\\n    .container{display:flex; flex:1; gap:18px; min-height:400px;}\\n    .controls{\\n      width:360px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\\n      border-radius:12px; padding:14px; box-shadow: 0 6px 24px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.04);\\n      display:flex; flex-direction:column; gap:12px;\\n    }\\n    .title{font-size:18px; font-weight:600; color:var(--accent);}\\n    .subtitle{font-size:12px; color:var(--muted); margin-bottom:6px;}\\n    .canvas-wrap{\\n      flex:1; border-radius:12px; overflow:hidden; background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.15));\\n      display:flex; flex-direction:column;\\n    }\\n    canvas{width:100%; height:100%; display:block; background:transparent;}\\n    .panel {\\n      background:var(--card); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:8px;\\n    }\\n    label{font-size:13px; color:#dbe9f5;}\\n    input[type=\\\"range\\\"]{width:100%;}\\n    .row{display:flex; gap:8px; align-items:center;}\\n    .btn {\\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\\n      border:1px solid rgba(255,255,255,0.04);\\n      color:#e6eef8; padding:8px 12px; border-radius:8px; cursor:pointer;\\n      transition:transform .12s ease, box-shadow .12s ease;\\n      display:inline-flex; align-items:center; gap:8px;\\n    }\\n    .btn:active{transform:translateY(1px) scale(.996);}\\n    .controls .group{display:flex; flex-direction:column; gap:8px;}\\n    .stat{font-size:13px; color:var(--muted);}\\n    .small{font-size:12px;color:var(--muted);}\\n    .control-grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px;}\\n    .toggle{display:inline-flex; align-items:center; gap:8px;}\\n    .chip{background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:6px; font-size:13px;}\\n    footer.instructions{font-size:12px; color:var(--muted); padding-top:6px;}\\n\\n    /* attractor icons */\\n    .attractor { width:18px; height:18px; border-radius:50%; display:inline-block; }\\n    .attract { background: radial-gradient(circle at 30% 30%, #fff, #22c1c3 40%, #0a98a0 100%);}\\n    .repel { background: radial-gradient(circle at 30% 30%, #fff, #ff7a7a 40%, #ff4a4a 100%);}\\n\\n    /* simple responsive */\\n    @media (max-width:920px){\\n      body{padding:12px;}\\n      .controls{width:320px;}\\n    }\\n    @media (max-width:720px){\\n      body{flex-direction:column;}\\n      .container{flex-direction:column;}\\n      .controls{width:auto;}\\n    }\",\"js_content\":\"/*\\n    交互式粒子系统演示\\n    - 粒子受吸引/排斥点影响\\n    - 支持：开始/暂停、单帧、重置、随机化、轨迹开关\\n    - 滑块控制粒子数量、速度、重力、大小、色相、斥力半径、轨迹透明度\\n    - 点击画布：放置吸引或排斥点（取决于当前模式）\\n  */\\n\\n  // --- DOM references ---\\n  const canvas = document.getElementById('canvas');\\n  const ctx = canvas.getContext('2d', { alpha: true });\\n  const startBtn = document.getElementById('startBtn');\\n  const stepBtn = document.getElementById('stepBtn');\\n  const resetBtn = document.getElementById('resetBtn');\\n  const randomBtn = document.getElementById('randomBtn');\\n  const trailToggle = document.getElementById('trailToggle');\\n  const modeAttract = document.getElementById('modeAttract');\\n  const modeRepel = document.getElementById('modeRepel');\\n\\n  const countSlider = document.getElementById('count');\\n  const speedSlider = document.getElementById('speed');\\n  const gravitySlider = document.getElementById('gravity');\\n  const sizeSlider = document.getElementById('size');\\n  const hueSlider = document.getElementById('hue');\\n  const repelRadiusSlider = document.getElementById('repelRadius');\\n  const trailAlphaSlider = document.getElementById('trailAlpha');\\n\\n  const countVal = document.getElementById('countVal');\\n  const speedVal = document.getElementById('speedVal');\\n  const gravVal = document.getElementById('gravVal');\\n  const sizeVal = document.getElementById('sizeVal');\\n  const hueVal = document.getElementById('hueVal');\\n  const repelVal = document.getElementById('repelVal');\\n  const trailVal = document.getElementById('trailVal');\\n\\n  const statusLabel = document.getElementById('status');\\n  const fpsLabel = document.getElementById('fps');\\n  const energyLabel = document.getElementById('energy');\\n  const particleCountLabel = document.getElementById('particleCount');\\n\\n  // --- Canvas sizing ---\\n  function fitCanvas(){\\n    // set canvas internal resolution for crisp rendering\\n    const rect = canvas.getBoundingClientRect();\\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\\n    canvas.width = Math.floor(rect.width * dpr);\\n    canvas.height = Math.floor(rect.height * dpr);\\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\\n  }\\n  window.addEventListener('resize', fitCanvas);\\n  // initial fit after DOM layout\\n  setTimeout(fitCanvas, 50);\\n\\n  // --- Simulation state ---\\n  let particles = [];\\n  let attractors = []; // {x, y, strength, type} type: 'attract' or 'repel'\\n  let running = true;\\n  let trailEnabled = true;\\n  let stepOnce = false;\\n\\n  // Settings (linked to sliders)\\n  const settings = {\\n    count: parseInt(countSlider.value),\\n    speed: parseFloat(speedSlider.value),\\n    gravity: parseFloat(gravitySlider.value),\\n    size: parseFloat(sizeSlider.value),\\n    hue: parseInt(hueSlider.value),\\n    repelRadius: parseFloat(repelRadiusSlider.value),\\n    trailAlpha: parseFloat(trailAlphaSlider.value)\\n  };\\n\\n  // --- Utility functions ---\\n  function rand(min, max){ return Math.random() * (max - min) + min; }\\n  function dist2(a,b,c,d){ const dx = a-c, dy = b-d; return dx*dx + dy*dy; }\\n\\n  // --- Particle class-like objects ---\\n  function createParticle(x, y){\\n    const angle = Math.random() * Math.PI * 2;\\n    const speed = Math.random() * 0.6 + 0.1;\\n    return {\\n      x: x !== undefined ? x : rand(0, canvas.width / (window.devicePixelRatio||1)),\\n      y: y !== undefined ? y : rand(0, canvas.height / (window.devicePixelRatio||1)),\\n      vx: Math.cos(angle) * speed,\\n      vy: Math.sin(angle) * speed,\\n      size: settings.size,\\n      hue: settings.hue\\n    };\\n  }\\n\\n  function resetParticles(count){\\n    particles = [];\\n    for(let i=0;i<count;i++) particles.push(createParticle());\\n    updateParticleCountLabel();\\n  }\\n\\n  // --- Attractor handling ---\\n  function addAttractor(x, y, type = 'attract'){\\n    const strength = (type === 'attract') ? 3000 : -3000;\\n    attractors.push({x,y,strength,type});\\n  }\\n\\n  // --- Simulation update ---\\n  function update(dt){\\n    const w = canvas.width / (window.devicePixelRatio||1);\\n    const h = canvas.height / (window.devicePixelRatio||1);\\n\\n    // compute global energy for display\\n    let energy = 0;\\n\\n    for(let p of particles){\\n      // global gravity\\n      p.vy += settings.gravity * dt;\\n\\n      // apply attractors/repulsors\\n      for(let a of attractors){\\n        const dx = a.x - p.x;\\n        const dy = a.y - p.y;\\n        const d2 = dx*dx + dy*dy;\\n        const minR = 10;\\n        const r = Math.sqrt(d2) + 0.0001;\\n        const radius = settings.repelRadius;\\n        // influence reduces with distance (inverse-square-like under cap)\\n        const influence = Math.max(0, 1 - (r / radius));\\n        if (influence > 0){\\n          // force magnitude\\n          const force = (a.strength / (d2 + 100)) * influence * settings.speed;\\n          p.vx += (dx / r) * force * dt;\\n          p.vy += (dy / r) * force * dt;\\n        }\\n      }\\n\\n      // velocity damping for stability\\n      p.vx *= 0.999;\\n      p.vy *= 0.999;\\n\\n      // integrate\\n      p.x += p.vx * settings.speed * dt;\\n      p.y += p.vy * settings.speed * dt;\\n\\n      // wrapping boundaries\\n      if(p.x < -20) p.x = w + 20;\\n      if(p.x > w + 20) p.x = -20;\\n      if(p.y < -20) p.y = h + 20;\\n      if(p.y > h + 20) p.y = -20;\\n\\n      energy += (p.vx*p.vx + p.vy*p.vy) * 0.5;\\n    }\\n\\n    energyLabel.textContent = energy.toFixed(1);\\n  }\\n\\n  // --- Rendering ---\\n  function render(){\\n    const w = canvas.width / (window.devicePixelRatio||1);\\n    const h = canvas.height / (window.devicePixelRatio||1);\\n\\n    // trail effect: fill with translucent rect to fade previous frames\\n    if(trailEnabled){\\n      ctx.fillStyle = `rgba(6,11,20,${settings.trailAlpha})`;\\n      ctx.fillRect(0,0,w,h);\\n    } else {\\n      // clear fully\\n      ctx.clearRect(0,0,w,h);\\n      // draw subtle background\\n      ctx.fillStyle = 'rgba(6,11,20,1)';\\n      ctx.fillRect(0,0,w,h);\\n    }\\n\\n    // draw attractors\\n    for(let a of attractors){\\n      const radius = 10 + Math.min(80, Math.abs(a.strength)/50);\\n      ctx.beginPath();\\n      const grad = ctx.createRadialGradient(a.x-2, a.y-2, 1, a.x, a.y, radius);\\n      if(a.type === 'attract'){\\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\\n        grad.addColorStop(0.5, 'rgba(34,193,195,0.8)');\\n        grad.addColorStop(1,'rgba(10,152,160,0.25)');\\n      } else {\\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\\n        grad.addColorStop(0.5, 'rgba(255,122,122,0.85)');\\n        grad.addColorStop(1,'rgba(255,74,74,0.18)');\\n      }\\n      ctx.fillStyle = grad;\\n      ctx.arc(a.x, a.y, radius, 0, Math.PI*2);\\n      ctx.fill();\\n\\n      // ring showing influence radius\\n      ctx.strokeStyle = (a.type === 'attract') ? 'rgba(34,193,195,0.25)' : 'rgba(255,122,122,0.22)';\\n      ctx.lineWidth = 1.2;\\n      ctx.beginPath();\\n      ctx.arc(a.x, a.y, settings.repelRadius, 0, Math.PI*2);\\n      ctx.stroke();\\n    }\\n\\n    // draw particles\\n    for(let p of particles){\\n      // color based on velocity/hue\\n      const speed = Math.min(1.5, Math.sqrt(p.vx*p.vx + p.vy*p.vy));\\n      const sat = 60 + Math.round(speed*40);\\n      const light = 45 + Math.round(speed*8);\\n      ctx.fillStyle = `hsl(${settings.hue}, ${sat}%, ${light}%)`;\\n      ctx.beginPath();\\n      ctx.arc(p.x, p.y, settings.size, 0, Math.PI*2);\\n      ctx.fill();\\n    }\\n  }\\n\\n  // --- Main loop with FPS measurement ---\\n  let last = performance.now();\\n  let accum = 0;\\n  let frames = 0;\\n  let fpsTimer = performance.now();\\n  let fps = 0;\\n\\n  function animate(now){\\n    const dt = Math.min(40, now - last);\\n    last = now;\\n    // dt in ms -> convert to seconds for physics stability\\n    const dtSec = dt / 16.6667; // normalized so 1 equals approx 60fps\\n\\n    if(running || stepOnce){\\n      update(dtSec);\\n      render();\\n      stepOnce = false;\\n    }\\n\\n    frames++;\\n    if(now - fpsTimer > 500){\\n      fps = Math.round((frames * 1000) / (now - fpsTimer));\\n      fpsLabel.textContent = fps;\\n      frames = 0;\\n      fpsTimer = now;\\n    }\\n\\n    requestAnimationFrame(animate);\\n  }\\n\\n  // --- UI wiring ---\\n  function updateSettingsFromUI(){\\n    settings.count = parseInt(countSlider.value);\\n    settings.speed = parseFloat(speedSlider.value);\\n    settings.gravity = parseFloat(gravitySlider.value);\\n    settings.size = parseFloat(sizeSlider.value);\\n    settings.hue = parseInt(hueSlider.value);\\n    settings.repelRadius = parseFloat(repelRadiusSlider.value);\\n    settings.trailAlpha = parseFloat(trailAlphaSlider.value);\\n\\n    countVal.textContent = settings.count;\\n    speedVal.textContent = settings.speed.toFixed(2);\\n    gravVal.textContent = settings.gravity.toFixed(2);\\n    sizeVal.textContent = settings.size;\\n    hueVal.textContent = settings.hue;\\n    repelVal.textContent = settings.repelRadius;\\n    trailVal.textContent = settings.trailAlpha;\\n  }\\n\\n  // update labels on initial load\\n  updateSettingsFromUI();\\n\\n  // event listeners for sliders\\n  [countSlider, speedSlider, gravitySlider, sizeSlider, hueSlider, repelRadiusSlider, trailAlphaSlider].forEach(input=>{\\n    input.addEventListener('input', e=>{\\n      updateSettingsFromUI();\\n      // re-create particles if count changed significantly\\n      const desired = settings.count;\\n      if(particles.length < desired){\\n        const add = desired - particles.length;\\n        for(let i=0;i<add;i++) particles.push(createParticle());\\n      } else if(particles.length > desired){\\n        particles.length = desired;\\n      }\\n      updateParticleCountLabel();\\n    });\\n  });\\n\\n  function updateParticleCountLabel(){\\n    particleCountLabel.textContent = particles.length;\\n    countVal.textContent = settings.count;\\n  }\\n\\n  // buttons\\n  startBtn.addEventListener('click', ()=>{\\n    running = !running;\\n    startBtn.textContent = running ? '暂停' : '运行';\\n    startBtn.setAttribute('aria-pressed', running ? 'true' : 'false');\\n    statusLabel.textContent = running ? '运行中' : '已暂停';\\n  });\\n\\n  stepBtn.addEventListener('click', ()=>{\\n    if(!running){\\n      stepOnce = true;\\n    } else {\\n      // when running, allow a single extra step (no-op)\\n    }\\n  });\\n\\n  resetBtn.addEventListener('click', ()=>{\\n    attractors = [];\\n    resetParticles(settings.count);\\n  });\\n\\n  randomBtn.addEventListener('click', ()=>{\\n    // randomize some sliders\\n    countSlider.value = Math.floor(rand(50, 500));\\n    speedSlider.value = (rand(0.3, 2.5)).toFixed(2);\\n    gravitySlider.value = (rand(-0.2, 0.6)).toFixed(2);\\n    sizeSlider.value = (rand(1.5, 6)).toFixed(1);\\n    hueSlider.value = Math.floor(rand(0, 360));\\n    repelRadiusSlider.value = Math.floor(rand(40, 220));\\n    trailAlphaSlider.value = (rand(0,0.25)).toFixed(2);\\n    updateSettingsFromUI();\\n    resetParticles(settings.count);\\n  });\\n\\n  trailToggle.addEventListener('click', ()=>{\\n    trailEnabled = !trailEnabled;\\n    trailToggle.textContent = trailEnabled ? '切换轨迹' : '切换轨迹';\\n    // Update visual feedback: change background fill immediately on toggle\\n    if(!trailEnabled){\\n      // clear fully\\n      const w = canvas.width / (window.devicePixelRatio||1);\\n      const h = canvas.height / (window.devicePixelRatio||1);\\n      ctx.clearRect(0,0,w,h);\\n    }\\n  });\\n\\n  // attract/repel mode toggle\\n  modeAttract.addEventListener('click', ()=>{\\n    modeAttract.setAttribute('aria-pressed','true');\\n    modeRepel.setAttribute('aria-pressed','false');\\n  });\\n  modeRepel.addEventListener('click', ()=>{\\n    modeAttract.setAttribute('aria-pressed','false');\\n    modeRepel.setAttribute('aria-pressed','true');\\n  });\\n\\n  // canvas click to place attractor/repulsor\\n  canvas.addEventListener('click', (e)=>{\\n    const rect = canvas.getBoundingClientRect();\\n    // map mouse to canvas coordinate (CSS pixels)\\n    const x = e.clientX - rect.left;\\n    const y = e.clientY - rect.top;\\n    const type = (modeRepel.getAttribute('aria-pressed') === 'true') ? 'repel' : 'attract';\\n    addAttractor(x, y, type);\\n  });\\n\\n  // double-click removes nearest attractor\\n  canvas.addEventListener('dblclick', (e)=>{\\n    if(attractors.length === 0) return;\\n    const rect = canvas.getBoundingClientRect();\\n    const x = e.clientX - rect.left;\\n    const y = e.clientY - rect.top;\\n    let nearestIdx = -1;\\n    let nearestDist = Infinity;\\n    for(let i=0;i<attractors.length;i++){\\n      const a = attractors[i];\\n      const d = (a.x - x) * (a.x - x) + (a.y - y) * (a.y - y);\\n      if(d < nearestDist){ nearestDist = d; nearestIdx = i; }\\n    }\\n    if(nearestIdx >= 0) attractors.splice(nearestIdx, 1);\\n  });\\n\\n  // keyboard shortcuts\\n  window.addEventListener('keydown', (e)=>{\\n    if(e.key === ' '){\\n      e.preventDefault();\\n      startBtn.click();\\n    } else if(e.key === 'r'){\\n      randomBtn.click();\\n    } else if(e.key === 't'){\\n      trailToggle.click();\\n    }\\n  });\\n\\n  // initialization\\n  resetParticles(settings.count);\\n\\n  // ensure canvas fits and animate\\n  fitCanvas();\\n  requestAnimationFrame(animate);\\n\\n  // Accessibility: give focus outline on keyboard navigation for buttons\\n  const allBtns = document.querySelectorAll('.btn, .chip');\\n  allBtns.forEach(b=>{\\n    b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') b.click(); });\\n  });\",\"parameters\":[],\"status\":\"success\"},\"attempts\":1}"
          }
        },
        {
          "stage": "data_analysis",
          "timestamp": "2025-08-09T13:10:16.959Z",
          "dataType": "object",
          "keys": [
            "success",
            "data",
            "attempts"
          ],
          "data": {
            "success": true,
            "data": {
              "experiment_id": "df88de10-d212-4ccc-9d06-ad35cef1c6d8",
              "title": "交互式系统演示：粒子动画 + 按钮与滑块",
              "description": "摘要（来自 Perplexity 的信息）：\n- 创建包含多个交互元素（按钮、滑块、动画效果）的复杂系统是一个多学科的话题，涉及用户交互、实时渲染和可视化设计。该领域注重交互控制、性能与可访问性（来源：Perplexity AI 研究）。\n- 本演示将把这些要素组合在一起，提供可调参数、动画、可视化反馈与交互控件，便于演示实时系统如何对输入响应（来源：Perplexity AI 研究）。\n\n下面是完整的自包含 HTML 文件。将其保存为 .html 并在浏览器中打开即可运行。代码中包含使用说明、注释与可访问性标签。",
              "html_content": "<div class=\"container\" role=\"main\" aria-label=\"Interactive particle system demo\">\n    <aside class=\"controls\" aria-label=\"Controls panel\">\n      <div>\n        <div class=\"title\">交互式粒子系统演示</div>\n        <div class=\"subtitle\">使用按钮、滑块与点击交互，实时调整与观察动画效果</div>\n      </div>\n\n      <div class=\"panel group\" aria-hidden=\"false\">\n        <div class=\"row\" style=\"justify-content:space-between; align-items:center;\">\n          <div class=\"stat\">状态: <span id=\"status\">运行中</span></div>\n          <div class=\"stat\">FPS: <span id=\"fps\">0</span></div>\n        </div>\n\n        <div>\n          <label for=\"count\">粒子数量: <span id=\"countVal\">200</span></label>\n          <input id=\"count\" type=\"range\" min=\"10\" max=\"800\" step=\"1\" value=\"200\" aria-label=\"粒子数量滑块\">\n        </div>\n\n        <div>\n          <label for=\"speed\">速度倍率: <span id=\"speedVal\">1.0</span></label>\n          <input id=\"speed\" type=\"range\" min=\"0.1\" max=\"4\" step=\"0.05\" value=\"1\" aria-label=\"速度倍率滑块\">\n        </div>\n\n        <div>\n          <label for=\"gravity\">全局重力 (y): <span id=\"gravVal\">0.00</span></label>\n          <input id=\"gravity\" type=\"range\" min=\"-1\" max=\"1\" step=\"0.01\" value=\"0\" aria-label=\"重力滑块\">\n        </div>\n\n        <div>\n          <label for=\"size\">粒子大小: <span id=\"sizeVal\">3</span></label>\n          <input id=\"size\" type=\"range\" min=\"1\" max=\"8\" step=\"0.5\" value=\"3\" aria-label=\"粒子大小滑块\">\n        </div>\n\n        <div>\n          <label for=\"hue\">色相 (色彩风格): <span id=\"hueVal\">200</span></label>\n          <input id=\"hue\" type=\"range\" min=\"0\" max=\"360\" step=\"1\" value=\"200\" aria-label=\"色相滑块\">\n        </div>\n\n        <div class=\"control-grid\">\n          <div>\n            <label for=\"repelRadius\">斥力半径: <span id=\"repelVal\">60</span></label>\n            <input id=\"repelRadius\" type=\"range\" min=\"10\" max=\"300\" step=\"1\" value=\"60\" aria-label=\"斥力半径滑块\">\n          </div>\n          <div>\n            <label for=\"trailAlpha\">轨迹透明度: <span id=\"trailVal\">0.12</span></label>\n            <input id=\"trailAlpha\" type=\"range\" min=\"0\" max=\"0.5\" step=\"0.01\" value=\"0.12\" aria-label=\"轨迹透明度滑块\">\n          </div>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between; margin-top:6px;\">\n          <button id=\"startBtn\" class=\"btn\" aria-pressed=\"true\">暂停</button>\n          <button id=\"stepBtn\" class=\"btn\">单帧</button>\n          <button id=\"resetBtn\" class=\"btn\">重置</button>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <button id=\"randomBtn\" class=\"btn\">随机参数</button>\n          <button id=\"trailToggle\" class=\"btn\">切换轨迹</button>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <div class=\"small\">点击画布以放置吸引点/排斥点</div>\n          <div class=\"toggle\">\n            <button id=\"modeAttract\" class=\"btn chip\" aria-pressed=\"true\"><span class=\"attractor attract\" aria-hidden=\"true\"></span> 吸引</button>\n            <button id=\"modeRepel\" class=\"btn chip\" aria-pressed=\"false\"><span class=\"attractor repel\" aria-hidden=\"true\"></span> 排斥</button>\n          </div>\n        </div>\n\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <div class=\"stat\">能量: <span id=\"energy\">0</span></div>\n          <div class=\"stat\">粒子: <span id=\"particleCount\">0</span></div>\n        </div>\n\n        <footer class=\"instructions\">\n          说明：使用滑块调整系统参数。点击“吸引/排斥”选择模式，然后点击画布放置控制点。可切换轨迹以查看运动路径。\n        </footer>\n      </div>\n    </aside>\n\n    <main class=\"canvas-wrap\" aria-label=\"Canvas area\">\n      <canvas id=\"canvas\" width=\"1200\" height=\"760\" role=\"img\" aria-label=\"粒子动画画布\"></canvas>\n    </main>\n  </div>\n\n  <script>\n  /*\n    交互式粒子系统演示\n    - 粒子受吸引/排斥点影响\n    - 支持：开始/暂停、单帧、重置、随机化、轨迹开关\n    - 滑块控制粒子数量、速度、重力、大小、色相、斥力半径、轨迹透明度\n    - 点击画布：放置吸引或排斥点（取决于当前模式）\n  */\n\n  // --- DOM references ---\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d', { alpha: true });\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const trailToggle = document.getElementById('trailToggle');\n  const modeAttract = document.getElementById('modeAttract');\n  const modeRepel = document.getElementById('modeRepel');\n\n  const countSlider = document.getElementById('count');\n  const speedSlider = document.getElementById('speed');\n  const gravitySlider = document.getElementById('gravity');\n  const sizeSlider = document.getElementById('size');\n  const hueSlider = document.getElementById('hue');\n  const repelRadiusSlider = document.getElementById('repelRadius');\n  const trailAlphaSlider = document.getElementById('trailAlpha');\n\n  const countVal = document.getElementById('countVal');\n  const speedVal = document.getElementById('speedVal');\n  const gravVal = document.getElementById('gravVal');\n  const sizeVal = document.getElementById('sizeVal');\n  const hueVal = document.getElementById('hueVal');\n  const repelVal = document.getElementById('repelVal');\n  const trailVal = document.getElementById('trailVal');\n\n  const statusLabel = document.getElementById('status');\n  const fpsLabel = document.getElementById('fps');\n  const energyLabel = document.getElementById('energy');\n  const particleCountLabel = document.getElementById('particleCount');\n\n  // --- Canvas sizing ---\n  function fitCanvas(){\n    // set canvas internal resolution for crisp rendering\n    const rect = canvas.getBoundingClientRect();\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n  window.addEventListener('resize', fitCanvas);\n  // initial fit after DOM layout\n  setTimeout(fitCanvas, 50);\n\n  // --- Simulation state ---\n  let particles = [];\n  let attractors = []; // {x, y, strength, type} type: 'attract' or 'repel'\n  let running = true;\n  let trailEnabled = true;\n  let stepOnce = false;\n\n  // Settings (linked to sliders)\n  const settings = {\n    count: parseInt(countSlider.value),\n    speed: parseFloat(speedSlider.value),\n    gravity: parseFloat(gravitySlider.value),\n    size: parseFloat(sizeSlider.value),\n    hue: parseInt(hueSlider.value),\n    repelRadius: parseFloat(repelRadiusSlider.value),\n    trailAlpha: parseFloat(trailAlphaSlider.value)\n  };\n\n  // --- Utility functions ---\n  function rand(min, max){ return Math.random() * (max - min) + min; }\n  function dist2(a,b,c,d){ const dx = a-c, dy = b-d; return dx*dx + dy*dy; }\n\n  // --- Particle class-like objects ---\n  function createParticle(x, y){\n    const angle = Math.random() * Math.PI * 2;\n    const speed = Math.random() * 0.6 + 0.1;\n    return {\n      x: x !== undefined ? x : rand(0, canvas.width / (window.devicePixelRatio||1)),\n      y: y !== undefined ? y : rand(0, canvas.height / (window.devicePixelRatio||1)),\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: settings.size,\n      hue: settings.hue\n    };\n  }\n\n  function resetParticles(count){\n    particles = [];\n    for(let i=0;i<count;i++) particles.push(createParticle());\n    updateParticleCountLabel();\n  }\n\n  // --- Attractor handling ---\n  function addAttractor(x, y, type = 'attract'){\n    const strength = (type === 'attract') ? 3000 : -3000;\n    attractors.push({x,y,strength,type});\n  }\n\n  // --- Simulation update ---\n  function update(dt){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // compute global energy for display\n    let energy = 0;\n\n    for(let p of particles){\n      // global gravity\n      p.vy += settings.gravity * dt;\n\n      // apply attractors/repulsors\n      for(let a of attractors){\n        const dx = a.x - p.x;\n        const dy = a.y - p.y;\n        const d2 = dx*dx + dy*dy;\n        const minR = 10;\n        const r = Math.sqrt(d2) + 0.0001;\n        const radius = settings.repelRadius;\n        // influence reduces with distance (inverse-square-like under cap)\n        const influence = Math.max(0, 1 - (r / radius));\n        if (influence > 0){\n          // force magnitude\n          const force = (a.strength / (d2 + 100)) * influence * settings.speed;\n          p.vx += (dx / r) * force * dt;\n          p.vy += (dy / r) * force * dt;\n        }\n      }\n\n      // velocity damping for stability\n      p.vx *= 0.999;\n      p.vy *= 0.999;\n\n      // integrate\n      p.x += p.vx * settings.speed * dt;\n      p.y += p.vy * settings.speed * dt;\n\n      // wrapping boundaries\n      if(p.x < -20) p.x = w + 20;\n      if(p.x > w + 20) p.x = -20;\n      if(p.y < -20) p.y = h + 20;\n      if(p.y > h + 20) p.y = -20;\n\n      energy += (p.vx*p.vx + p.vy*p.vy) * 0.5;\n    }\n\n    energyLabel.textContent = energy.toFixed(1);\n  }\n\n  // --- Rendering ---\n  function render(){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // trail effect: fill with translucent rect to fade previous frames\n    if(trailEnabled){\n      ctx.fillStyle = `rgba(6,11,20,${settings.trailAlpha})`;\n      ctx.fillRect(0,0,w,h);\n    } else {\n      // clear fully\n      ctx.clearRect(0,0,w,h);\n      // draw subtle background\n      ctx.fillStyle = 'rgba(6,11,20,1)';\n      ctx.fillRect(0,0,w,h);\n    }\n\n    // draw attractors\n    for(let a of attractors){\n      const radius = 10 + Math.min(80, Math.abs(a.strength)/50);\n      ctx.beginPath();\n      const grad = ctx.createRadialGradient(a.x-2, a.y-2, 1, a.x, a.y, radius);\n      if(a.type === 'attract'){\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(34,193,195,0.8)');\n        grad.addColorStop(1,'rgba(10,152,160,0.25)');\n      } else {\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(255,122,122,0.85)');\n        grad.addColorStop(1,'rgba(255,74,74,0.18)');\n      }\n      ctx.fillStyle = grad;\n      ctx.arc(a.x, a.y, radius, 0, Math.PI*2);\n      ctx.fill();\n\n      // ring showing influence radius\n      ctx.strokeStyle = (a.type === 'attract') ? 'rgba(34,193,195,0.25)' : 'rgba(255,122,122,0.22)';\n      ctx.lineWidth = 1.2;\n      ctx.beginPath();\n      ctx.arc(a.x, a.y, settings.repelRadius, 0, Math.PI*2);\n      ctx.stroke();\n    }\n\n    // draw particles\n    for(let p of particles){\n      // color based on velocity/hue\n      const speed = Math.min(1.5, Math.sqrt(p.vx*p.vx + p.vy*p.vy));\n      const sat = 60 + Math.round(speed*40);\n      const light = 45 + Math.round(speed*8);\n      ctx.fillStyle = `hsl(${settings.hue}, ${sat}%, ${light}%)`;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, settings.size, 0, Math.PI*2);\n      ctx.fill();\n    }\n  }\n\n  // --- Main loop with FPS measurement ---\n  let last = performance.now();\n  let accum = 0;\n  let frames = 0;\n  let fpsTimer = performance.now();\n  let fps = 0;\n\n  function animate(now){\n    const dt = Math.min(40, now - last);\n    last = now;\n    // dt in ms -> convert to seconds for physics stability\n    const dtSec = dt / 16.6667; // normalized so 1 equals approx 60fps\n\n    if(running || stepOnce){\n      update(dtSec);\n      render();\n      stepOnce = false;\n    }\n\n    frames++;\n    if(now - fpsTimer > 500){\n      fps = Math.round((frames * 1000) / (now - fpsTimer));\n      fpsLabel.textContent = fps;\n      frames = 0;\n      fpsTimer = now;\n    }\n\n    requestAnimationFrame(animate);\n  }\n\n  // --- UI wiring ---\n  function updateSettingsFromUI(){\n    settings.count = parseInt(countSlider.value);\n    settings.speed = parseFloat(speedSlider.value);\n    settings.gravity = parseFloat(gravitySlider.value);\n    settings.size = parseFloat(sizeSlider.value);\n    settings.hue = parseInt(hueSlider.value);\n    settings.repelRadius = parseFloat(repelRadiusSlider.value);\n    settings.trailAlpha = parseFloat(trailAlphaSlider.value);\n\n    countVal.textContent = settings.count;\n    speedVal.textContent = settings.speed.toFixed(2);\n    gravVal.textContent = settings.gravity.toFixed(2);\n    sizeVal.textContent = settings.size;\n    hueVal.textContent = settings.hue;\n    repelVal.textContent = settings.repelRadius;\n    trailVal.textContent = settings.trailAlpha;\n  }\n\n  // update labels on initial load\n  updateSettingsFromUI();\n\n  // event listeners for sliders\n  [countSlider, speedSlider, gravitySlider, sizeSlider, hueSlider, repelRadiusSlider, trailAlphaSlider].forEach(input=>{\n    input.addEventListener('input', e=>{\n      updateSettingsFromUI();\n      // re-create particles if count changed significantly\n      const desired = settings.count;\n      if(particles.length < desired){\n        const add = desired - particles.length;\n        for(let i=0;i<add;i++) particles.push(createParticle());\n      } else if(particles.length > desired){\n        particles.length = desired;\n      }\n      updateParticleCountLabel();\n    });\n  });\n\n  function updateParticleCountLabel(){\n    particleCountLabel.textContent = particles.length;\n    countVal.textContent = settings.count;\n  }\n\n  // buttons\n  startBtn.addEventListener('click', ()=>{\n    running = !running;\n    startBtn.textContent = running ? '暂停' : '运行';\n    startBtn.setAttribute('aria-pressed', running ? 'true' : 'false');\n    statusLabel.textContent = running ? '运行中' : '已暂停';\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(!running){\n      stepOnce = true;\n    } else {\n      // when running, allow a single extra step (no-op)\n    }\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    attractors = [];\n    resetParticles(settings.count);\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    // randomize some sliders\n    countSlider.value = Math.floor(rand(50, 500));\n    speedSlider.value = (rand(0.3, 2.5)).toFixed(2);\n    gravitySlider.value = (rand(-0.2, 0.6)).toFixed(2);\n    sizeSlider.value = (rand(1.5, 6)).toFixed(1);\n    hueSlider.value = Math.floor(rand(0, 360));\n    repelRadiusSlider.value = Math.floor(rand(40, 220));\n    trailAlphaSlider.value = (rand(0,0.25)).toFixed(2);\n    updateSettingsFromUI();\n    resetParticles(settings.count);\n  });\n\n  trailToggle.addEventListener('click', ()=>{\n    trailEnabled = !trailEnabled;\n    trailToggle.textContent = trailEnabled ? '切换轨迹' : '切换轨迹';\n    // Update visual feedback: change background fill immediately on toggle\n    if(!trailEnabled){\n      // clear fully\n      const w = canvas.width / (window.devicePixelRatio||1);\n      const h = canvas.height / (window.devicePixelRatio||1);\n      ctx.clearRect(0,0,w,h);\n    }\n  });\n\n  // attract/repel mode toggle\n  modeAttract.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','true');\n    modeRepel.setAttribute('aria-pressed','false');\n  });\n  modeRepel.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','false');\n    modeRepel.setAttribute('aria-pressed','true');\n  });\n\n  // canvas click to place attractor/repulsor\n  canvas.addEventListener('click', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    // map mouse to canvas coordinate (CSS pixels)\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const type = (modeRepel.getAttribute('aria-pressed') === 'true') ? 'repel' : 'attract';\n    addAttractor(x, y, type);\n  });\n\n  // double-click removes nearest attractor\n  canvas.addEventListener('dblclick', (e)=>{\n    if(attractors.length === 0) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    let nearestIdx = -1;\n    let nearestDist = Infinity;\n    for(let i=0;i<attractors.length;i++){\n      const a = attractors[i];\n      const d = (a.x - x) * (a.x - x) + (a.y - y) * (a.y - y);\n      if(d < nearestDist){ nearestDist = d; nearestIdx = i; }\n    }\n    if(nearestIdx >= 0) attractors.splice(nearestIdx, 1);\n  });\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      startBtn.click();\n    } else if(e.key === 'r'){\n      randomBtn.click();\n    } else if(e.key === 't'){\n      trailToggle.click();\n    }\n  });\n\n  // initialization\n  resetParticles(settings.count);\n\n  // ensure canvas fits and animate\n  fitCanvas();\n  requestAnimationFrame(animate);\n\n  // Accessibility: give focus outline on keyboard navigation for buttons\n  const allBtns = document.querySelectorAll('.btn, .chip');\n  allBtns.forEach(b=>{\n    b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') b.click(); });\n  });\n\n  </script>",
              "css_content": "/* 基础布局 */\n    :root{\n      --bg: #0f1720;\n      --panel: #0b1220;\n      --accent: #22c1c3;\n      --muted: #94a3b8;\n      --card: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,#061021 0%, #0b1220 100%); color:#e6eef8; display:flex; align-items:stretch; gap:18px; padding:18px;}\n    .container{display:flex; flex:1; gap:18px; min-height:400px;}\n    .controls{\n      width:360px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px; padding:14px; box-shadow: 0 6px 24px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.04);\n      display:flex; flex-direction:column; gap:12px;\n    }\n    .title{font-size:18px; font-weight:600; color:var(--accent);}\n    .subtitle{font-size:12px; color:var(--muted); margin-bottom:6px;}\n    .canvas-wrap{\n      flex:1; border-radius:12px; overflow:hidden; background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.15));\n      display:flex; flex-direction:column;\n    }\n    canvas{width:100%; height:100%; display:block; background:transparent;}\n    .panel {\n      background:var(--card); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:8px;\n    }\n    label{font-size:13px; color:#dbe9f5;}\n    input[type=\"range\"]{width:100%;}\n    .row{display:flex; gap:8px; align-items:center;}\n    .btn {\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      color:#e6eef8; padding:8px 12px; border-radius:8px; cursor:pointer;\n      transition:transform .12s ease, box-shadow .12s ease;\n      display:inline-flex; align-items:center; gap:8px;\n    }\n    .btn:active{transform:translateY(1px) scale(.996);}\n    .controls .group{display:flex; flex-direction:column; gap:8px;}\n    .stat{font-size:13px; color:var(--muted);}\n    .small{font-size:12px;color:var(--muted);}\n    .control-grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px;}\n    .toggle{display:inline-flex; align-items:center; gap:8px;}\n    .chip{background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:6px; font-size:13px;}\n    footer.instructions{font-size:12px; color:var(--muted); padding-top:6px;}\n\n    /* attractor icons */\n    .attractor { width:18px; height:18px; border-radius:50%; display:inline-block; }\n    .attract { background: radial-gradient(circle at 30% 30%, #fff, #22c1c3 40%, #0a98a0 100%);}\n    .repel { background: radial-gradient(circle at 30% 30%, #fff, #ff7a7a 40%, #ff4a4a 100%);}\n\n    /* simple responsive */\n    @media (max-width:920px){\n      body{padding:12px;}\n      .controls{width:320px;}\n    }\n    @media (max-width:720px){\n      body{flex-direction:column;}\n      .container{flex-direction:column;}\n      .controls{width:auto;}\n    }",
              "js_content": "/*\n    交互式粒子系统演示\n    - 粒子受吸引/排斥点影响\n    - 支持：开始/暂停、单帧、重置、随机化、轨迹开关\n    - 滑块控制粒子数量、速度、重力、大小、色相、斥力半径、轨迹透明度\n    - 点击画布：放置吸引或排斥点（取决于当前模式）\n  */\n\n  // --- DOM references ---\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d', { alpha: true });\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const trailToggle = document.getElementById('trailToggle');\n  const modeAttract = document.getElementById('modeAttract');\n  const modeRepel = document.getElementById('modeRepel');\n\n  const countSlider = document.getElementById('count');\n  const speedSlider = document.getElementById('speed');\n  const gravitySlider = document.getElementById('gravity');\n  const sizeSlider = document.getElementById('size');\n  const hueSlider = document.getElementById('hue');\n  const repelRadiusSlider = document.getElementById('repelRadius');\n  const trailAlphaSlider = document.getElementById('trailAlpha');\n\n  const countVal = document.getElementById('countVal');\n  const speedVal = document.getElementById('speedVal');\n  const gravVal = document.getElementById('gravVal');\n  const sizeVal = document.getElementById('sizeVal');\n  const hueVal = document.getElementById('hueVal');\n  const repelVal = document.getElementById('repelVal');\n  const trailVal = document.getElementById('trailVal');\n\n  const statusLabel = document.getElementById('status');\n  const fpsLabel = document.getElementById('fps');\n  const energyLabel = document.getElementById('energy');\n  const particleCountLabel = document.getElementById('particleCount');\n\n  // --- Canvas sizing ---\n  function fitCanvas(){\n    // set canvas internal resolution for crisp rendering\n    const rect = canvas.getBoundingClientRect();\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n  window.addEventListener('resize', fitCanvas);\n  // initial fit after DOM layout\n  setTimeout(fitCanvas, 50);\n\n  // --- Simulation state ---\n  let particles = [];\n  let attractors = []; // {x, y, strength, type} type: 'attract' or 'repel'\n  let running = true;\n  let trailEnabled = true;\n  let stepOnce = false;\n\n  // Settings (linked to sliders)\n  const settings = {\n    count: parseInt(countSlider.value),\n    speed: parseFloat(speedSlider.value),\n    gravity: parseFloat(gravitySlider.value),\n    size: parseFloat(sizeSlider.value),\n    hue: parseInt(hueSlider.value),\n    repelRadius: parseFloat(repelRadiusSlider.value),\n    trailAlpha: parseFloat(trailAlphaSlider.value)\n  };\n\n  // --- Utility functions ---\n  function rand(min, max){ return Math.random() * (max - min) + min; }\n  function dist2(a,b,c,d){ const dx = a-c, dy = b-d; return dx*dx + dy*dy; }\n\n  // --- Particle class-like objects ---\n  function createParticle(x, y){\n    const angle = Math.random() * Math.PI * 2;\n    const speed = Math.random() * 0.6 + 0.1;\n    return {\n      x: x !== undefined ? x : rand(0, canvas.width / (window.devicePixelRatio||1)),\n      y: y !== undefined ? y : rand(0, canvas.height / (window.devicePixelRatio||1)),\n      vx: Math.cos(angle) * speed,\n      vy: Math.sin(angle) * speed,\n      size: settings.size,\n      hue: settings.hue\n    };\n  }\n\n  function resetParticles(count){\n    particles = [];\n    for(let i=0;i<count;i++) particles.push(createParticle());\n    updateParticleCountLabel();\n  }\n\n  // --- Attractor handling ---\n  function addAttractor(x, y, type = 'attract'){\n    const strength = (type === 'attract') ? 3000 : -3000;\n    attractors.push({x,y,strength,type});\n  }\n\n  // --- Simulation update ---\n  function update(dt){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // compute global energy for display\n    let energy = 0;\n\n    for(let p of particles){\n      // global gravity\n      p.vy += settings.gravity * dt;\n\n      // apply attractors/repulsors\n      for(let a of attractors){\n        const dx = a.x - p.x;\n        const dy = a.y - p.y;\n        const d2 = dx*dx + dy*dy;\n        const minR = 10;\n        const r = Math.sqrt(d2) + 0.0001;\n        const radius = settings.repelRadius;\n        // influence reduces with distance (inverse-square-like under cap)\n        const influence = Math.max(0, 1 - (r / radius));\n        if (influence > 0){\n          // force magnitude\n          const force = (a.strength / (d2 + 100)) * influence * settings.speed;\n          p.vx += (dx / r) * force * dt;\n          p.vy += (dy / r) * force * dt;\n        }\n      }\n\n      // velocity damping for stability\n      p.vx *= 0.999;\n      p.vy *= 0.999;\n\n      // integrate\n      p.x += p.vx * settings.speed * dt;\n      p.y += p.vy * settings.speed * dt;\n\n      // wrapping boundaries\n      if(p.x < -20) p.x = w + 20;\n      if(p.x > w + 20) p.x = -20;\n      if(p.y < -20) p.y = h + 20;\n      if(p.y > h + 20) p.y = -20;\n\n      energy += (p.vx*p.vx + p.vy*p.vy) * 0.5;\n    }\n\n    energyLabel.textContent = energy.toFixed(1);\n  }\n\n  // --- Rendering ---\n  function render(){\n    const w = canvas.width / (window.devicePixelRatio||1);\n    const h = canvas.height / (window.devicePixelRatio||1);\n\n    // trail effect: fill with translucent rect to fade previous frames\n    if(trailEnabled){\n      ctx.fillStyle = `rgba(6,11,20,${settings.trailAlpha})`;\n      ctx.fillRect(0,0,w,h);\n    } else {\n      // clear fully\n      ctx.clearRect(0,0,w,h);\n      // draw subtle background\n      ctx.fillStyle = 'rgba(6,11,20,1)';\n      ctx.fillRect(0,0,w,h);\n    }\n\n    // draw attractors\n    for(let a of attractors){\n      const radius = 10 + Math.min(80, Math.abs(a.strength)/50);\n      ctx.beginPath();\n      const grad = ctx.createRadialGradient(a.x-2, a.y-2, 1, a.x, a.y, radius);\n      if(a.type === 'attract'){\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(34,193,195,0.8)');\n        grad.addColorStop(1,'rgba(10,152,160,0.25)');\n      } else {\n        grad.addColorStop(0,'rgba(255,255,255,0.9)');\n        grad.addColorStop(0.5, 'rgba(255,122,122,0.85)');\n        grad.addColorStop(1,'rgba(255,74,74,0.18)');\n      }\n      ctx.fillStyle = grad;\n      ctx.arc(a.x, a.y, radius, 0, Math.PI*2);\n      ctx.fill();\n\n      // ring showing influence radius\n      ctx.strokeStyle = (a.type === 'attract') ? 'rgba(34,193,195,0.25)' : 'rgba(255,122,122,0.22)';\n      ctx.lineWidth = 1.2;\n      ctx.beginPath();\n      ctx.arc(a.x, a.y, settings.repelRadius, 0, Math.PI*2);\n      ctx.stroke();\n    }\n\n    // draw particles\n    for(let p of particles){\n      // color based on velocity/hue\n      const speed = Math.min(1.5, Math.sqrt(p.vx*p.vx + p.vy*p.vy));\n      const sat = 60 + Math.round(speed*40);\n      const light = 45 + Math.round(speed*8);\n      ctx.fillStyle = `hsl(${settings.hue}, ${sat}%, ${light}%)`;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, settings.size, 0, Math.PI*2);\n      ctx.fill();\n    }\n  }\n\n  // --- Main loop with FPS measurement ---\n  let last = performance.now();\n  let accum = 0;\n  let frames = 0;\n  let fpsTimer = performance.now();\n  let fps = 0;\n\n  function animate(now){\n    const dt = Math.min(40, now - last);\n    last = now;\n    // dt in ms -> convert to seconds for physics stability\n    const dtSec = dt / 16.6667; // normalized so 1 equals approx 60fps\n\n    if(running || stepOnce){\n      update(dtSec);\n      render();\n      stepOnce = false;\n    }\n\n    frames++;\n    if(now - fpsTimer > 500){\n      fps = Math.round((frames * 1000) / (now - fpsTimer));\n      fpsLabel.textContent = fps;\n      frames = 0;\n      fpsTimer = now;\n    }\n\n    requestAnimationFrame(animate);\n  }\n\n  // --- UI wiring ---\n  function updateSettingsFromUI(){\n    settings.count = parseInt(countSlider.value);\n    settings.speed = parseFloat(speedSlider.value);\n    settings.gravity = parseFloat(gravitySlider.value);\n    settings.size = parseFloat(sizeSlider.value);\n    settings.hue = parseInt(hueSlider.value);\n    settings.repelRadius = parseFloat(repelRadiusSlider.value);\n    settings.trailAlpha = parseFloat(trailAlphaSlider.value);\n\n    countVal.textContent = settings.count;\n    speedVal.textContent = settings.speed.toFixed(2);\n    gravVal.textContent = settings.gravity.toFixed(2);\n    sizeVal.textContent = settings.size;\n    hueVal.textContent = settings.hue;\n    repelVal.textContent = settings.repelRadius;\n    trailVal.textContent = settings.trailAlpha;\n  }\n\n  // update labels on initial load\n  updateSettingsFromUI();\n\n  // event listeners for sliders\n  [countSlider, speedSlider, gravitySlider, sizeSlider, hueSlider, repelRadiusSlider, trailAlphaSlider].forEach(input=>{\n    input.addEventListener('input', e=>{\n      updateSettingsFromUI();\n      // re-create particles if count changed significantly\n      const desired = settings.count;\n      if(particles.length < desired){\n        const add = desired - particles.length;\n        for(let i=0;i<add;i++) particles.push(createParticle());\n      } else if(particles.length > desired){\n        particles.length = desired;\n      }\n      updateParticleCountLabel();\n    });\n  });\n\n  function updateParticleCountLabel(){\n    particleCountLabel.textContent = particles.length;\n    countVal.textContent = settings.count;\n  }\n\n  // buttons\n  startBtn.addEventListener('click', ()=>{\n    running = !running;\n    startBtn.textContent = running ? '暂停' : '运行';\n    startBtn.setAttribute('aria-pressed', running ? 'true' : 'false');\n    statusLabel.textContent = running ? '运行中' : '已暂停';\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(!running){\n      stepOnce = true;\n    } else {\n      // when running, allow a single extra step (no-op)\n    }\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    attractors = [];\n    resetParticles(settings.count);\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    // randomize some sliders\n    countSlider.value = Math.floor(rand(50, 500));\n    speedSlider.value = (rand(0.3, 2.5)).toFixed(2);\n    gravitySlider.value = (rand(-0.2, 0.6)).toFixed(2);\n    sizeSlider.value = (rand(1.5, 6)).toFixed(1);\n    hueSlider.value = Math.floor(rand(0, 360));\n    repelRadiusSlider.value = Math.floor(rand(40, 220));\n    trailAlphaSlider.value = (rand(0,0.25)).toFixed(2);\n    updateSettingsFromUI();\n    resetParticles(settings.count);\n  });\n\n  trailToggle.addEventListener('click', ()=>{\n    trailEnabled = !trailEnabled;\n    trailToggle.textContent = trailEnabled ? '切换轨迹' : '切换轨迹';\n    // Update visual feedback: change background fill immediately on toggle\n    if(!trailEnabled){\n      // clear fully\n      const w = canvas.width / (window.devicePixelRatio||1);\n      const h = canvas.height / (window.devicePixelRatio||1);\n      ctx.clearRect(0,0,w,h);\n    }\n  });\n\n  // attract/repel mode toggle\n  modeAttract.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','true');\n    modeRepel.setAttribute('aria-pressed','false');\n  });\n  modeRepel.addEventListener('click', ()=>{\n    modeAttract.setAttribute('aria-pressed','false');\n    modeRepel.setAttribute('aria-pressed','true');\n  });\n\n  // canvas click to place attractor/repulsor\n  canvas.addEventListener('click', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    // map mouse to canvas coordinate (CSS pixels)\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const type = (modeRepel.getAttribute('aria-pressed') === 'true') ? 'repel' : 'attract';\n    addAttractor(x, y, type);\n  });\n\n  // double-click removes nearest attractor\n  canvas.addEventListener('dblclick', (e)=>{\n    if(attractors.length === 0) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    let nearestIdx = -1;\n    let nearestDist = Infinity;\n    for(let i=0;i<attractors.length;i++){\n      const a = attractors[i];\n      const d = (a.x - x) * (a.x - x) + (a.y - y) * (a.y - y);\n      if(d < nearestDist){ nearestDist = d; nearestIdx = i; }\n    }\n    if(nearestIdx >= 0) attractors.splice(nearestIdx, 1);\n  });\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      startBtn.click();\n    } else if(e.key === 'r'){\n      randomBtn.click();\n    } else if(e.key === 't'){\n      trailToggle.click();\n    }\n  });\n\n  // initialization\n  resetParticles(settings.count);\n\n  // ensure canvas fits and animate\n  fitCanvas();\n  requestAnimationFrame(animate);\n\n  // Accessibility: give focus outline on keyboard navigation for buttons\n  const allBtns = document.querySelectorAll('.btn, .chip');\n  allBtns.forEach(b=>{\n    b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') b.click(); });\n  });",
              "parameters": [],
              "status": "success"
            },
            "attempts": 1
          }
        },
        {
          "stage": "quality_check",
          "timestamp": "2025-08-09T13:10:16.959Z",
          "checks": {
            "hasCode": false,
            "codeLength": 0,
            "htmlTagsFound": [],
            "syntaxErrors": [],
            "bracketMatching": true,
            "syntaxValid": true
          }
        }
      ],
      "finalResult": {
        "codeGenerated": false,
        "codeLength": 0,
        "hasQualityIssues": false,
        "issues": {
          "htmlTags": 0,
          "bracketErrors": false,
          "syntaxErrors": false
        }
      },
      "success": true,
      "errors": [],
      "endTime": "2025-08-09T13:10:16.959Z",
      "duration": 71049
    },
    {
      "name": "数学可视化",
      "prompt": "创建一个数学函数可视化工具，能够绘制sin和cos函数",
      "model": "openrouter/openai/gpt-4o-mini",
      "startTime": "2025-08-09T13:10:21.959Z",
      "stages": [
        {
          "stage": "generate_request",
          "timestamp": "2025-08-09T13:13:19.569Z",
          "response": {
            "status": 200,
            "statusText": "OK",
            "headers": {
              "access-control-allow-origin": "*",
              "connection": "keep-alive",
              "content-length": "39760",
              "content-type": "application/json; charset=utf-8",
              "date": "Sat, 09 Aug 2025 13:13:19 GMT",
              "etag": "W/\"9b50-P8EjTVLBHV7IdxAVcxDYAMexXUA\"",
              "keep-alive": "timeout=5",
              "x-powered-by": "Express"
            },
            "data": {
              "success": true,
              "data": {
                "experiment_id": "aedb0293-4a9d-4317-b277-9d6634fc172f",
                "title": "sin / cos 函数可视化工具",
                "description": "摘要（基于 Perplexity AI 的信息）:\n- sin 与 cos 是周期性三角函数，常用参数包括振幅（A）、角频率/频率（ω 或 f）、相位（φ）和纵向平移（D）。函数形式常写为 y = A * sin(ωx + φ) + D 或 y = A * cos(ωx + φ) + D。周期为 T = 2π/ω（或以 f 表示频率，则 ω = 2πf）。这些概念将用于交互可视化（来源：Perplexity AI）。\n- 下方 HTML 示例是自包含的、无外部依赖的交互式函数可视化工具，可绘制并动态调整 sin 和 cos 曲线的参数，并具有动画、导出图片和鼠标提示等功能。\n\n完整可运行 HTML（保存为 .html 并在浏览器打开）：",
                "html_content": "<header style=\"display:flex;justify-content:space-between;align-items:center;\">\n    <div>\n      <h1>三角函数可视化工具 — sin & cos</h1>\n      <div class=\"small\">调整参数查看曲线变化。支持动画、导出图片与鼠标读取数值。</div>\n    </div>\n    <div style=\"text-align:right\" class=\"small\">来源: Perplexity AI（概念摘要）</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"left\" aria-label=\"Canvas area\">\n      <div style=\"position:relative;\">\n        <canvas id=\"plot\" width=\"1000\" height=\"600\" role=\"img\" aria-label=\"函数绘图\"></canvas>\n        <div id=\"tooltip\" class=\"tooltip\" style=\"display:none\"></div>\n      </div>\n      <div class=\"legend\" aria-hidden=\"false\">\n        <div class=\"item\"><div class=\"swatch\" style=\"background:var(--sin)\"></div><div class=\"small\">y = A·sin(ωx + φ) + D</div></div>\n        <div class=\"item\"><div class=\"swatch\" style=\"background:var(--cos)\"></div><div class=\"small\">y = A·cos(ωx + φ) + D</div></div>\n      </div>\n      <div class=\"eq\" id=\"equation\">y = 1·sin(1·x + 0°) + 0</div>\n      <div class=\"footer\">提示：移动鼠标在画布上可查看具体坐标（x, y）。</div>\n    </div>\n\n    <aside class=\"right\" aria-label=\"Controls\">\n      <div style=\"display:flex;gap:8px;align-items:center;justify-content:space-between;\">\n        <div style=\"font-weight:600\">参数</div>\n        <div class=\"row\">\n          <button class=\"btn secondary\" id=\"resetBtn\">重置</button>\n          <button class=\"btn\" id=\"exportBtn\" title=\"导出为 PNG\">导出 PNG</button>\n        </div>\n      </div>\n\n      <div style=\"margin-top:8px;\">\n        <div class=\"control-row\">\n          <label for=\"amplitude\">振幅 A</label>\n          <input id=\"amplitude\" type=\"range\" min=\"0\" max=\"5\" step=\"0.1\" value=\"1\" />\n          <div style=\"width:60px;text-align:right\" id=\"ampVal\">1.0</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"frequency\">频率 f</label>\n          <input id=\"frequency\" type=\"range\" min=\"0.1\" max=\"5\" step=\"0.1\" value=\"1\" />\n          <div style=\"width:60px;text-align:right\" id=\"freqVal\">1.0</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"phase\">相位 φ (°)</label>\n          <input id=\"phase\" type=\"range\" min=\"-360\" max=\"360\" step=\"1\" value=\"0\" />\n          <div style=\"width:60px;text-align:right\" id=\"phaseVal\">0°</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"vshift\">纵移 D</label>\n          <input id=\"vshift\" type=\"range\" min=\"-5\" max=\"5\" step=\"0.1\" value=\"0\" />\n          <div style=\"width:60px;text-align:right\" id=\"vshiftVal\">0.0</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"xstart\">x 范围</label>\n          <div style=\"display:flex;gap:6px;align-items:center;\">\n            <input id=\"xstart\" type=\"number\" step=\"0.1\" value=\"-6.28\" aria-label=\"x start\" />\n            <span style=\"color:var(--muted)\">到</span>\n            <input id=\"xend\" type=\"number\" step=\"0.1\" value=\"6.28\" aria-label=\"x end\" />\n          </div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"resolution\">采样点</label>\n          <input id=\"resolution\" type=\"range\" min=\"100\" max=\"4000\" step=\"50\" value=\"1000\" />\n          <div style=\"width:60px;text-align:right\" id=\"resVal\">1000</div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div class=\"checkboxes\" role=\"group\" aria-label=\"显示选项\">\n            <label><input id=\"showSin\" type=\"checkbox\" checked /> sin</label>\n            <label><input id=\"showCos\" type=\"checkbox\" checked /> cos</label>\n            <label><input id=\"showGrid\" type=\"checkbox\" checked /> 网格</label>\n          </div>\n        </div>\n\n        <hr style=\"margin:12px 0\" />\n\n        <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n          <div style=\"font-weight:600\">动画</div>\n          <div class=\"small\" id=\"animState\">停止</div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div class=\"control-row\">\n            <label for=\"animate\">播放</label>\n            <button id=\"playBtn\" class=\"btn secondary\">播放</button>\n            <button id=\"pauseBtn\" class=\"btn secondary\">暂停</button>\n          </div>\n\n          <div class=\"control-row\">\n            <label for=\"speed\">速度</label>\n            <input id=\"speed\" type=\"range\" min=\"-4\" max=\"4\" step=\"0.1\" value=\"1\" />\n            <div style=\"width:60px;text-align:right\" id=\"speedVal\">1.0x</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px;\">\n          <div class=\"small\">方程</div>\n          <div class=\"eq\" id=\"equationFull\">sin: y = A·sin(ωx + φ) + D  （ω = 2πf）</div>\n        </div>\n      </div>\n    </aside>\n  </div>\n\n  <script>\n    // 三角函数可视化脚本\n    // 说明：将所有逻辑放在此文件中，使用 canvas 绘制并响应 UI 控件。\n\n    // --- 帮助函数 ---\n    function lerp(a,b,t){ return a + (b-a)*t; }\n    function degToRad(d){ return d * Math.PI / 180; }\n    function formatNum(v, precision=3){ return Number.parseFloat(v).toFixed(precision); }\n\n    // --- DOM ---\n    const canvas = document.getElementById('plot');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    const tooltip = document.getElementById('tooltip');\n\n    // Controls\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xstart = document.getElementById('xstart');\n    const xend = document.getElementById('xend');\n    const resolution = document.getElementById('resolution');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const showGrid = document.getElementById('showGrid');\n\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const resVal = document.getElementById('resVal');\n    const eqText = document.getElementById('equation');\n    const eqFull = document.getElementById('equationFull');\n\n    const playBtn = document.getElementById('playBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const animState = document.getElementById('animState');\n    const speed = document.getElementById('speed');\n    const speedVal = document.getElementById('speedVal');\n\n    const resetBtn = document.getElementById('resetBtn');\n    const exportBtn = document.getElementById('exportBtn');\n\n    // --- 状态 ---\n    let state = {\n      A: parseFloat(amplitude.value),\n      f: parseFloat(frequency.value),\n      phiDeg: parseFloat(phase.value),\n      D: parseFloat(vshift.value),\n      x0: parseFloat(xstart.value),\n      x1: parseFloat(xend.value),\n      N: parseInt(resolution.value),\n      t: 0,\n      playing: false,\n      speed: parseFloat(speed.value),\n      showGrid: showGrid.checked,\n      showSin: showSin.checked,\n      showCos: showCos.checked\n    };\n\n    // Canvas logical size handling for crispness\n    function resizeCanvas(){\n      const ratio = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.max(300, Math.floor(rect.width * ratio));\n      canvas.height = Math.max(200, Math.floor(rect.height * ratio));\n      ctx.setTransform(ratio,0,0,ratio,0,0); // scale drawing operations\n      draw();\n    }\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n\n    // Update UI labels\n    function updateUI(){\n      ampVal.textContent = state.A.toFixed(1);\n      freqVal.textContent = state.f.toFixed(1);\n      phaseVal.textContent = state.phiDeg.toFixed(0) + '°';\n      vshiftVal.textContent = state.D.toFixed(1);\n      resVal.textContent = state.N;\n      speedVal.textContent = state.speed.toFixed(1) + 'x';\n      eqText.textContent = `y = ${state.A} · sin(2π·${state.f}·x / 2π + ${state.phiDeg}°) + ${state.D}`;\n      eqFull.textContent = `sin: y = A·sin(ωx + φ) + D  （ω = 2πf）。 当前: A=${state.A}, f=${state.f}, φ=${state.phiDeg}°, D=${state.D}`;\n      animState.textContent = state.playing ? '播放中' : '停止';\n    }\n\n    // Attach input events\n    amplitude.addEventListener('input', ()=>{ state.A = parseFloat(amplitude.value); updateUI(); draw(); });\n    frequency.addEventListener('input', ()=>{ state.f = parseFloat(frequency.value); updateUI(); draw(); });\n    phase.addEventListener('input', ()=>{ state.phiDeg = parseFloat(phase.value); updateUI(); draw(); });\n    vshift.addEventListener('input', ()=>{ state.D = parseFloat(vshift.value); updateUI(); draw(); });\n    xstart.addEventListener('change', ()=>{ state.x0 = parseFloat(xstart.value); draw(); });\n    xend.addEventListener('change', ()=>{ state.x1 = parseFloat(xend.value); draw(); });\n    resolution.addEventListener('input', ()=>{ state.N = parseInt(resolution.value); updateUI(); draw(); });\n    showGrid.addEventListener('change', ()=>{ state.showGrid = showGrid.checked; draw(); });\n    showSin.addEventListener('change', ()=>{ state.showSin = showSin.checked; draw(); });\n    showCos.addEventListener('change', ()=>{ state.showCos = showCos.checked; draw(); });\n    speed.addEventListener('input', ()=>{ state.speed = parseFloat(speed.value); updateUI(); });\n\n    playBtn.addEventListener('click', ()=>{\n      state.playing = true;\n      updateUI();\n      if(!animating) animate();\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.playing = false;\n      updateUI();\n    });\n\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1; frequency.value = 1; phase.value = 0; vshift.value = 0;\n      xstart.value = -6.28; xend.value = 6.28; resolution.value = 1000; speed.value = 1;\n      showGrid.checked = true; showSin.checked = true; showCos.checked = true;\n      // update state\n      state.A = 1; state.f = 1; state.phiDeg = 0; state.D = 0;\n      state.x0 = -6.28; state.x1 = 6.28; state.N = 1000; state.speed = 1;\n      state.showGrid = true; state.showSin = true; state.showCos = true;\n      updateUI();\n      draw();\n    });\n\n    exportBtn.addEventListener('click', ()=>{\n      // Export canvas as PNG\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      link.href = canvas.toDataURL('image/png');\n      link.click();\n    });\n\n    // --- Drawing helpers ---\n    function clearBG(){\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n    }\n\n    function drawGrid(xToPx, yToPx, pxToX, pxToY, left, top, right, bottom){\n      if(!state.showGrid) return;\n      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');\n      ctx.lineWidth = 1;\n      // vertical grid lines (x ticks)\n      const xRange = state.x1 - state.x0;\n      // choose nice step in x (approx 8-12 vertical lines)\n      let approx = xRange / 10;\n      const pow = Math.pow(10, Math.floor(Math.log10(approx)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      ctx.beginPath();\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // horizontal grid lines (y ticks)\n      // estimate y range from amplitude and vertical shift\n      const yAbs = Math.max(1, Math.abs(state.A) + Math.abs(state.D));\n      const yRange = Math.max(2*yAbs, 10);\n      // choose step\n      let yStep = 1;\n      ctx.beginPath();\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n    }\n\n    function drawAxes(xToPx, yToPx, left, top, right, bottom){\n      ctx.lineWidth = 1.5;\n      ctx.strokeStyle = '#222';\n      // x axis (y=0)\n      const py0 = yToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(left, py0);\n      ctx.lineTo(right, py0);\n      ctx.stroke();\n\n      // y axis (x=0)\n      const px0 = xToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(px0, top);\n      ctx.lineTo(px0, bottom);\n      ctx.stroke();\n\n      // ticks and labels\n      ctx.fillStyle = '#222';\n      ctx.font = '12px system-ui,Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      // x ticks\n      const xRange = state.x1 - state.x0;\n      const approx = xRange / 8;\n      const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(approx)||1)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.beginPath();\n        ctx.moveTo(px, yToPx(0)-6);\n        ctx.lineTo(px, yToPx(0)+6);\n        ctx.stroke();\n        ctx.fillText(formatNum(x,2), px, yToPx(0)+8);\n      }\n\n      // y ticks\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.beginPath();\n        ctx.moveTo(xToPx(0)-6, py);\n        ctx.lineTo(xToPx(0)+6, py);\n        ctx.stroke();\n        ctx.fillText(String(y), xToPx(0)-8, py);\n      }\n    }\n\n    function plotFunction(points, color, lineWidth=2){\n      if(points.length < 2) return;\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for(let i=1;i<points.length;i++){\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Convert between data x/y and pixel coords\n    function createTransform(width, height){\n      const margin = {left:60, right:20, top:20, bottom:40};\n      const left = margin.left, right = width - margin.right, top = margin.top, bottom = height - margin.bottom;\n      const x0 = state.x0, x1 = state.x1;\n      // estimate y range: use amplitude and vertical shift, but allow more space\n      const maxY = Math.max(2, Math.abs(state.A) + Math.abs(state.D) + 1);\n      const yMin = -maxY + state.D, yMax = maxY + state.D;\n      const yRange = yMax - yMin;\n      const xToPx = (x) => left + (x - x0) / (x1 - x0) * (right - left);\n      const yToPx = (y) => bottom - (y - yMin) / yRange * (bottom - top);\n      const pxToX = (px) => x0 + (px - left) / (right - left) * (x1 - x0);\n      const pxToY = (py) => {\n        const y = yMin + (bottom - py) / (bottom - top) * yRange;\n        return y;\n      };\n      return {left, right, top, bottom, xToPx, yToPx, pxToX, pxToY, yMin, yMax};\n    }\n\n    // Compute points for sin and cos\n    function computePoints(){\n      const ptsSin = [], ptsCos = [];\n      const N = Math.max(10, state.N);\n      const dx = (state.x1 - state.x0) / (N-1);\n      // angular frequency\n      const omega = 2 * Math.PI * state.f;\n      const phi = degToRad(state.phiDeg + state.t); // include animation as additional phase offset\n      for(let i=0;i<N;i++){\n        const x = state.x0 + dx * i;\n        const base = omega * x + phi;\n        const ys = state.A * Math.sin(base) + state.D;\n        const yc = state.A * Math.cos(base) + state.D;\n        ptsSin.push({x,y:ys});\n        ptsCos.push({x,y:yc});\n      }\n      return {ptsSin, ptsCos};\n    }\n\n    // Main draw\n    function draw(){\n      clearBG();\n      // pixel dims\n      const width = canvas.width / (window.devicePixelRatio || 1);\n      const height = canvas.height / (window.devicePixelRatio || 1);\n      const t = createTransform(width, height);\n      // draw grid\n      drawGrid(t.xToPx, t.yToPx, t.pxToX, t.pxToY, t.left, t.top, t.right, t.bottom);\n      // draw axes\n      drawAxes(t.xToPx, t.yToPx, t.left, t.top, t.right, t.bottom);\n\n      // compute real points and draw\n      const {ptsSin, ptsCos} = computePoints();\n      // transform to pixel coords\n      const sinPx = ptsSin.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n      const cosPx = ptsCos.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n\n      if(state.showSin){\n        plotFunction(sinPx, getComputedStyle(document.documentElement).getPropertyValue('--sin'), 2.5);\n      }\n      if(state.showCos){\n        plotFunction(cosPx, getComputedStyle(document.documentElement).getPropertyValue('--cos'), 2.5);\n      }\n\n      // draw border\n      ctx.strokeStyle = '#e8eef8';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(t.left - 0.5, t.top - 0.5, t.right - t.left + 1, t.bottom - t.top + 1);\n    }\n\n    // --- Animation ---\n    let animating = false;\n    let lastTime = 0;\n    function animate(ts){\n      if(!animating){ animating = true; lastTime = ts || performance.now(); }\n      if(!state.playing){\n        animating = false;\n        return;\n      }\n      const now = ts || performance.now();\n      const dt = (now - lastTime) / 1000; // seconds\n      lastTime = now;\n      // advance phase by speed * dt * 60 degrees per second (arbitrary choice)\n      state.t += state.speed * dt * 120; // degrees\n      draw();\n      requestAnimationFrame(animate);\n    }\n\n    // start/stop control ensures only one rAF loop\n    function startAnimation(){\n      if(!animating && state.playing) requestAnimationFrame(animate);\n    }\n\n    // Mouse interaction for tooltip\n    canvas.addEventListener('mousemove', (e)=>{\n      const rect = canvas.getBoundingClientRect();\n      const ratio = window.devicePixelRatio || 1;\n      const px = (e.clientX - rect.left);\n      const py = (e.clientY - rect.top);\n      // compute transforms\n      const width = canvas.width / ratio;\n      const height = canvas.height / ratio;\n      const t = createTransform(width, height);\n      const x = t.pxToX(px);\n      const yAt = (fn) => {\n        const omega = 2*Math.PI*state.f;\n        const phi = degToRad(state.phiDeg + state.t);\n        return state.A * (fn === 'sin' ? Math.sin(omega * x + phi) : Math.cos(omega * x + phi)) + state.D;\n      };\n      if(px < t.left || px > t.right || py < t.top || py > t.bottom){\n        tooltip.style.display = 'none';\n        return;\n      }\n      let text = `x=${formatNum(x,3)} `;\n      const lines = [];\n      if(state.showSin) lines.push(`sin=${formatNum(yAt('sin'),3)}`);\n      if(state.showCos) lines.push(`cos=${formatNum(yAt('cos'),3)}`);\n      text += lines.join(' , ');\n      tooltip.style.display = 'block';\n      tooltip.textContent = text;\n      // position tooltip\n      tooltip.style.left = (rect.left + px) + 'px';\n      tooltip.style.top = (rect.top + py) + 'px';\n    });\n    canvas.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; });\n\n    // initialize UI and draw once\n    updateUI();\n    draw();\n\n    // Start animation if playing toggled by user\n    // Use interval to advance even without rAF if paused? Already handled in animate.\n\n    // Accessibility: keyboard triggers for play/pause\n    document.addEventListener('keydown', (e)=>{\n      if(e.key === ' '){ // space toggles play/pause\n        e.preventDefault();\n        state.playing = !state.playing;\n        updateUI();\n        if(state.playing) startAnimation();\n      } else if(e.key === 'r'){ resetBtn.click(); }\n    });\n\n    // If user clicks play, start rAF\n    playBtn.addEventListener('click', startAnimation);\n\n    // Ensure draw updates while sliding knobs (some browsers fire input events continuously)\n    ['input','change'].forEach(evt=>{\n      [amplitude,frequency,phase,vshift,resolution,xstart,xend].forEach(inp=>{\n        inp.addEventListener(evt, ()=>{ draw(); });\n      });\n    });\n\n    // Prevent form submission when pressing enter on number inputs\n    [xstart,xend].forEach(inp=>{\n      inp.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){ e.preventDefault(); draw(); }\n      });\n    });\n\n    // Initial instructions in console (developers)\n    console.log('sin/cos 可视化已加载。快捷键: 空格 切换播放, r 重置。');\n  </script>",
                "css_content": ":root{\n      --bg:#f7f9fc;\n      --panel:#ffffff;\n      --muted:#666;\n      --accent:#0b6cff;\n      --sin:#e44d4d;\n      --cos:#3aa0c9;\n      --grid:#e0e6ef;\n    }\n    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:var(--bg);color:#111;display:flex;flex-direction:column;gap:12px;padding:14px;}\n    h1{margin:0;font-size:18px;}\n    .container{display:flex;gap:12px;align-items:flex-start;}\n    .left{flex:1;min-width:520px;background:var(--panel);border-radius:8px;padding:12px;box-shadow:0 1px 3px rgba(0,0,0,0.06);}\n    .right{width:360px;background:var(--panel);border-radius:8px;padding:12px;box-shadow:0 1px 3px rgba(0,0,0,0.06);}\n    canvas{width:100%;height:480px;background:linear-gradient(180deg,white, #fbfdff);border-radius:6px;display:block;}\n    .controls{display:grid;grid-template-columns:1fr 60px;gap:8px;align-items:center;margin-top:10px;}\n    .control-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;}\n    label{font-size:13px;color:var(--muted);min-width:90px;}\n    input[type=\"range\"]{width:100%;}\n    .small{font-size:12px;color:var(--muted);}\n    .legend{display:flex;gap:12px;align-items:center;margin-top:8px;}\n    .legend .item{display:flex;gap:6px;align-items:center;}\n    .swatch{width:18px;height:4px;border-radius:2px;}\n    .btn{background:var(--accent);color:white;padding:8px 10px;border-radius:6px;cursor:pointer;border:0;font-weight:600;}\n    .btn.secondary{background:#eef3ff;color:var(--accent);font-weight:600;border:0;cursor:pointer;}\n    .row{display:flex;gap:8px;align-items:center;}\n    .checkboxes{display:flex;gap:8px;align-items:center;}\n    .footer{font-size:12px;color:var(--muted);margin-top:8px;}\n    .eq{background:#f1f6ff;padding:8px;border-radius:6px;font-family:monospace;margin-top:8px;}\n    .tooltip{position:absolute;background:rgba(18,18,18,0.9);color:white;padding:6px 8px;border-radius:6px;font-size:12px;pointer-events:none;transform:translate(-50%,-120%);white-space:nowrap;z-index:20;}\n    input[type=\"number\"]{width:80px;padding:6px;border-radius:6px;border:1px solid #d7dbe8;background:white;}",
                "js_content": "// 三角函数可视化脚本\n    // 说明：将所有逻辑放在此文件中，使用 canvas 绘制并响应 UI 控件。\n\n    // --- 帮助函数 ---\n    function lerp(a,b,t){ return a + (b-a)*t; }\n    function degToRad(d){ return d * Math.PI / 180; }\n    function formatNum(v, precision=3){ return Number.parseFloat(v).toFixed(precision); }\n\n    // --- DOM ---\n    const canvas = document.getElementById('plot');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    const tooltip = document.getElementById('tooltip');\n\n    // Controls\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xstart = document.getElementById('xstart');\n    const xend = document.getElementById('xend');\n    const resolution = document.getElementById('resolution');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const showGrid = document.getElementById('showGrid');\n\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const resVal = document.getElementById('resVal');\n    const eqText = document.getElementById('equation');\n    const eqFull = document.getElementById('equationFull');\n\n    const playBtn = document.getElementById('playBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const animState = document.getElementById('animState');\n    const speed = document.getElementById('speed');\n    const speedVal = document.getElementById('speedVal');\n\n    const resetBtn = document.getElementById('resetBtn');\n    const exportBtn = document.getElementById('exportBtn');\n\n    // --- 状态 ---\n    let state = {\n      A: parseFloat(amplitude.value),\n      f: parseFloat(frequency.value),\n      phiDeg: parseFloat(phase.value),\n      D: parseFloat(vshift.value),\n      x0: parseFloat(xstart.value),\n      x1: parseFloat(xend.value),\n      N: parseInt(resolution.value),\n      t: 0,\n      playing: false,\n      speed: parseFloat(speed.value),\n      showGrid: showGrid.checked,\n      showSin: showSin.checked,\n      showCos: showCos.checked\n    };\n\n    // Canvas logical size handling for crispness\n    function resizeCanvas(){\n      const ratio = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.max(300, Math.floor(rect.width * ratio));\n      canvas.height = Math.max(200, Math.floor(rect.height * ratio));\n      ctx.setTransform(ratio,0,0,ratio,0,0); // scale drawing operations\n      draw();\n    }\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n\n    // Update UI labels\n    function updateUI(){\n      ampVal.textContent = state.A.toFixed(1);\n      freqVal.textContent = state.f.toFixed(1);\n      phaseVal.textContent = state.phiDeg.toFixed(0) + '°';\n      vshiftVal.textContent = state.D.toFixed(1);\n      resVal.textContent = state.N;\n      speedVal.textContent = state.speed.toFixed(1) + 'x';\n      eqText.textContent = `y = ${state.A} · sin(2π·${state.f}·x / 2π + ${state.phiDeg}°) + ${state.D}`;\n      eqFull.textContent = `sin: y = A·sin(ωx + φ) + D  （ω = 2πf）。 当前: A=${state.A}, f=${state.f}, φ=${state.phiDeg}°, D=${state.D}`;\n      animState.textContent = state.playing ? '播放中' : '停止';\n    }\n\n    // Attach input events\n    amplitude.addEventListener('input', ()=>{ state.A = parseFloat(amplitude.value); updateUI(); draw(); });\n    frequency.addEventListener('input', ()=>{ state.f = parseFloat(frequency.value); updateUI(); draw(); });\n    phase.addEventListener('input', ()=>{ state.phiDeg = parseFloat(phase.value); updateUI(); draw(); });\n    vshift.addEventListener('input', ()=>{ state.D = parseFloat(vshift.value); updateUI(); draw(); });\n    xstart.addEventListener('change', ()=>{ state.x0 = parseFloat(xstart.value); draw(); });\n    xend.addEventListener('change', ()=>{ state.x1 = parseFloat(xend.value); draw(); });\n    resolution.addEventListener('input', ()=>{ state.N = parseInt(resolution.value); updateUI(); draw(); });\n    showGrid.addEventListener('change', ()=>{ state.showGrid = showGrid.checked; draw(); });\n    showSin.addEventListener('change', ()=>{ state.showSin = showSin.checked; draw(); });\n    showCos.addEventListener('change', ()=>{ state.showCos = showCos.checked; draw(); });\n    speed.addEventListener('input', ()=>{ state.speed = parseFloat(speed.value); updateUI(); });\n\n    playBtn.addEventListener('click', ()=>{\n      state.playing = true;\n      updateUI();\n      if(!animating) animate();\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.playing = false;\n      updateUI();\n    });\n\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1; frequency.value = 1; phase.value = 0; vshift.value = 0;\n      xstart.value = -6.28; xend.value = 6.28; resolution.value = 1000; speed.value = 1;\n      showGrid.checked = true; showSin.checked = true; showCos.checked = true;\n      // update state\n      state.A = 1; state.f = 1; state.phiDeg = 0; state.D = 0;\n      state.x0 = -6.28; state.x1 = 6.28; state.N = 1000; state.speed = 1;\n      state.showGrid = true; state.showSin = true; state.showCos = true;\n      updateUI();\n      draw();\n    });\n\n    exportBtn.addEventListener('click', ()=>{\n      // Export canvas as PNG\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      link.href = canvas.toDataURL('image/png');\n      link.click();\n    });\n\n    // --- Drawing helpers ---\n    function clearBG(){\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n    }\n\n    function drawGrid(xToPx, yToPx, pxToX, pxToY, left, top, right, bottom){\n      if(!state.showGrid) return;\n      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');\n      ctx.lineWidth = 1;\n      // vertical grid lines (x ticks)\n      const xRange = state.x1 - state.x0;\n      // choose nice step in x (approx 8-12 vertical lines)\n      let approx = xRange / 10;\n      const pow = Math.pow(10, Math.floor(Math.log10(approx)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      ctx.beginPath();\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // horizontal grid lines (y ticks)\n      // estimate y range from amplitude and vertical shift\n      const yAbs = Math.max(1, Math.abs(state.A) + Math.abs(state.D));\n      const yRange = Math.max(2*yAbs, 10);\n      // choose step\n      let yStep = 1;\n      ctx.beginPath();\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n    }\n\n    function drawAxes(xToPx, yToPx, left, top, right, bottom){\n      ctx.lineWidth = 1.5;\n      ctx.strokeStyle = '#222';\n      // x axis (y=0)\n      const py0 = yToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(left, py0);\n      ctx.lineTo(right, py0);\n      ctx.stroke();\n\n      // y axis (x=0)\n      const px0 = xToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(px0, top);\n      ctx.lineTo(px0, bottom);\n      ctx.stroke();\n\n      // ticks and labels\n      ctx.fillStyle = '#222';\n      ctx.font = '12px system-ui,Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      // x ticks\n      const xRange = state.x1 - state.x0;\n      const approx = xRange / 8;\n      const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(approx)||1)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.beginPath();\n        ctx.moveTo(px, yToPx(0)-6);\n        ctx.lineTo(px, yToPx(0)+6);\n        ctx.stroke();\n        ctx.fillText(formatNum(x,2), px, yToPx(0)+8);\n      }\n\n      // y ticks\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.beginPath();\n        ctx.moveTo(xToPx(0)-6, py);\n        ctx.lineTo(xToPx(0)+6, py);\n        ctx.stroke();\n        ctx.fillText(String(y), xToPx(0)-8, py);\n      }\n    }\n\n    function plotFunction(points, color, lineWidth=2){\n      if(points.length < 2) return;\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for(let i=1;i<points.length;i++){\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Convert between data x/y and pixel coords\n    function createTransform(width, height){\n      const margin = {left:60, right:20, top:20, bottom:40};\n      const left = margin.left, right = width - margin.right, top = margin.top, bottom = height - margin.bottom;\n      const x0 = state.x0, x1 = state.x1;\n      // estimate y range: use amplitude and vertical shift, but allow more space\n      const maxY = Math.max(2, Math.abs(state.A) + Math.abs(state.D) + 1);\n      const yMin = -maxY + state.D, yMax = maxY + state.D;\n      const yRange = yMax - yMin;\n      const xToPx = (x) => left + (x - x0) / (x1 - x0) * (right - left);\n      const yToPx = (y) => bottom - (y - yMin) / yRange * (bottom - top);\n      const pxToX = (px) => x0 + (px - left) / (right - left) * (x1 - x0);\n      const pxToY = (py) => {\n        const y = yMin + (bottom - py) / (bottom - top) * yRange;\n        return y;\n      };\n      return {left, right, top, bottom, xToPx, yToPx, pxToX, pxToY, yMin, yMax};\n    }\n\n    // Compute points for sin and cos\n    function computePoints(){\n      const ptsSin = [], ptsCos = [];\n      const N = Math.max(10, state.N);\n      const dx = (state.x1 - state.x0) / (N-1);\n      // angular frequency\n      const omega = 2 * Math.PI * state.f;\n      const phi = degToRad(state.phiDeg + state.t); // include animation as additional phase offset\n      for(let i=0;i<N;i++){\n        const x = state.x0 + dx * i;\n        const base = omega * x + phi;\n        const ys = state.A * Math.sin(base) + state.D;\n        const yc = state.A * Math.cos(base) + state.D;\n        ptsSin.push({x,y:ys});\n        ptsCos.push({x,y:yc});\n      }\n      return {ptsSin, ptsCos};\n    }\n\n    // Main draw\n    function draw(){\n      clearBG();\n      // pixel dims\n      const width = canvas.width / (window.devicePixelRatio || 1);\n      const height = canvas.height / (window.devicePixelRatio || 1);\n      const t = createTransform(width, height);\n      // draw grid\n      drawGrid(t.xToPx, t.yToPx, t.pxToX, t.pxToY, t.left, t.top, t.right, t.bottom);\n      // draw axes\n      drawAxes(t.xToPx, t.yToPx, t.left, t.top, t.right, t.bottom);\n\n      // compute real points and draw\n      const {ptsSin, ptsCos} = computePoints();\n      // transform to pixel coords\n      const sinPx = ptsSin.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n      const cosPx = ptsCos.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n\n      if(state.showSin){\n        plotFunction(sinPx, getComputedStyle(document.documentElement).getPropertyValue('--sin'), 2.5);\n      }\n      if(state.showCos){\n        plotFunction(cosPx, getComputedStyle(document.documentElement).getPropertyValue('--cos'), 2.5);\n      }\n\n      // draw border\n      ctx.strokeStyle = '#e8eef8';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(t.left - 0.5, t.top - 0.5, t.right - t.left + 1, t.bottom - t.top + 1);\n    }\n\n    // --- Animation ---\n    let animating = false;\n    let lastTime = 0;\n    function animate(ts){\n      if(!animating){ animating = true; lastTime = ts || performance.now(); }\n      if(!state.playing){\n        animating = false;\n        return;\n      }\n      const now = ts || performance.now();\n      const dt = (now - lastTime) / 1000; // seconds\n      lastTime = now;\n      // advance phase by speed * dt * 60 degrees per second (arbitrary choice)\n      state.t += state.speed * dt * 120; // degrees\n      draw();\n      requestAnimationFrame(animate);\n    }\n\n    // start/stop control ensures only one rAF loop\n    function startAnimation(){\n      if(!animating && state.playing) requestAnimationFrame(animate);\n    }\n\n    // Mouse interaction for tooltip\n    canvas.addEventListener('mousemove', (e)=>{\n      const rect = canvas.getBoundingClientRect();\n      const ratio = window.devicePixelRatio || 1;\n      const px = (e.clientX - rect.left);\n      const py = (e.clientY - rect.top);\n      // compute transforms\n      const width = canvas.width / ratio;\n      const height = canvas.height / ratio;\n      const t = createTransform(width, height);\n      const x = t.pxToX(px);\n      const yAt = (fn) => {\n        const omega = 2*Math.PI*state.f;\n        const phi = degToRad(state.phiDeg + state.t);\n        return state.A * (fn === 'sin' ? Math.sin(omega * x + phi) : Math.cos(omega * x + phi)) + state.D;\n      };\n      if(px < t.left || px > t.right || py < t.top || py > t.bottom){\n        tooltip.style.display = 'none';\n        return;\n      }\n      let text = `x=${formatNum(x,3)} `;\n      const lines = [];\n      if(state.showSin) lines.push(`sin=${formatNum(yAt('sin'),3)}`);\n      if(state.showCos) lines.push(`cos=${formatNum(yAt('cos'),3)}`);\n      text += lines.join(' , ');\n      tooltip.style.display = 'block';\n      tooltip.textContent = text;\n      // position tooltip\n      tooltip.style.left = (rect.left + px) + 'px';\n      tooltip.style.top = (rect.top + py) + 'px';\n    });\n    canvas.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; });\n\n    // initialize UI and draw once\n    updateUI();\n    draw();\n\n    // Start animation if playing toggled by user\n    // Use interval to advance even without rAF if paused? Already handled in animate.\n\n    // Accessibility: keyboard triggers for play/pause\n    document.addEventListener('keydown', (e)=>{\n      if(e.key === ' '){ // space toggles play/pause\n        e.preventDefault();\n        state.playing = !state.playing;\n        updateUI();\n        if(state.playing) startAnimation();\n      } else if(e.key === 'r'){ resetBtn.click(); }\n    });\n\n    // If user clicks play, start rAF\n    playBtn.addEventListener('click', startAnimation);\n\n    // Ensure draw updates while sliding knobs (some browsers fire input events continuously)\n    ['input','change'].forEach(evt=>{\n      [amplitude,frequency,phase,vshift,resolution,xstart,xend].forEach(inp=>{\n        inp.addEventListener(evt, ()=>{ draw(); });\n      });\n    });\n\n    // Prevent form submission when pressing enter on number inputs\n    [xstart,xend].forEach(inp=>{\n      inp.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){ e.preventDefault(); draw(); }\n      });\n    });\n\n    // Initial instructions in console (developers)\n    console.log('sin/cos 可视化已加载。快捷键: 空格 切换播放, r 重置。');",
                "parameters": [],
                "status": "success"
              },
              "attempts": 2
            },
            "rawData": "{\"success\":true,\"data\":{\"experiment_id\":\"aedb0293-4a9d-4317-b277-9d6634fc172f\",\"title\":\"sin / cos 函数可视化工具\",\"description\":\"摘要（基于 Perplexity AI 的信息）:\\n- sin 与 cos 是周期性三角函数，常用参数包括振幅（A）、角频率/频率（ω 或 f）、相位（φ）和纵向平移（D）。函数形式常写为 y = A * sin(ωx + φ) + D 或 y = A * cos(ωx + φ) + D。周期为 T = 2π/ω（或以 f 表示频率，则 ω = 2πf）。这些概念将用于交互可视化（来源：Perplexity AI）。\\n- 下方 HTML 示例是自包含的、无外部依赖的交互式函数可视化工具，可绘制并动态调整 sin 和 cos 曲线的参数，并具有动画、导出图片和鼠标提示等功能。\\n\\n完整可运行 HTML（保存为 .html 并在浏览器打开）：\",\"html_content\":\"<header style=\\\"display:flex;justify-content:space-between;align-items:center;\\\">\\n    <div>\\n      <h1>三角函数可视化工具 — sin & cos</h1>\\n      <div class=\\\"small\\\">调整参数查看曲线变化。支持动画、导出图片与鼠标读取数值。</div>\\n    </div>\\n    <div style=\\\"text-align:right\\\" class=\\\"small\\\">来源: Perplexity AI（概念摘要）</div>\\n  </header>\\n\\n  <div class=\\\"container\\\">\\n    <div class=\\\"left\\\" aria-label=\\\"Canvas area\\\">\\n      <div style=\\\"position:relative;\\\">\\n        <canvas id=\\\"plot\\\" width=\\\"1000\\\" height=\\\"600\\\" role=\\\"img\\\" aria-label=\\\"函数绘图\\\"></canvas>\\n        <div id=\\\"tooltip\\\" class=\\\"tooltip\\\" style=\\\"display:none\\\"></div>\\n      </div>\\n      <div class=\\\"legend\\\" aria-hidden=\\\"false\\\">\\n        <div class=\\\"item\\\"><div class=\\\"swatch\\\" style=\\\"background:var(--sin)\\\"></div><div class=\\\"small\\\">y = A·sin(ωx + φ) + D</div></div>\\n        <div class=\\\"item\\\"><div class=\\\"swatch\\\" style=\\\"background:var(--cos)\\\"></div><div class=\\\"small\\\">y = A·cos(ωx + φ) + D</div></div>\\n      </div>\\n      <div class=\\\"eq\\\" id=\\\"equation\\\">y = 1·sin(1·x + 0°) + 0</div>\\n      <div class=\\\"footer\\\">提示：移动鼠标在画布上可查看具体坐标（x, y）。</div>\\n    </div>\\n\\n    <aside class=\\\"right\\\" aria-label=\\\"Controls\\\">\\n      <div style=\\\"display:flex;gap:8px;align-items:center;justify-content:space-between;\\\">\\n        <div style=\\\"font-weight:600\\\">参数</div>\\n        <div class=\\\"row\\\">\\n          <button class=\\\"btn secondary\\\" id=\\\"resetBtn\\\">重置</button>\\n          <button class=\\\"btn\\\" id=\\\"exportBtn\\\" title=\\\"导出为 PNG\\\">导出 PNG</button>\\n        </div>\\n      </div>\\n\\n      <div style=\\\"margin-top:8px;\\\">\\n        <div class=\\\"control-row\\\">\\n          <label for=\\\"amplitude\\\">振幅 A</label>\\n          <input id=\\\"amplitude\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"5\\\" step=\\\"0.1\\\" value=\\\"1\\\" />\\n          <div style=\\\"width:60px;text-align:right\\\" id=\\\"ampVal\\\">1.0</div>\\n        </div>\\n\\n        <div class=\\\"control-row\\\">\\n          <label for=\\\"frequency\\\">频率 f</label>\\n          <input id=\\\"frequency\\\" type=\\\"range\\\" min=\\\"0.1\\\" max=\\\"5\\\" step=\\\"0.1\\\" value=\\\"1\\\" />\\n          <div style=\\\"width:60px;text-align:right\\\" id=\\\"freqVal\\\">1.0</div>\\n        </div>\\n\\n        <div class=\\\"control-row\\\">\\n          <label for=\\\"phase\\\">相位 φ (°)</label>\\n          <input id=\\\"phase\\\" type=\\\"range\\\" min=\\\"-360\\\" max=\\\"360\\\" step=\\\"1\\\" value=\\\"0\\\" />\\n          <div style=\\\"width:60px;text-align:right\\\" id=\\\"phaseVal\\\">0°</div>\\n        </div>\\n\\n        <div class=\\\"control-row\\\">\\n          <label for=\\\"vshift\\\">纵移 D</label>\\n          <input id=\\\"vshift\\\" type=\\\"range\\\" min=\\\"-5\\\" max=\\\"5\\\" step=\\\"0.1\\\" value=\\\"0\\\" />\\n          <div style=\\\"width:60px;text-align:right\\\" id=\\\"vshiftVal\\\">0.0</div>\\n        </div>\\n\\n        <div class=\\\"control-row\\\">\\n          <label for=\\\"xstart\\\">x 范围</label>\\n          <div style=\\\"display:flex;gap:6px;align-items:center;\\\">\\n            <input id=\\\"xstart\\\" type=\\\"number\\\" step=\\\"0.1\\\" value=\\\"-6.28\\\" aria-label=\\\"x start\\\" />\\n            <span style=\\\"color:var(--muted)\\\">到</span>\\n            <input id=\\\"xend\\\" type=\\\"number\\\" step=\\\"0.1\\\" value=\\\"6.28\\\" aria-label=\\\"x end\\\" />\\n          </div>\\n        </div>\\n\\n        <div class=\\\"control-row\\\">\\n          <label for=\\\"resolution\\\">采样点</label>\\n          <input id=\\\"resolution\\\" type=\\\"range\\\" min=\\\"100\\\" max=\\\"4000\\\" step=\\\"50\\\" value=\\\"1000\\\" />\\n          <div style=\\\"width:60px;text-align:right\\\" id=\\\"resVal\\\">1000</div>\\n        </div>\\n\\n        <div style=\\\"margin-top:8px;\\\">\\n          <div class=\\\"checkboxes\\\" role=\\\"group\\\" aria-label=\\\"显示选项\\\">\\n            <label><input id=\\\"showSin\\\" type=\\\"checkbox\\\" checked /> sin</label>\\n            <label><input id=\\\"showCos\\\" type=\\\"checkbox\\\" checked /> cos</label>\\n            <label><input id=\\\"showGrid\\\" type=\\\"checkbox\\\" checked /> 网格</label>\\n          </div>\\n        </div>\\n\\n        <hr style=\\\"margin:12px 0\\\" />\\n\\n        <div style=\\\"display:flex;align-items:center;justify-content:space-between;\\\">\\n          <div style=\\\"font-weight:600\\\">动画</div>\\n          <div class=\\\"small\\\" id=\\\"animState\\\">停止</div>\\n        </div>\\n\\n        <div style=\\\"margin-top:8px;\\\">\\n          <div class=\\\"control-row\\\">\\n            <label for=\\\"animate\\\">播放</label>\\n            <button id=\\\"playBtn\\\" class=\\\"btn secondary\\\">播放</button>\\n            <button id=\\\"pauseBtn\\\" class=\\\"btn secondary\\\">暂停</button>\\n          </div>\\n\\n          <div class=\\\"control-row\\\">\\n            <label for=\\\"speed\\\">速度</label>\\n            <input id=\\\"speed\\\" type=\\\"range\\\" min=\\\"-4\\\" max=\\\"4\\\" step=\\\"0.1\\\" value=\\\"1\\\" />\\n            <div style=\\\"width:60px;text-align:right\\\" id=\\\"speedVal\\\">1.0x</div>\\n          </div>\\n        </div>\\n\\n        <div style=\\\"margin-top:12px;\\\">\\n          <div class=\\\"small\\\">方程</div>\\n          <div class=\\\"eq\\\" id=\\\"equationFull\\\">sin: y = A·sin(ωx + φ) + D  （ω = 2πf）</div>\\n        </div>\\n      </div>\\n    </aside>\\n  </div>\\n\\n  <script>\\n    // 三角函数可视化脚本\\n    // 说明：将所有逻辑放在此文件中，使用 canvas 绘制并响应 UI 控件。\\n\\n    // --- 帮助函数 ---\\n    function lerp(a,b,t){ return a + (b-a)*t; }\\n    function degToRad(d){ return d * Math.PI / 180; }\\n    function formatNum(v, precision=3){ return Number.parseFloat(v).toFixed(precision); }\\n\\n    // --- DOM ---\\n    const canvas = document.getElementById('plot');\\n    const ctx = canvas.getContext('2d', { alpha: false });\\n    const tooltip = document.getElementById('tooltip');\\n\\n    // Controls\\n    const amplitude = document.getElementById('amplitude');\\n    const frequency = document.getElementById('frequency');\\n    const phase = document.getElementById('phase');\\n    const vshift = document.getElementById('vshift');\\n    const xstart = document.getElementById('xstart');\\n    const xend = document.getElementById('xend');\\n    const resolution = document.getElementById('resolution');\\n    const showSin = document.getElementById('showSin');\\n    const showCos = document.getElementById('showCos');\\n    const showGrid = document.getElementById('showGrid');\\n\\n    const ampVal = document.getElementById('ampVal');\\n    const freqVal = document.getElementById('freqVal');\\n    const phaseVal = document.getElementById('phaseVal');\\n    const vshiftVal = document.getElementById('vshiftVal');\\n    const resVal = document.getElementById('resVal');\\n    const eqText = document.getElementById('equation');\\n    const eqFull = document.getElementById('equationFull');\\n\\n    const playBtn = document.getElementById('playBtn');\\n    const pauseBtn = document.getElementById('pauseBtn');\\n    const animState = document.getElementById('animState');\\n    const speed = document.getElementById('speed');\\n    const speedVal = document.getElementById('speedVal');\\n\\n    const resetBtn = document.getElementById('resetBtn');\\n    const exportBtn = document.getElementById('exportBtn');\\n\\n    // --- 状态 ---\\n    let state = {\\n      A: parseFloat(amplitude.value),\\n      f: parseFloat(frequency.value),\\n      phiDeg: parseFloat(phase.value),\\n      D: parseFloat(vshift.value),\\n      x0: parseFloat(xstart.value),\\n      x1: parseFloat(xend.value),\\n      N: parseInt(resolution.value),\\n      t: 0,\\n      playing: false,\\n      speed: parseFloat(speed.value),\\n      showGrid: showGrid.checked,\\n      showSin: showSin.checked,\\n      showCos: showCos.checked\\n    };\\n\\n    // Canvas logical size handling for crispness\\n    function resizeCanvas(){\\n      const ratio = window.devicePixelRatio || 1;\\n      const rect = canvas.getBoundingClientRect();\\n      canvas.width = Math.max(300, Math.floor(rect.width * ratio));\\n      canvas.height = Math.max(200, Math.floor(rect.height * ratio));\\n      ctx.setTransform(ratio,0,0,ratio,0,0); // scale drawing operations\\n      draw();\\n    }\\n    window.addEventListener('resize', resizeCanvas);\\n    resizeCanvas();\\n\\n    // Update UI labels\\n    function updateUI(){\\n      ampVal.textContent = state.A.toFixed(1);\\n      freqVal.textContent = state.f.toFixed(1);\\n      phaseVal.textContent = state.phiDeg.toFixed(0) + '°';\\n      vshiftVal.textContent = state.D.toFixed(1);\\n      resVal.textContent = state.N;\\n      speedVal.textContent = state.speed.toFixed(1) + 'x';\\n      eqText.textContent = `y = ${state.A} · sin(2π·${state.f}·x / 2π + ${state.phiDeg}°) + ${state.D}`;\\n      eqFull.textContent = `sin: y = A·sin(ωx + φ) + D  （ω = 2πf）。 当前: A=${state.A}, f=${state.f}, φ=${state.phiDeg}°, D=${state.D}`;\\n      animState.textContent = state.playing ? '播放中' : '停止';\\n    }\\n\\n    // Attach input events\\n    amplitude.addEventListener('input', ()=>{ state.A = parseFloat(amplitude.value); updateUI(); draw(); });\\n    frequency.addEventListener('input', ()=>{ state.f = parseFloat(frequency.value); updateUI(); draw(); });\\n    phase.addEventListener('input', ()=>{ state.phiDeg = parseFloat(phase.value); updateUI(); draw(); });\\n    vshift.addEventListener('input', ()=>{ state.D = parseFloat(vshift.value); updateUI(); draw(); });\\n    xstart.addEventListener('change', ()=>{ state.x0 = parseFloat(xstart.value); draw(); });\\n    xend.addEventListener('change', ()=>{ state.x1 = parseFloat(xend.value); draw(); });\\n    resolution.addEventListener('input', ()=>{ state.N = parseInt(resolution.value); updateUI(); draw(); });\\n    showGrid.addEventListener('change', ()=>{ state.showGrid = showGrid.checked; draw(); });\\n    showSin.addEventListener('change', ()=>{ state.showSin = showSin.checked; draw(); });\\n    showCos.addEventListener('change', ()=>{ state.showCos = showCos.checked; draw(); });\\n    speed.addEventListener('input', ()=>{ state.speed = parseFloat(speed.value); updateUI(); });\\n\\n    playBtn.addEventListener('click', ()=>{\\n      state.playing = true;\\n      updateUI();\\n      if(!animating) animate();\\n    });\\n    pauseBtn.addEventListener('click', ()=>{\\n      state.playing = false;\\n      updateUI();\\n    });\\n\\n    resetBtn.addEventListener('click', ()=>{\\n      amplitude.value = 1; frequency.value = 1; phase.value = 0; vshift.value = 0;\\n      xstart.value = -6.28; xend.value = 6.28; resolution.value = 1000; speed.value = 1;\\n      showGrid.checked = true; showSin.checked = true; showCos.checked = true;\\n      // update state\\n      state.A = 1; state.f = 1; state.phiDeg = 0; state.D = 0;\\n      state.x0 = -6.28; state.x1 = 6.28; state.N = 1000; state.speed = 1;\\n      state.showGrid = true; state.showSin = true; state.showCos = true;\\n      updateUI();\\n      draw();\\n    });\\n\\n    exportBtn.addEventListener('click', ()=>{\\n      // Export canvas as PNG\\n      const link = document.createElement('a');\\n      link.download = 'sin_cos_plot.png';\\n      link.href = canvas.toDataURL('image/png');\\n      link.click();\\n    });\\n\\n    // --- Drawing helpers ---\\n    function clearBG(){\\n      ctx.fillStyle = '#ffffff';\\n      ctx.fillRect(0,0,canvas.width,canvas.height);\\n    }\\n\\n    function drawGrid(xToPx, yToPx, pxToX, pxToY, left, top, right, bottom){\\n      if(!state.showGrid) return;\\n      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');\\n      ctx.lineWidth = 1;\\n      // vertical grid lines (x ticks)\\n      const xRange = state.x1 - state.x0;\\n      // choose nice step in x (approx 8-12 vertical lines)\\n      let approx = xRange / 10;\\n      const pow = Math.pow(10, Math.floor(Math.log10(approx)));\\n      let step = pow;\\n      if(approx / pow < 1.5) step = pow / 2;\\n      else if(approx / pow < 3) step = pow;\\n      else step = pow * 2;\\n      ctx.beginPath();\\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\\n        const px = xToPx(x);\\n        ctx.moveTo(px, top);\\n        ctx.lineTo(px, bottom);\\n      }\\n      ctx.stroke();\\n\\n      // horizontal grid lines (y ticks)\\n      // estimate y range from amplitude and vertical shift\\n      const yAbs = Math.max(1, Math.abs(state.A) + Math.abs(state.D));\\n      const yRange = Math.max(2*yAbs, 10);\\n      // choose step\\n      let yStep = 1;\\n      ctx.beginPath();\\n      for(let y = -10; y <= 10; y += 1){\\n        const py = yToPx(y);\\n        ctx.moveTo(left, py);\\n        ctx.lineTo(right, py);\\n      }\\n      ctx.stroke();\\n    }\\n\\n    function drawAxes(xToPx, yToPx, left, top, right, bottom){\\n      ctx.lineWidth = 1.5;\\n      ctx.strokeStyle = '#222';\\n      // x axis (y=0)\\n      const py0 = yToPx(0);\\n      ctx.beginPath();\\n      ctx.moveTo(left, py0);\\n      ctx.lineTo(right, py0);\\n      ctx.stroke();\\n\\n      // y axis (x=0)\\n      const px0 = xToPx(0);\\n      ctx.beginPath();\\n      ctx.moveTo(px0, top);\\n      ctx.lineTo(px0, bottom);\\n      ctx.stroke();\\n\\n      // ticks and labels\\n      ctx.fillStyle = '#222';\\n      ctx.font = '12px system-ui,Arial';\\n      ctx.textAlign = 'center';\\n      ctx.textBaseline = 'top';\\n      // x ticks\\n      const xRange = state.x1 - state.x0;\\n      const approx = xRange / 8;\\n      const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(approx)||1)));\\n      let step = pow;\\n      if(approx / pow < 1.5) step = pow / 2;\\n      else if(approx / pow < 3) step = pow;\\n      else step = pow * 2;\\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\\n        const px = xToPx(x);\\n        ctx.beginPath();\\n        ctx.moveTo(px, yToPx(0)-6);\\n        ctx.lineTo(px, yToPx(0)+6);\\n        ctx.stroke();\\n        ctx.fillText(formatNum(x,2), px, yToPx(0)+8);\\n      }\\n\\n      // y ticks\\n      ctx.textAlign = 'right';\\n      ctx.textBaseline = 'middle';\\n      for(let y = -10; y <= 10; y += 1){\\n        const py = yToPx(y);\\n        ctx.beginPath();\\n        ctx.moveTo(xToPx(0)-6, py);\\n        ctx.lineTo(xToPx(0)+6, py);\\n        ctx.stroke();\\n        ctx.fillText(String(y), xToPx(0)-8, py);\\n      }\\n    }\\n\\n    function plotFunction(points, color, lineWidth=2){\\n      if(points.length < 2) return;\\n      ctx.beginPath();\\n      ctx.moveTo(points[0].x, points[0].y);\\n      for(let i=1;i<points.length;i++){\\n        ctx.lineTo(points[i].x, points[i].y);\\n      }\\n      ctx.strokeStyle = color;\\n      ctx.lineWidth = lineWidth;\\n      ctx.lineJoin = 'round';\\n      ctx.lineCap = 'round';\\n      ctx.stroke();\\n    }\\n\\n    // Convert between data x/y and pixel coords\\n    function createTransform(width, height){\\n      const margin = {left:60, right:20, top:20, bottom:40};\\n      const left = margin.left, right = width - margin.right, top = margin.top, bottom = height - margin.bottom;\\n      const x0 = state.x0, x1 = state.x1;\\n      // estimate y range: use amplitude and vertical shift, but allow more space\\n      const maxY = Math.max(2, Math.abs(state.A) + Math.abs(state.D) + 1);\\n      const yMin = -maxY + state.D, yMax = maxY + state.D;\\n      const yRange = yMax - yMin;\\n      const xToPx = (x) => left + (x - x0) / (x1 - x0) * (right - left);\\n      const yToPx = (y) => bottom - (y - yMin) / yRange * (bottom - top);\\n      const pxToX = (px) => x0 + (px - left) / (right - left) * (x1 - x0);\\n      const pxToY = (py) => {\\n        const y = yMin + (bottom - py) / (bottom - top) * yRange;\\n        return y;\\n      };\\n      return {left, right, top, bottom, xToPx, yToPx, pxToX, pxToY, yMin, yMax};\\n    }\\n\\n    // Compute points for sin and cos\\n    function computePoints(){\\n      const ptsSin = [], ptsCos = [];\\n      const N = Math.max(10, state.N);\\n      const dx = (state.x1 - state.x0) / (N-1);\\n      // angular frequency\\n      const omega = 2 * Math.PI * state.f;\\n      const phi = degToRad(state.phiDeg + state.t); // include animation as additional phase offset\\n      for(let i=0;i<N;i++){\\n        const x = state.x0 + dx * i;\\n        const base = omega * x + phi;\\n        const ys = state.A * Math.sin(base) + state.D;\\n        const yc = state.A * Math.cos(base) + state.D;\\n        ptsSin.push({x,y:ys});\\n        ptsCos.push({x,y:yc});\\n      }\\n      return {ptsSin, ptsCos};\\n    }\\n\\n    // Main draw\\n    function draw(){\\n      clearBG();\\n      // pixel dims\\n      const width = canvas.width / (window.devicePixelRatio || 1);\\n      const height = canvas.height / (window.devicePixelRatio || 1);\\n      const t = createTransform(width, height);\\n      // draw grid\\n      drawGrid(t.xToPx, t.yToPx, t.pxToX, t.pxToY, t.left, t.top, t.right, t.bottom);\\n      // draw axes\\n      drawAxes(t.xToPx, t.yToPx, t.left, t.top, t.right, t.bottom);\\n\\n      // compute real points and draw\\n      const {ptsSin, ptsCos} = computePoints();\\n      // transform to pixel coords\\n      const sinPx = ptsSin.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\\n      const cosPx = ptsCos.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\\n\\n      if(state.showSin){\\n        plotFunction(sinPx, getComputedStyle(document.documentElement).getPropertyValue('--sin'), 2.5);\\n      }\\n      if(state.showCos){\\n        plotFunction(cosPx, getComputedStyle(document.documentElement).getPropertyValue('--cos'), 2.5);\\n      }\\n\\n      // draw border\\n      ctx.strokeStyle = '#e8eef8';\\n      ctx.lineWidth = 1;\\n      ctx.strokeRect(t.left - 0.5, t.top - 0.5, t.right - t.left + 1, t.bottom - t.top + 1);\\n    }\\n\\n    // --- Animation ---\\n    let animating = false;\\n    let lastTime = 0;\\n    function animate(ts){\\n      if(!animating){ animating = true; lastTime = ts || performance.now(); }\\n      if(!state.playing){\\n        animating = false;\\n        return;\\n      }\\n      const now = ts || performance.now();\\n      const dt = (now - lastTime) / 1000; // seconds\\n      lastTime = now;\\n      // advance phase by speed * dt * 60 degrees per second (arbitrary choice)\\n      state.t += state.speed * dt * 120; // degrees\\n      draw();\\n      requestAnimationFrame(animate);\\n    }\\n\\n    // start/stop control ensures only one rAF loop\\n    function startAnimation(){\\n      if(!animating && state.playing) requestAnimationFrame(animate);\\n    }\\n\\n    // Mouse interaction for tooltip\\n    canvas.addEventListener('mousemove', (e)=>{\\n      const rect = canvas.getBoundingClientRect();\\n      const ratio = window.devicePixelRatio || 1;\\n      const px = (e.clientX - rect.left);\\n      const py = (e.clientY - rect.top);\\n      // compute transforms\\n      const width = canvas.width / ratio;\\n      const height = canvas.height / ratio;\\n      const t = createTransform(width, height);\\n      const x = t.pxToX(px);\\n      const yAt = (fn) => {\\n        const omega = 2*Math.PI*state.f;\\n        const phi = degToRad(state.phiDeg + state.t);\\n        return state.A * (fn === 'sin' ? Math.sin(omega * x + phi) : Math.cos(omega * x + phi)) + state.D;\\n      };\\n      if(px < t.left || px > t.right || py < t.top || py > t.bottom){\\n        tooltip.style.display = 'none';\\n        return;\\n      }\\n      let text = `x=${formatNum(x,3)} `;\\n      const lines = [];\\n      if(state.showSin) lines.push(`sin=${formatNum(yAt('sin'),3)}`);\\n      if(state.showCos) lines.push(`cos=${formatNum(yAt('cos'),3)}`);\\n      text += lines.join(' , ');\\n      tooltip.style.display = 'block';\\n      tooltip.textContent = text;\\n      // position tooltip\\n      tooltip.style.left = (rect.left + px) + 'px';\\n      tooltip.style.top = (rect.top + py) + 'px';\\n    });\\n    canvas.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; });\\n\\n    // initialize UI and draw once\\n    updateUI();\\n    draw();\\n\\n    // Start animation if playing toggled by user\\n    // Use interval to advance even without rAF if paused? Already handled in animate.\\n\\n    // Accessibility: keyboard triggers for play/pause\\n    document.addEventListener('keydown', (e)=>{\\n      if(e.key === ' '){ // space toggles play/pause\\n        e.preventDefault();\\n        state.playing = !state.playing;\\n        updateUI();\\n        if(state.playing) startAnimation();\\n      } else if(e.key === 'r'){ resetBtn.click(); }\\n    });\\n\\n    // If user clicks play, start rAF\\n    playBtn.addEventListener('click', startAnimation);\\n\\n    // Ensure draw updates while sliding knobs (some browsers fire input events continuously)\\n    ['input','change'].forEach(evt=>{\\n      [amplitude,frequency,phase,vshift,resolution,xstart,xend].forEach(inp=>{\\n        inp.addEventListener(evt, ()=>{ draw(); });\\n      });\\n    });\\n\\n    // Prevent form submission when pressing enter on number inputs\\n    [xstart,xend].forEach(inp=>{\\n      inp.addEventListener('keydown', (e)=>{\\n        if(e.key === 'Enter'){ e.preventDefault(); draw(); }\\n      });\\n    });\\n\\n    // Initial instructions in console (developers)\\n    console.log('sin/cos 可视化已加载。快捷键: 空格 切换播放, r 重置。');\\n  </script>\",\"css_content\":\":root{\\n      --bg:#f7f9fc;\\n      --panel:#ffffff;\\n      --muted:#666;\\n      --accent:#0b6cff;\\n      --sin:#e44d4d;\\n      --cos:#3aa0c9;\\n      --grid:#e0e6ef;\\n    }\\n    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\\\"Helvetica Neue\\\",Arial;}\\n    body{background:var(--bg);color:#111;display:flex;flex-direction:column;gap:12px;padding:14px;}\\n    h1{margin:0;font-size:18px;}\\n    .container{display:flex;gap:12px;align-items:flex-start;}\\n    .left{flex:1;min-width:520px;background:var(--panel);border-radius:8px;padding:12px;box-shadow:0 1px 3px rgba(0,0,0,0.06);}\\n    .right{width:360px;background:var(--panel);border-radius:8px;padding:12px;box-shadow:0 1px 3px rgba(0,0,0,0.06);}\\n    canvas{width:100%;height:480px;background:linear-gradient(180deg,white, #fbfdff);border-radius:6px;display:block;}\\n    .controls{display:grid;grid-template-columns:1fr 60px;gap:8px;align-items:center;margin-top:10px;}\\n    .control-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;}\\n    label{font-size:13px;color:var(--muted);min-width:90px;}\\n    input[type=\\\"range\\\"]{width:100%;}\\n    .small{font-size:12px;color:var(--muted);}\\n    .legend{display:flex;gap:12px;align-items:center;margin-top:8px;}\\n    .legend .item{display:flex;gap:6px;align-items:center;}\\n    .swatch{width:18px;height:4px;border-radius:2px;}\\n    .btn{background:var(--accent);color:white;padding:8px 10px;border-radius:6px;cursor:pointer;border:0;font-weight:600;}\\n    .btn.secondary{background:#eef3ff;color:var(--accent);font-weight:600;border:0;cursor:pointer;}\\n    .row{display:flex;gap:8px;align-items:center;}\\n    .checkboxes{display:flex;gap:8px;align-items:center;}\\n    .footer{font-size:12px;color:var(--muted);margin-top:8px;}\\n    .eq{background:#f1f6ff;padding:8px;border-radius:6px;font-family:monospace;margin-top:8px;}\\n    .tooltip{position:absolute;background:rgba(18,18,18,0.9);color:white;padding:6px 8px;border-radius:6px;font-size:12px;pointer-events:none;transform:translate(-50%,-120%);white-space:nowrap;z-index:20;}\\n    input[type=\\\"number\\\"]{width:80px;padding:6px;border-radius:6px;border:1px solid #d7dbe8;background:white;}\",\"js_content\":\"// 三角函数可视化脚本\\n    // 说明：将所有逻辑放在此文件中，使用 canvas 绘制并响应 UI 控件。\\n\\n    // --- 帮助函数 ---\\n    function lerp(a,b,t){ return a + (b-a)*t; }\\n    function degToRad(d){ return d * Math.PI / 180; }\\n    function formatNum(v, precision=3){ return Number.parseFloat(v).toFixed(precision); }\\n\\n    // --- DOM ---\\n    const canvas = document.getElementById('plot');\\n    const ctx = canvas.getContext('2d', { alpha: false });\\n    const tooltip = document.getElementById('tooltip');\\n\\n    // Controls\\n    const amplitude = document.getElementById('amplitude');\\n    const frequency = document.getElementById('frequency');\\n    const phase = document.getElementById('phase');\\n    const vshift = document.getElementById('vshift');\\n    const xstart = document.getElementById('xstart');\\n    const xend = document.getElementById('xend');\\n    const resolution = document.getElementById('resolution');\\n    const showSin = document.getElementById('showSin');\\n    const showCos = document.getElementById('showCos');\\n    const showGrid = document.getElementById('showGrid');\\n\\n    const ampVal = document.getElementById('ampVal');\\n    const freqVal = document.getElementById('freqVal');\\n    const phaseVal = document.getElementById('phaseVal');\\n    const vshiftVal = document.getElementById('vshiftVal');\\n    const resVal = document.getElementById('resVal');\\n    const eqText = document.getElementById('equation');\\n    const eqFull = document.getElementById('equationFull');\\n\\n    const playBtn = document.getElementById('playBtn');\\n    const pauseBtn = document.getElementById('pauseBtn');\\n    const animState = document.getElementById('animState');\\n    const speed = document.getElementById('speed');\\n    const speedVal = document.getElementById('speedVal');\\n\\n    const resetBtn = document.getElementById('resetBtn');\\n    const exportBtn = document.getElementById('exportBtn');\\n\\n    // --- 状态 ---\\n    let state = {\\n      A: parseFloat(amplitude.value),\\n      f: parseFloat(frequency.value),\\n      phiDeg: parseFloat(phase.value),\\n      D: parseFloat(vshift.value),\\n      x0: parseFloat(xstart.value),\\n      x1: parseFloat(xend.value),\\n      N: parseInt(resolution.value),\\n      t: 0,\\n      playing: false,\\n      speed: parseFloat(speed.value),\\n      showGrid: showGrid.checked,\\n      showSin: showSin.checked,\\n      showCos: showCos.checked\\n    };\\n\\n    // Canvas logical size handling for crispness\\n    function resizeCanvas(){\\n      const ratio = window.devicePixelRatio || 1;\\n      const rect = canvas.getBoundingClientRect();\\n      canvas.width = Math.max(300, Math.floor(rect.width * ratio));\\n      canvas.height = Math.max(200, Math.floor(rect.height * ratio));\\n      ctx.setTransform(ratio,0,0,ratio,0,0); // scale drawing operations\\n      draw();\\n    }\\n    window.addEventListener('resize', resizeCanvas);\\n    resizeCanvas();\\n\\n    // Update UI labels\\n    function updateUI(){\\n      ampVal.textContent = state.A.toFixed(1);\\n      freqVal.textContent = state.f.toFixed(1);\\n      phaseVal.textContent = state.phiDeg.toFixed(0) + '°';\\n      vshiftVal.textContent = state.D.toFixed(1);\\n      resVal.textContent = state.N;\\n      speedVal.textContent = state.speed.toFixed(1) + 'x';\\n      eqText.textContent = `y = ${state.A} · sin(2π·${state.f}·x / 2π + ${state.phiDeg}°) + ${state.D}`;\\n      eqFull.textContent = `sin: y = A·sin(ωx + φ) + D  （ω = 2πf）。 当前: A=${state.A}, f=${state.f}, φ=${state.phiDeg}°, D=${state.D}`;\\n      animState.textContent = state.playing ? '播放中' : '停止';\\n    }\\n\\n    // Attach input events\\n    amplitude.addEventListener('input', ()=>{ state.A = parseFloat(amplitude.value); updateUI(); draw(); });\\n    frequency.addEventListener('input', ()=>{ state.f = parseFloat(frequency.value); updateUI(); draw(); });\\n    phase.addEventListener('input', ()=>{ state.phiDeg = parseFloat(phase.value); updateUI(); draw(); });\\n    vshift.addEventListener('input', ()=>{ state.D = parseFloat(vshift.value); updateUI(); draw(); });\\n    xstart.addEventListener('change', ()=>{ state.x0 = parseFloat(xstart.value); draw(); });\\n    xend.addEventListener('change', ()=>{ state.x1 = parseFloat(xend.value); draw(); });\\n    resolution.addEventListener('input', ()=>{ state.N = parseInt(resolution.value); updateUI(); draw(); });\\n    showGrid.addEventListener('change', ()=>{ state.showGrid = showGrid.checked; draw(); });\\n    showSin.addEventListener('change', ()=>{ state.showSin = showSin.checked; draw(); });\\n    showCos.addEventListener('change', ()=>{ state.showCos = showCos.checked; draw(); });\\n    speed.addEventListener('input', ()=>{ state.speed = parseFloat(speed.value); updateUI(); });\\n\\n    playBtn.addEventListener('click', ()=>{\\n      state.playing = true;\\n      updateUI();\\n      if(!animating) animate();\\n    });\\n    pauseBtn.addEventListener('click', ()=>{\\n      state.playing = false;\\n      updateUI();\\n    });\\n\\n    resetBtn.addEventListener('click', ()=>{\\n      amplitude.value = 1; frequency.value = 1; phase.value = 0; vshift.value = 0;\\n      xstart.value = -6.28; xend.value = 6.28; resolution.value = 1000; speed.value = 1;\\n      showGrid.checked = true; showSin.checked = true; showCos.checked = true;\\n      // update state\\n      state.A = 1; state.f = 1; state.phiDeg = 0; state.D = 0;\\n      state.x0 = -6.28; state.x1 = 6.28; state.N = 1000; state.speed = 1;\\n      state.showGrid = true; state.showSin = true; state.showCos = true;\\n      updateUI();\\n      draw();\\n    });\\n\\n    exportBtn.addEventListener('click', ()=>{\\n      // Export canvas as PNG\\n      const link = document.createElement('a');\\n      link.download = 'sin_cos_plot.png';\\n      link.href = canvas.toDataURL('image/png');\\n      link.click();\\n    });\\n\\n    // --- Drawing helpers ---\\n    function clearBG(){\\n      ctx.fillStyle = '#ffffff';\\n      ctx.fillRect(0,0,canvas.width,canvas.height);\\n    }\\n\\n    function drawGrid(xToPx, yToPx, pxToX, pxToY, left, top, right, bottom){\\n      if(!state.showGrid) return;\\n      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');\\n      ctx.lineWidth = 1;\\n      // vertical grid lines (x ticks)\\n      const xRange = state.x1 - state.x0;\\n      // choose nice step in x (approx 8-12 vertical lines)\\n      let approx = xRange / 10;\\n      const pow = Math.pow(10, Math.floor(Math.log10(approx)));\\n      let step = pow;\\n      if(approx / pow < 1.5) step = pow / 2;\\n      else if(approx / pow < 3) step = pow;\\n      else step = pow * 2;\\n      ctx.beginPath();\\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\\n        const px = xToPx(x);\\n        ctx.moveTo(px, top);\\n        ctx.lineTo(px, bottom);\\n      }\\n      ctx.stroke();\\n\\n      // horizontal grid lines (y ticks)\\n      // estimate y range from amplitude and vertical shift\\n      const yAbs = Math.max(1, Math.abs(state.A) + Math.abs(state.D));\\n      const yRange = Math.max(2*yAbs, 10);\\n      // choose step\\n      let yStep = 1;\\n      ctx.beginPath();\\n      for(let y = -10; y <= 10; y += 1){\\n        const py = yToPx(y);\\n        ctx.moveTo(left, py);\\n        ctx.lineTo(right, py);\\n      }\\n      ctx.stroke();\\n    }\\n\\n    function drawAxes(xToPx, yToPx, left, top, right, bottom){\\n      ctx.lineWidth = 1.5;\\n      ctx.strokeStyle = '#222';\\n      // x axis (y=0)\\n      const py0 = yToPx(0);\\n      ctx.beginPath();\\n      ctx.moveTo(left, py0);\\n      ctx.lineTo(right, py0);\\n      ctx.stroke();\\n\\n      // y axis (x=0)\\n      const px0 = xToPx(0);\\n      ctx.beginPath();\\n      ctx.moveTo(px0, top);\\n      ctx.lineTo(px0, bottom);\\n      ctx.stroke();\\n\\n      // ticks and labels\\n      ctx.fillStyle = '#222';\\n      ctx.font = '12px system-ui,Arial';\\n      ctx.textAlign = 'center';\\n      ctx.textBaseline = 'top';\\n      // x ticks\\n      const xRange = state.x1 - state.x0;\\n      const approx = xRange / 8;\\n      const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(approx)||1)));\\n      let step = pow;\\n      if(approx / pow < 1.5) step = pow / 2;\\n      else if(approx / pow < 3) step = pow;\\n      else step = pow * 2;\\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\\n        const px = xToPx(x);\\n        ctx.beginPath();\\n        ctx.moveTo(px, yToPx(0)-6);\\n        ctx.lineTo(px, yToPx(0)+6);\\n        ctx.stroke();\\n        ctx.fillText(formatNum(x,2), px, yToPx(0)+8);\\n      }\\n\\n      // y ticks\\n      ctx.textAlign = 'right';\\n      ctx.textBaseline = 'middle';\\n      for(let y = -10; y <= 10; y += 1){\\n        const py = yToPx(y);\\n        ctx.beginPath();\\n        ctx.moveTo(xToPx(0)-6, py);\\n        ctx.lineTo(xToPx(0)+6, py);\\n        ctx.stroke();\\n        ctx.fillText(String(y), xToPx(0)-8, py);\\n      }\\n    }\\n\\n    function plotFunction(points, color, lineWidth=2){\\n      if(points.length < 2) return;\\n      ctx.beginPath();\\n      ctx.moveTo(points[0].x, points[0].y);\\n      for(let i=1;i<points.length;i++){\\n        ctx.lineTo(points[i].x, points[i].y);\\n      }\\n      ctx.strokeStyle = color;\\n      ctx.lineWidth = lineWidth;\\n      ctx.lineJoin = 'round';\\n      ctx.lineCap = 'round';\\n      ctx.stroke();\\n    }\\n\\n    // Convert between data x/y and pixel coords\\n    function createTransform(width, height){\\n      const margin = {left:60, right:20, top:20, bottom:40};\\n      const left = margin.left, right = width - margin.right, top = margin.top, bottom = height - margin.bottom;\\n      const x0 = state.x0, x1 = state.x1;\\n      // estimate y range: use amplitude and vertical shift, but allow more space\\n      const maxY = Math.max(2, Math.abs(state.A) + Math.abs(state.D) + 1);\\n      const yMin = -maxY + state.D, yMax = maxY + state.D;\\n      const yRange = yMax - yMin;\\n      const xToPx = (x) => left + (x - x0) / (x1 - x0) * (right - left);\\n      const yToPx = (y) => bottom - (y - yMin) / yRange * (bottom - top);\\n      const pxToX = (px) => x0 + (px - left) / (right - left) * (x1 - x0);\\n      const pxToY = (py) => {\\n        const y = yMin + (bottom - py) / (bottom - top) * yRange;\\n        return y;\\n      };\\n      return {left, right, top, bottom, xToPx, yToPx, pxToX, pxToY, yMin, yMax};\\n    }\\n\\n    // Compute points for sin and cos\\n    function computePoints(){\\n      const ptsSin = [], ptsCos = [];\\n      const N = Math.max(10, state.N);\\n      const dx = (state.x1 - state.x0) / (N-1);\\n      // angular frequency\\n      const omega = 2 * Math.PI * state.f;\\n      const phi = degToRad(state.phiDeg + state.t); // include animation as additional phase offset\\n      for(let i=0;i<N;i++){\\n        const x = state.x0 + dx * i;\\n        const base = omega * x + phi;\\n        const ys = state.A * Math.sin(base) + state.D;\\n        const yc = state.A * Math.cos(base) + state.D;\\n        ptsSin.push({x,y:ys});\\n        ptsCos.push({x,y:yc});\\n      }\\n      return {ptsSin, ptsCos};\\n    }\\n\\n    // Main draw\\n    function draw(){\\n      clearBG();\\n      // pixel dims\\n      const width = canvas.width / (window.devicePixelRatio || 1);\\n      const height = canvas.height / (window.devicePixelRatio || 1);\\n      const t = createTransform(width, height);\\n      // draw grid\\n      drawGrid(t.xToPx, t.yToPx, t.pxToX, t.pxToY, t.left, t.top, t.right, t.bottom);\\n      // draw axes\\n      drawAxes(t.xToPx, t.yToPx, t.left, t.top, t.right, t.bottom);\\n\\n      // compute real points and draw\\n      const {ptsSin, ptsCos} = computePoints();\\n      // transform to pixel coords\\n      const sinPx = ptsSin.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\\n      const cosPx = ptsCos.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\\n\\n      if(state.showSin){\\n        plotFunction(sinPx, getComputedStyle(document.documentElement).getPropertyValue('--sin'), 2.5);\\n      }\\n      if(state.showCos){\\n        plotFunction(cosPx, getComputedStyle(document.documentElement).getPropertyValue('--cos'), 2.5);\\n      }\\n\\n      // draw border\\n      ctx.strokeStyle = '#e8eef8';\\n      ctx.lineWidth = 1;\\n      ctx.strokeRect(t.left - 0.5, t.top - 0.5, t.right - t.left + 1, t.bottom - t.top + 1);\\n    }\\n\\n    // --- Animation ---\\n    let animating = false;\\n    let lastTime = 0;\\n    function animate(ts){\\n      if(!animating){ animating = true; lastTime = ts || performance.now(); }\\n      if(!state.playing){\\n        animating = false;\\n        return;\\n      }\\n      const now = ts || performance.now();\\n      const dt = (now - lastTime) / 1000; // seconds\\n      lastTime = now;\\n      // advance phase by speed * dt * 60 degrees per second (arbitrary choice)\\n      state.t += state.speed * dt * 120; // degrees\\n      draw();\\n      requestAnimationFrame(animate);\\n    }\\n\\n    // start/stop control ensures only one rAF loop\\n    function startAnimation(){\\n      if(!animating && state.playing) requestAnimationFrame(animate);\\n    }\\n\\n    // Mouse interaction for tooltip\\n    canvas.addEventListener('mousemove', (e)=>{\\n      const rect = canvas.getBoundingClientRect();\\n      const ratio = window.devicePixelRatio || 1;\\n      const px = (e.clientX - rect.left);\\n      const py = (e.clientY - rect.top);\\n      // compute transforms\\n      const width = canvas.width / ratio;\\n      const height = canvas.height / ratio;\\n      const t = createTransform(width, height);\\n      const x = t.pxToX(px);\\n      const yAt = (fn) => {\\n        const omega = 2*Math.PI*state.f;\\n        const phi = degToRad(state.phiDeg + state.t);\\n        return state.A * (fn === 'sin' ? Math.sin(omega * x + phi) : Math.cos(omega * x + phi)) + state.D;\\n      };\\n      if(px < t.left || px > t.right || py < t.top || py > t.bottom){\\n        tooltip.style.display = 'none';\\n        return;\\n      }\\n      let text = `x=${formatNum(x,3)} `;\\n      const lines = [];\\n      if(state.showSin) lines.push(`sin=${formatNum(yAt('sin'),3)}`);\\n      if(state.showCos) lines.push(`cos=${formatNum(yAt('cos'),3)}`);\\n      text += lines.join(' , ');\\n      tooltip.style.display = 'block';\\n      tooltip.textContent = text;\\n      // position tooltip\\n      tooltip.style.left = (rect.left + px) + 'px';\\n      tooltip.style.top = (rect.top + py) + 'px';\\n    });\\n    canvas.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; });\\n\\n    // initialize UI and draw once\\n    updateUI();\\n    draw();\\n\\n    // Start animation if playing toggled by user\\n    // Use interval to advance even without rAF if paused? Already handled in animate.\\n\\n    // Accessibility: keyboard triggers for play/pause\\n    document.addEventListener('keydown', (e)=>{\\n      if(e.key === ' '){ // space toggles play/pause\\n        e.preventDefault();\\n        state.playing = !state.playing;\\n        updateUI();\\n        if(state.playing) startAnimation();\\n      } else if(e.key === 'r'){ resetBtn.click(); }\\n    });\\n\\n    // If user clicks play, start rAF\\n    playBtn.addEventListener('click', startAnimation);\\n\\n    // Ensure draw updates while sliding knobs (some browsers fire input events continuously)\\n    ['input','change'].forEach(evt=>{\\n      [amplitude,frequency,phase,vshift,resolution,xstart,xend].forEach(inp=>{\\n        inp.addEventListener(evt, ()=>{ draw(); });\\n      });\\n    });\\n\\n    // Prevent form submission when pressing enter on number inputs\\n    [xstart,xend].forEach(inp=>{\\n      inp.addEventListener('keydown', (e)=>{\\n        if(e.key === 'Enter'){ e.preventDefault(); draw(); }\\n      });\\n    });\\n\\n    // Initial instructions in console (developers)\\n    console.log('sin/cos 可视化已加载。快捷键: 空格 切换播放, r 重置。');\",\"parameters\":[],\"status\":\"success\"},\"attempts\":2}"
          }
        },
        {
          "stage": "data_analysis",
          "timestamp": "2025-08-09T13:13:19.569Z",
          "dataType": "object",
          "keys": [
            "success",
            "data",
            "attempts"
          ],
          "data": {
            "success": true,
            "data": {
              "experiment_id": "aedb0293-4a9d-4317-b277-9d6634fc172f",
              "title": "sin / cos 函数可视化工具",
              "description": "摘要（基于 Perplexity AI 的信息）:\n- sin 与 cos 是周期性三角函数，常用参数包括振幅（A）、角频率/频率（ω 或 f）、相位（φ）和纵向平移（D）。函数形式常写为 y = A * sin(ωx + φ) + D 或 y = A * cos(ωx + φ) + D。周期为 T = 2π/ω（或以 f 表示频率，则 ω = 2πf）。这些概念将用于交互可视化（来源：Perplexity AI）。\n- 下方 HTML 示例是自包含的、无外部依赖的交互式函数可视化工具，可绘制并动态调整 sin 和 cos 曲线的参数，并具有动画、导出图片和鼠标提示等功能。\n\n完整可运行 HTML（保存为 .html 并在浏览器打开）：",
              "html_content": "<header style=\"display:flex;justify-content:space-between;align-items:center;\">\n    <div>\n      <h1>三角函数可视化工具 — sin & cos</h1>\n      <div class=\"small\">调整参数查看曲线变化。支持动画、导出图片与鼠标读取数值。</div>\n    </div>\n    <div style=\"text-align:right\" class=\"small\">来源: Perplexity AI（概念摘要）</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"left\" aria-label=\"Canvas area\">\n      <div style=\"position:relative;\">\n        <canvas id=\"plot\" width=\"1000\" height=\"600\" role=\"img\" aria-label=\"函数绘图\"></canvas>\n        <div id=\"tooltip\" class=\"tooltip\" style=\"display:none\"></div>\n      </div>\n      <div class=\"legend\" aria-hidden=\"false\">\n        <div class=\"item\"><div class=\"swatch\" style=\"background:var(--sin)\"></div><div class=\"small\">y = A·sin(ωx + φ) + D</div></div>\n        <div class=\"item\"><div class=\"swatch\" style=\"background:var(--cos)\"></div><div class=\"small\">y = A·cos(ωx + φ) + D</div></div>\n      </div>\n      <div class=\"eq\" id=\"equation\">y = 1·sin(1·x + 0°) + 0</div>\n      <div class=\"footer\">提示：移动鼠标在画布上可查看具体坐标（x, y）。</div>\n    </div>\n\n    <aside class=\"right\" aria-label=\"Controls\">\n      <div style=\"display:flex;gap:8px;align-items:center;justify-content:space-between;\">\n        <div style=\"font-weight:600\">参数</div>\n        <div class=\"row\">\n          <button class=\"btn secondary\" id=\"resetBtn\">重置</button>\n          <button class=\"btn\" id=\"exportBtn\" title=\"导出为 PNG\">导出 PNG</button>\n        </div>\n      </div>\n\n      <div style=\"margin-top:8px;\">\n        <div class=\"control-row\">\n          <label for=\"amplitude\">振幅 A</label>\n          <input id=\"amplitude\" type=\"range\" min=\"0\" max=\"5\" step=\"0.1\" value=\"1\" />\n          <div style=\"width:60px;text-align:right\" id=\"ampVal\">1.0</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"frequency\">频率 f</label>\n          <input id=\"frequency\" type=\"range\" min=\"0.1\" max=\"5\" step=\"0.1\" value=\"1\" />\n          <div style=\"width:60px;text-align:right\" id=\"freqVal\">1.0</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"phase\">相位 φ (°)</label>\n          <input id=\"phase\" type=\"range\" min=\"-360\" max=\"360\" step=\"1\" value=\"0\" />\n          <div style=\"width:60px;text-align:right\" id=\"phaseVal\">0°</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"vshift\">纵移 D</label>\n          <input id=\"vshift\" type=\"range\" min=\"-5\" max=\"5\" step=\"0.1\" value=\"0\" />\n          <div style=\"width:60px;text-align:right\" id=\"vshiftVal\">0.0</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"xstart\">x 范围</label>\n          <div style=\"display:flex;gap:6px;align-items:center;\">\n            <input id=\"xstart\" type=\"number\" step=\"0.1\" value=\"-6.28\" aria-label=\"x start\" />\n            <span style=\"color:var(--muted)\">到</span>\n            <input id=\"xend\" type=\"number\" step=\"0.1\" value=\"6.28\" aria-label=\"x end\" />\n          </div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"resolution\">采样点</label>\n          <input id=\"resolution\" type=\"range\" min=\"100\" max=\"4000\" step=\"50\" value=\"1000\" />\n          <div style=\"width:60px;text-align:right\" id=\"resVal\">1000</div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div class=\"checkboxes\" role=\"group\" aria-label=\"显示选项\">\n            <label><input id=\"showSin\" type=\"checkbox\" checked /> sin</label>\n            <label><input id=\"showCos\" type=\"checkbox\" checked /> cos</label>\n            <label><input id=\"showGrid\" type=\"checkbox\" checked /> 网格</label>\n          </div>\n        </div>\n\n        <hr style=\"margin:12px 0\" />\n\n        <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n          <div style=\"font-weight:600\">动画</div>\n          <div class=\"small\" id=\"animState\">停止</div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div class=\"control-row\">\n            <label for=\"animate\">播放</label>\n            <button id=\"playBtn\" class=\"btn secondary\">播放</button>\n            <button id=\"pauseBtn\" class=\"btn secondary\">暂停</button>\n          </div>\n\n          <div class=\"control-row\">\n            <label for=\"speed\">速度</label>\n            <input id=\"speed\" type=\"range\" min=\"-4\" max=\"4\" step=\"0.1\" value=\"1\" />\n            <div style=\"width:60px;text-align:right\" id=\"speedVal\">1.0x</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px;\">\n          <div class=\"small\">方程</div>\n          <div class=\"eq\" id=\"equationFull\">sin: y = A·sin(ωx + φ) + D  （ω = 2πf）</div>\n        </div>\n      </div>\n    </aside>\n  </div>\n\n  <script>\n    // 三角函数可视化脚本\n    // 说明：将所有逻辑放在此文件中，使用 canvas 绘制并响应 UI 控件。\n\n    // --- 帮助函数 ---\n    function lerp(a,b,t){ return a + (b-a)*t; }\n    function degToRad(d){ return d * Math.PI / 180; }\n    function formatNum(v, precision=3){ return Number.parseFloat(v).toFixed(precision); }\n\n    // --- DOM ---\n    const canvas = document.getElementById('plot');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    const tooltip = document.getElementById('tooltip');\n\n    // Controls\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xstart = document.getElementById('xstart');\n    const xend = document.getElementById('xend');\n    const resolution = document.getElementById('resolution');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const showGrid = document.getElementById('showGrid');\n\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const resVal = document.getElementById('resVal');\n    const eqText = document.getElementById('equation');\n    const eqFull = document.getElementById('equationFull');\n\n    const playBtn = document.getElementById('playBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const animState = document.getElementById('animState');\n    const speed = document.getElementById('speed');\n    const speedVal = document.getElementById('speedVal');\n\n    const resetBtn = document.getElementById('resetBtn');\n    const exportBtn = document.getElementById('exportBtn');\n\n    // --- 状态 ---\n    let state = {\n      A: parseFloat(amplitude.value),\n      f: parseFloat(frequency.value),\n      phiDeg: parseFloat(phase.value),\n      D: parseFloat(vshift.value),\n      x0: parseFloat(xstart.value),\n      x1: parseFloat(xend.value),\n      N: parseInt(resolution.value),\n      t: 0,\n      playing: false,\n      speed: parseFloat(speed.value),\n      showGrid: showGrid.checked,\n      showSin: showSin.checked,\n      showCos: showCos.checked\n    };\n\n    // Canvas logical size handling for crispness\n    function resizeCanvas(){\n      const ratio = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.max(300, Math.floor(rect.width * ratio));\n      canvas.height = Math.max(200, Math.floor(rect.height * ratio));\n      ctx.setTransform(ratio,0,0,ratio,0,0); // scale drawing operations\n      draw();\n    }\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n\n    // Update UI labels\n    function updateUI(){\n      ampVal.textContent = state.A.toFixed(1);\n      freqVal.textContent = state.f.toFixed(1);\n      phaseVal.textContent = state.phiDeg.toFixed(0) + '°';\n      vshiftVal.textContent = state.D.toFixed(1);\n      resVal.textContent = state.N;\n      speedVal.textContent = state.speed.toFixed(1) + 'x';\n      eqText.textContent = `y = ${state.A} · sin(2π·${state.f}·x / 2π + ${state.phiDeg}°) + ${state.D}`;\n      eqFull.textContent = `sin: y = A·sin(ωx + φ) + D  （ω = 2πf）。 当前: A=${state.A}, f=${state.f}, φ=${state.phiDeg}°, D=${state.D}`;\n      animState.textContent = state.playing ? '播放中' : '停止';\n    }\n\n    // Attach input events\n    amplitude.addEventListener('input', ()=>{ state.A = parseFloat(amplitude.value); updateUI(); draw(); });\n    frequency.addEventListener('input', ()=>{ state.f = parseFloat(frequency.value); updateUI(); draw(); });\n    phase.addEventListener('input', ()=>{ state.phiDeg = parseFloat(phase.value); updateUI(); draw(); });\n    vshift.addEventListener('input', ()=>{ state.D = parseFloat(vshift.value); updateUI(); draw(); });\n    xstart.addEventListener('change', ()=>{ state.x0 = parseFloat(xstart.value); draw(); });\n    xend.addEventListener('change', ()=>{ state.x1 = parseFloat(xend.value); draw(); });\n    resolution.addEventListener('input', ()=>{ state.N = parseInt(resolution.value); updateUI(); draw(); });\n    showGrid.addEventListener('change', ()=>{ state.showGrid = showGrid.checked; draw(); });\n    showSin.addEventListener('change', ()=>{ state.showSin = showSin.checked; draw(); });\n    showCos.addEventListener('change', ()=>{ state.showCos = showCos.checked; draw(); });\n    speed.addEventListener('input', ()=>{ state.speed = parseFloat(speed.value); updateUI(); });\n\n    playBtn.addEventListener('click', ()=>{\n      state.playing = true;\n      updateUI();\n      if(!animating) animate();\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.playing = false;\n      updateUI();\n    });\n\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1; frequency.value = 1; phase.value = 0; vshift.value = 0;\n      xstart.value = -6.28; xend.value = 6.28; resolution.value = 1000; speed.value = 1;\n      showGrid.checked = true; showSin.checked = true; showCos.checked = true;\n      // update state\n      state.A = 1; state.f = 1; state.phiDeg = 0; state.D = 0;\n      state.x0 = -6.28; state.x1 = 6.28; state.N = 1000; state.speed = 1;\n      state.showGrid = true; state.showSin = true; state.showCos = true;\n      updateUI();\n      draw();\n    });\n\n    exportBtn.addEventListener('click', ()=>{\n      // Export canvas as PNG\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      link.href = canvas.toDataURL('image/png');\n      link.click();\n    });\n\n    // --- Drawing helpers ---\n    function clearBG(){\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n    }\n\n    function drawGrid(xToPx, yToPx, pxToX, pxToY, left, top, right, bottom){\n      if(!state.showGrid) return;\n      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');\n      ctx.lineWidth = 1;\n      // vertical grid lines (x ticks)\n      const xRange = state.x1 - state.x0;\n      // choose nice step in x (approx 8-12 vertical lines)\n      let approx = xRange / 10;\n      const pow = Math.pow(10, Math.floor(Math.log10(approx)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      ctx.beginPath();\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // horizontal grid lines (y ticks)\n      // estimate y range from amplitude and vertical shift\n      const yAbs = Math.max(1, Math.abs(state.A) + Math.abs(state.D));\n      const yRange = Math.max(2*yAbs, 10);\n      // choose step\n      let yStep = 1;\n      ctx.beginPath();\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n    }\n\n    function drawAxes(xToPx, yToPx, left, top, right, bottom){\n      ctx.lineWidth = 1.5;\n      ctx.strokeStyle = '#222';\n      // x axis (y=0)\n      const py0 = yToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(left, py0);\n      ctx.lineTo(right, py0);\n      ctx.stroke();\n\n      // y axis (x=0)\n      const px0 = xToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(px0, top);\n      ctx.lineTo(px0, bottom);\n      ctx.stroke();\n\n      // ticks and labels\n      ctx.fillStyle = '#222';\n      ctx.font = '12px system-ui,Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      // x ticks\n      const xRange = state.x1 - state.x0;\n      const approx = xRange / 8;\n      const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(approx)||1)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.beginPath();\n        ctx.moveTo(px, yToPx(0)-6);\n        ctx.lineTo(px, yToPx(0)+6);\n        ctx.stroke();\n        ctx.fillText(formatNum(x,2), px, yToPx(0)+8);\n      }\n\n      // y ticks\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.beginPath();\n        ctx.moveTo(xToPx(0)-6, py);\n        ctx.lineTo(xToPx(0)+6, py);\n        ctx.stroke();\n        ctx.fillText(String(y), xToPx(0)-8, py);\n      }\n    }\n\n    function plotFunction(points, color, lineWidth=2){\n      if(points.length < 2) return;\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for(let i=1;i<points.length;i++){\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Convert between data x/y and pixel coords\n    function createTransform(width, height){\n      const margin = {left:60, right:20, top:20, bottom:40};\n      const left = margin.left, right = width - margin.right, top = margin.top, bottom = height - margin.bottom;\n      const x0 = state.x0, x1 = state.x1;\n      // estimate y range: use amplitude and vertical shift, but allow more space\n      const maxY = Math.max(2, Math.abs(state.A) + Math.abs(state.D) + 1);\n      const yMin = -maxY + state.D, yMax = maxY + state.D;\n      const yRange = yMax - yMin;\n      const xToPx = (x) => left + (x - x0) / (x1 - x0) * (right - left);\n      const yToPx = (y) => bottom - (y - yMin) / yRange * (bottom - top);\n      const pxToX = (px) => x0 + (px - left) / (right - left) * (x1 - x0);\n      const pxToY = (py) => {\n        const y = yMin + (bottom - py) / (bottom - top) * yRange;\n        return y;\n      };\n      return {left, right, top, bottom, xToPx, yToPx, pxToX, pxToY, yMin, yMax};\n    }\n\n    // Compute points for sin and cos\n    function computePoints(){\n      const ptsSin = [], ptsCos = [];\n      const N = Math.max(10, state.N);\n      const dx = (state.x1 - state.x0) / (N-1);\n      // angular frequency\n      const omega = 2 * Math.PI * state.f;\n      const phi = degToRad(state.phiDeg + state.t); // include animation as additional phase offset\n      for(let i=0;i<N;i++){\n        const x = state.x0 + dx * i;\n        const base = omega * x + phi;\n        const ys = state.A * Math.sin(base) + state.D;\n        const yc = state.A * Math.cos(base) + state.D;\n        ptsSin.push({x,y:ys});\n        ptsCos.push({x,y:yc});\n      }\n      return {ptsSin, ptsCos};\n    }\n\n    // Main draw\n    function draw(){\n      clearBG();\n      // pixel dims\n      const width = canvas.width / (window.devicePixelRatio || 1);\n      const height = canvas.height / (window.devicePixelRatio || 1);\n      const t = createTransform(width, height);\n      // draw grid\n      drawGrid(t.xToPx, t.yToPx, t.pxToX, t.pxToY, t.left, t.top, t.right, t.bottom);\n      // draw axes\n      drawAxes(t.xToPx, t.yToPx, t.left, t.top, t.right, t.bottom);\n\n      // compute real points and draw\n      const {ptsSin, ptsCos} = computePoints();\n      // transform to pixel coords\n      const sinPx = ptsSin.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n      const cosPx = ptsCos.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n\n      if(state.showSin){\n        plotFunction(sinPx, getComputedStyle(document.documentElement).getPropertyValue('--sin'), 2.5);\n      }\n      if(state.showCos){\n        plotFunction(cosPx, getComputedStyle(document.documentElement).getPropertyValue('--cos'), 2.5);\n      }\n\n      // draw border\n      ctx.strokeStyle = '#e8eef8';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(t.left - 0.5, t.top - 0.5, t.right - t.left + 1, t.bottom - t.top + 1);\n    }\n\n    // --- Animation ---\n    let animating = false;\n    let lastTime = 0;\n    function animate(ts){\n      if(!animating){ animating = true; lastTime = ts || performance.now(); }\n      if(!state.playing){\n        animating = false;\n        return;\n      }\n      const now = ts || performance.now();\n      const dt = (now - lastTime) / 1000; // seconds\n      lastTime = now;\n      // advance phase by speed * dt * 60 degrees per second (arbitrary choice)\n      state.t += state.speed * dt * 120; // degrees\n      draw();\n      requestAnimationFrame(animate);\n    }\n\n    // start/stop control ensures only one rAF loop\n    function startAnimation(){\n      if(!animating && state.playing) requestAnimationFrame(animate);\n    }\n\n    // Mouse interaction for tooltip\n    canvas.addEventListener('mousemove', (e)=>{\n      const rect = canvas.getBoundingClientRect();\n      const ratio = window.devicePixelRatio || 1;\n      const px = (e.clientX - rect.left);\n      const py = (e.clientY - rect.top);\n      // compute transforms\n      const width = canvas.width / ratio;\n      const height = canvas.height / ratio;\n      const t = createTransform(width, height);\n      const x = t.pxToX(px);\n      const yAt = (fn) => {\n        const omega = 2*Math.PI*state.f;\n        const phi = degToRad(state.phiDeg + state.t);\n        return state.A * (fn === 'sin' ? Math.sin(omega * x + phi) : Math.cos(omega * x + phi)) + state.D;\n      };\n      if(px < t.left || px > t.right || py < t.top || py > t.bottom){\n        tooltip.style.display = 'none';\n        return;\n      }\n      let text = `x=${formatNum(x,3)} `;\n      const lines = [];\n      if(state.showSin) lines.push(`sin=${formatNum(yAt('sin'),3)}`);\n      if(state.showCos) lines.push(`cos=${formatNum(yAt('cos'),3)}`);\n      text += lines.join(' , ');\n      tooltip.style.display = 'block';\n      tooltip.textContent = text;\n      // position tooltip\n      tooltip.style.left = (rect.left + px) + 'px';\n      tooltip.style.top = (rect.top + py) + 'px';\n    });\n    canvas.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; });\n\n    // initialize UI and draw once\n    updateUI();\n    draw();\n\n    // Start animation if playing toggled by user\n    // Use interval to advance even without rAF if paused? Already handled in animate.\n\n    // Accessibility: keyboard triggers for play/pause\n    document.addEventListener('keydown', (e)=>{\n      if(e.key === ' '){ // space toggles play/pause\n        e.preventDefault();\n        state.playing = !state.playing;\n        updateUI();\n        if(state.playing) startAnimation();\n      } else if(e.key === 'r'){ resetBtn.click(); }\n    });\n\n    // If user clicks play, start rAF\n    playBtn.addEventListener('click', startAnimation);\n\n    // Ensure draw updates while sliding knobs (some browsers fire input events continuously)\n    ['input','change'].forEach(evt=>{\n      [amplitude,frequency,phase,vshift,resolution,xstart,xend].forEach(inp=>{\n        inp.addEventListener(evt, ()=>{ draw(); });\n      });\n    });\n\n    // Prevent form submission when pressing enter on number inputs\n    [xstart,xend].forEach(inp=>{\n      inp.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){ e.preventDefault(); draw(); }\n      });\n    });\n\n    // Initial instructions in console (developers)\n    console.log('sin/cos 可视化已加载。快捷键: 空格 切换播放, r 重置。');\n  </script>",
              "css_content": ":root{\n      --bg:#f7f9fc;\n      --panel:#ffffff;\n      --muted:#666;\n      --accent:#0b6cff;\n      --sin:#e44d4d;\n      --cos:#3aa0c9;\n      --grid:#e0e6ef;\n    }\n    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:var(--bg);color:#111;display:flex;flex-direction:column;gap:12px;padding:14px;}\n    h1{margin:0;font-size:18px;}\n    .container{display:flex;gap:12px;align-items:flex-start;}\n    .left{flex:1;min-width:520px;background:var(--panel);border-radius:8px;padding:12px;box-shadow:0 1px 3px rgba(0,0,0,0.06);}\n    .right{width:360px;background:var(--panel);border-radius:8px;padding:12px;box-shadow:0 1px 3px rgba(0,0,0,0.06);}\n    canvas{width:100%;height:480px;background:linear-gradient(180deg,white, #fbfdff);border-radius:6px;display:block;}\n    .controls{display:grid;grid-template-columns:1fr 60px;gap:8px;align-items:center;margin-top:10px;}\n    .control-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;}\n    label{font-size:13px;color:var(--muted);min-width:90px;}\n    input[type=\"range\"]{width:100%;}\n    .small{font-size:12px;color:var(--muted);}\n    .legend{display:flex;gap:12px;align-items:center;margin-top:8px;}\n    .legend .item{display:flex;gap:6px;align-items:center;}\n    .swatch{width:18px;height:4px;border-radius:2px;}\n    .btn{background:var(--accent);color:white;padding:8px 10px;border-radius:6px;cursor:pointer;border:0;font-weight:600;}\n    .btn.secondary{background:#eef3ff;color:var(--accent);font-weight:600;border:0;cursor:pointer;}\n    .row{display:flex;gap:8px;align-items:center;}\n    .checkboxes{display:flex;gap:8px;align-items:center;}\n    .footer{font-size:12px;color:var(--muted);margin-top:8px;}\n    .eq{background:#f1f6ff;padding:8px;border-radius:6px;font-family:monospace;margin-top:8px;}\n    .tooltip{position:absolute;background:rgba(18,18,18,0.9);color:white;padding:6px 8px;border-radius:6px;font-size:12px;pointer-events:none;transform:translate(-50%,-120%);white-space:nowrap;z-index:20;}\n    input[type=\"number\"]{width:80px;padding:6px;border-radius:6px;border:1px solid #d7dbe8;background:white;}",
              "js_content": "// 三角函数可视化脚本\n    // 说明：将所有逻辑放在此文件中，使用 canvas 绘制并响应 UI 控件。\n\n    // --- 帮助函数 ---\n    function lerp(a,b,t){ return a + (b-a)*t; }\n    function degToRad(d){ return d * Math.PI / 180; }\n    function formatNum(v, precision=3){ return Number.parseFloat(v).toFixed(precision); }\n\n    // --- DOM ---\n    const canvas = document.getElementById('plot');\n    const ctx = canvas.getContext('2d', { alpha: false });\n    const tooltip = document.getElementById('tooltip');\n\n    // Controls\n    const amplitude = document.getElementById('amplitude');\n    const frequency = document.getElementById('frequency');\n    const phase = document.getElementById('phase');\n    const vshift = document.getElementById('vshift');\n    const xstart = document.getElementById('xstart');\n    const xend = document.getElementById('xend');\n    const resolution = document.getElementById('resolution');\n    const showSin = document.getElementById('showSin');\n    const showCos = document.getElementById('showCos');\n    const showGrid = document.getElementById('showGrid');\n\n    const ampVal = document.getElementById('ampVal');\n    const freqVal = document.getElementById('freqVal');\n    const phaseVal = document.getElementById('phaseVal');\n    const vshiftVal = document.getElementById('vshiftVal');\n    const resVal = document.getElementById('resVal');\n    const eqText = document.getElementById('equation');\n    const eqFull = document.getElementById('equationFull');\n\n    const playBtn = document.getElementById('playBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const animState = document.getElementById('animState');\n    const speed = document.getElementById('speed');\n    const speedVal = document.getElementById('speedVal');\n\n    const resetBtn = document.getElementById('resetBtn');\n    const exportBtn = document.getElementById('exportBtn');\n\n    // --- 状态 ---\n    let state = {\n      A: parseFloat(amplitude.value),\n      f: parseFloat(frequency.value),\n      phiDeg: parseFloat(phase.value),\n      D: parseFloat(vshift.value),\n      x0: parseFloat(xstart.value),\n      x1: parseFloat(xend.value),\n      N: parseInt(resolution.value),\n      t: 0,\n      playing: false,\n      speed: parseFloat(speed.value),\n      showGrid: showGrid.checked,\n      showSin: showSin.checked,\n      showCos: showCos.checked\n    };\n\n    // Canvas logical size handling for crispness\n    function resizeCanvas(){\n      const ratio = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.max(300, Math.floor(rect.width * ratio));\n      canvas.height = Math.max(200, Math.floor(rect.height * ratio));\n      ctx.setTransform(ratio,0,0,ratio,0,0); // scale drawing operations\n      draw();\n    }\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n\n    // Update UI labels\n    function updateUI(){\n      ampVal.textContent = state.A.toFixed(1);\n      freqVal.textContent = state.f.toFixed(1);\n      phaseVal.textContent = state.phiDeg.toFixed(0) + '°';\n      vshiftVal.textContent = state.D.toFixed(1);\n      resVal.textContent = state.N;\n      speedVal.textContent = state.speed.toFixed(1) + 'x';\n      eqText.textContent = `y = ${state.A} · sin(2π·${state.f}·x / 2π + ${state.phiDeg}°) + ${state.D}`;\n      eqFull.textContent = `sin: y = A·sin(ωx + φ) + D  （ω = 2πf）。 当前: A=${state.A}, f=${state.f}, φ=${state.phiDeg}°, D=${state.D}`;\n      animState.textContent = state.playing ? '播放中' : '停止';\n    }\n\n    // Attach input events\n    amplitude.addEventListener('input', ()=>{ state.A = parseFloat(amplitude.value); updateUI(); draw(); });\n    frequency.addEventListener('input', ()=>{ state.f = parseFloat(frequency.value); updateUI(); draw(); });\n    phase.addEventListener('input', ()=>{ state.phiDeg = parseFloat(phase.value); updateUI(); draw(); });\n    vshift.addEventListener('input', ()=>{ state.D = parseFloat(vshift.value); updateUI(); draw(); });\n    xstart.addEventListener('change', ()=>{ state.x0 = parseFloat(xstart.value); draw(); });\n    xend.addEventListener('change', ()=>{ state.x1 = parseFloat(xend.value); draw(); });\n    resolution.addEventListener('input', ()=>{ state.N = parseInt(resolution.value); updateUI(); draw(); });\n    showGrid.addEventListener('change', ()=>{ state.showGrid = showGrid.checked; draw(); });\n    showSin.addEventListener('change', ()=>{ state.showSin = showSin.checked; draw(); });\n    showCos.addEventListener('change', ()=>{ state.showCos = showCos.checked; draw(); });\n    speed.addEventListener('input', ()=>{ state.speed = parseFloat(speed.value); updateUI(); });\n\n    playBtn.addEventListener('click', ()=>{\n      state.playing = true;\n      updateUI();\n      if(!animating) animate();\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      state.playing = false;\n      updateUI();\n    });\n\n    resetBtn.addEventListener('click', ()=>{\n      amplitude.value = 1; frequency.value = 1; phase.value = 0; vshift.value = 0;\n      xstart.value = -6.28; xend.value = 6.28; resolution.value = 1000; speed.value = 1;\n      showGrid.checked = true; showSin.checked = true; showCos.checked = true;\n      // update state\n      state.A = 1; state.f = 1; state.phiDeg = 0; state.D = 0;\n      state.x0 = -6.28; state.x1 = 6.28; state.N = 1000; state.speed = 1;\n      state.showGrid = true; state.showSin = true; state.showCos = true;\n      updateUI();\n      draw();\n    });\n\n    exportBtn.addEventListener('click', ()=>{\n      // Export canvas as PNG\n      const link = document.createElement('a');\n      link.download = 'sin_cos_plot.png';\n      link.href = canvas.toDataURL('image/png');\n      link.click();\n    });\n\n    // --- Drawing helpers ---\n    function clearBG(){\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n    }\n\n    function drawGrid(xToPx, yToPx, pxToX, pxToY, left, top, right, bottom){\n      if(!state.showGrid) return;\n      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');\n      ctx.lineWidth = 1;\n      // vertical grid lines (x ticks)\n      const xRange = state.x1 - state.x0;\n      // choose nice step in x (approx 8-12 vertical lines)\n      let approx = xRange / 10;\n      const pow = Math.pow(10, Math.floor(Math.log10(approx)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      ctx.beginPath();\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.moveTo(px, top);\n        ctx.lineTo(px, bottom);\n      }\n      ctx.stroke();\n\n      // horizontal grid lines (y ticks)\n      // estimate y range from amplitude and vertical shift\n      const yAbs = Math.max(1, Math.abs(state.A) + Math.abs(state.D));\n      const yRange = Math.max(2*yAbs, 10);\n      // choose step\n      let yStep = 1;\n      ctx.beginPath();\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.moveTo(left, py);\n        ctx.lineTo(right, py);\n      }\n      ctx.stroke();\n    }\n\n    function drawAxes(xToPx, yToPx, left, top, right, bottom){\n      ctx.lineWidth = 1.5;\n      ctx.strokeStyle = '#222';\n      // x axis (y=0)\n      const py0 = yToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(left, py0);\n      ctx.lineTo(right, py0);\n      ctx.stroke();\n\n      // y axis (x=0)\n      const px0 = xToPx(0);\n      ctx.beginPath();\n      ctx.moveTo(px0, top);\n      ctx.lineTo(px0, bottom);\n      ctx.stroke();\n\n      // ticks and labels\n      ctx.fillStyle = '#222';\n      ctx.font = '12px system-ui,Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      // x ticks\n      const xRange = state.x1 - state.x0;\n      const approx = xRange / 8;\n      const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(approx)||1)));\n      let step = pow;\n      if(approx / pow < 1.5) step = pow / 2;\n      else if(approx / pow < 3) step = pow;\n      else step = pow * 2;\n      for(let x = Math.ceil(state.x0/step)*step; x <= state.x1; x += step){\n        const px = xToPx(x);\n        ctx.beginPath();\n        ctx.moveTo(px, yToPx(0)-6);\n        ctx.lineTo(px, yToPx(0)+6);\n        ctx.stroke();\n        ctx.fillText(formatNum(x,2), px, yToPx(0)+8);\n      }\n\n      // y ticks\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      for(let y = -10; y <= 10; y += 1){\n        const py = yToPx(y);\n        ctx.beginPath();\n        ctx.moveTo(xToPx(0)-6, py);\n        ctx.lineTo(xToPx(0)+6, py);\n        ctx.stroke();\n        ctx.fillText(String(y), xToPx(0)-8, py);\n      }\n    }\n\n    function plotFunction(points, color, lineWidth=2){\n      if(points.length < 2) return;\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for(let i=1;i<points.length;i++){\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.strokeStyle = color;\n      ctx.lineWidth = lineWidth;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Convert between data x/y and pixel coords\n    function createTransform(width, height){\n      const margin = {left:60, right:20, top:20, bottom:40};\n      const left = margin.left, right = width - margin.right, top = margin.top, bottom = height - margin.bottom;\n      const x0 = state.x0, x1 = state.x1;\n      // estimate y range: use amplitude and vertical shift, but allow more space\n      const maxY = Math.max(2, Math.abs(state.A) + Math.abs(state.D) + 1);\n      const yMin = -maxY + state.D, yMax = maxY + state.D;\n      const yRange = yMax - yMin;\n      const xToPx = (x) => left + (x - x0) / (x1 - x0) * (right - left);\n      const yToPx = (y) => bottom - (y - yMin) / yRange * (bottom - top);\n      const pxToX = (px) => x0 + (px - left) / (right - left) * (x1 - x0);\n      const pxToY = (py) => {\n        const y = yMin + (bottom - py) / (bottom - top) * yRange;\n        return y;\n      };\n      return {left, right, top, bottom, xToPx, yToPx, pxToX, pxToY, yMin, yMax};\n    }\n\n    // Compute points for sin and cos\n    function computePoints(){\n      const ptsSin = [], ptsCos = [];\n      const N = Math.max(10, state.N);\n      const dx = (state.x1 - state.x0) / (N-1);\n      // angular frequency\n      const omega = 2 * Math.PI * state.f;\n      const phi = degToRad(state.phiDeg + state.t); // include animation as additional phase offset\n      for(let i=0;i<N;i++){\n        const x = state.x0 + dx * i;\n        const base = omega * x + phi;\n        const ys = state.A * Math.sin(base) + state.D;\n        const yc = state.A * Math.cos(base) + state.D;\n        ptsSin.push({x,y:ys});\n        ptsCos.push({x,y:yc});\n      }\n      return {ptsSin, ptsCos};\n    }\n\n    // Main draw\n    function draw(){\n      clearBG();\n      // pixel dims\n      const width = canvas.width / (window.devicePixelRatio || 1);\n      const height = canvas.height / (window.devicePixelRatio || 1);\n      const t = createTransform(width, height);\n      // draw grid\n      drawGrid(t.xToPx, t.yToPx, t.pxToX, t.pxToY, t.left, t.top, t.right, t.bottom);\n      // draw axes\n      drawAxes(t.xToPx, t.yToPx, t.left, t.top, t.right, t.bottom);\n\n      // compute real points and draw\n      const {ptsSin, ptsCos} = computePoints();\n      // transform to pixel coords\n      const sinPx = ptsSin.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n      const cosPx = ptsCos.map(p => ({x: t.xToPx(p.x), y: t.yToPx(p.y), ox:p.x, oy:p.y}));\n\n      if(state.showSin){\n        plotFunction(sinPx, getComputedStyle(document.documentElement).getPropertyValue('--sin'), 2.5);\n      }\n      if(state.showCos){\n        plotFunction(cosPx, getComputedStyle(document.documentElement).getPropertyValue('--cos'), 2.5);\n      }\n\n      // draw border\n      ctx.strokeStyle = '#e8eef8';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(t.left - 0.5, t.top - 0.5, t.right - t.left + 1, t.bottom - t.top + 1);\n    }\n\n    // --- Animation ---\n    let animating = false;\n    let lastTime = 0;\n    function animate(ts){\n      if(!animating){ animating = true; lastTime = ts || performance.now(); }\n      if(!state.playing){\n        animating = false;\n        return;\n      }\n      const now = ts || performance.now();\n      const dt = (now - lastTime) / 1000; // seconds\n      lastTime = now;\n      // advance phase by speed * dt * 60 degrees per second (arbitrary choice)\n      state.t += state.speed * dt * 120; // degrees\n      draw();\n      requestAnimationFrame(animate);\n    }\n\n    // start/stop control ensures only one rAF loop\n    function startAnimation(){\n      if(!animating && state.playing) requestAnimationFrame(animate);\n    }\n\n    // Mouse interaction for tooltip\n    canvas.addEventListener('mousemove', (e)=>{\n      const rect = canvas.getBoundingClientRect();\n      const ratio = window.devicePixelRatio || 1;\n      const px = (e.clientX - rect.left);\n      const py = (e.clientY - rect.top);\n      // compute transforms\n      const width = canvas.width / ratio;\n      const height = canvas.height / ratio;\n      const t = createTransform(width, height);\n      const x = t.pxToX(px);\n      const yAt = (fn) => {\n        const omega = 2*Math.PI*state.f;\n        const phi = degToRad(state.phiDeg + state.t);\n        return state.A * (fn === 'sin' ? Math.sin(omega * x + phi) : Math.cos(omega * x + phi)) + state.D;\n      };\n      if(px < t.left || px > t.right || py < t.top || py > t.bottom){\n        tooltip.style.display = 'none';\n        return;\n      }\n      let text = `x=${formatNum(x,3)} `;\n      const lines = [];\n      if(state.showSin) lines.push(`sin=${formatNum(yAt('sin'),3)}`);\n      if(state.showCos) lines.push(`cos=${formatNum(yAt('cos'),3)}`);\n      text += lines.join(' , ');\n      tooltip.style.display = 'block';\n      tooltip.textContent = text;\n      // position tooltip\n      tooltip.style.left = (rect.left + px) + 'px';\n      tooltip.style.top = (rect.top + py) + 'px';\n    });\n    canvas.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; });\n\n    // initialize UI and draw once\n    updateUI();\n    draw();\n\n    // Start animation if playing toggled by user\n    // Use interval to advance even without rAF if paused? Already handled in animate.\n\n    // Accessibility: keyboard triggers for play/pause\n    document.addEventListener('keydown', (e)=>{\n      if(e.key === ' '){ // space toggles play/pause\n        e.preventDefault();\n        state.playing = !state.playing;\n        updateUI();\n        if(state.playing) startAnimation();\n      } else if(e.key === 'r'){ resetBtn.click(); }\n    });\n\n    // If user clicks play, start rAF\n    playBtn.addEventListener('click', startAnimation);\n\n    // Ensure draw updates while sliding knobs (some browsers fire input events continuously)\n    ['input','change'].forEach(evt=>{\n      [amplitude,frequency,phase,vshift,resolution,xstart,xend].forEach(inp=>{\n        inp.addEventListener(evt, ()=>{ draw(); });\n      });\n    });\n\n    // Prevent form submission when pressing enter on number inputs\n    [xstart,xend].forEach(inp=>{\n      inp.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){ e.preventDefault(); draw(); }\n      });\n    });\n\n    // Initial instructions in console (developers)\n    console.log('sin/cos 可视化已加载。快捷键: 空格 切换播放, r 重置。');",
              "parameters": [],
              "status": "success"
            },
            "attempts": 2
          }
        },
        {
          "stage": "quality_check",
          "timestamp": "2025-08-09T13:13:19.569Z",
          "checks": {
            "hasCode": false,
            "codeLength": 0,
            "htmlTagsFound": [],
            "syntaxErrors": [],
            "bracketMatching": true,
            "syntaxValid": true
          }
        }
      ],
      "finalResult": {
        "codeGenerated": false,
        "codeLength": 0,
        "hasQualityIssues": false,
        "issues": {
          "htmlTags": 0,
          "bracketErrors": false,
          "syntaxErrors": false
        }
      },
      "success": true,
      "errors": [],
      "endTime": "2025-08-09T13:13:19.569Z",
      "duration": 177610
    }
  ],
  "summary": {
    "total": 3,
    "passed": 3,
    "failed": 0,
    "errors": []
  }
}